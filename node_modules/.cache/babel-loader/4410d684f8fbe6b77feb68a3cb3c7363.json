{"ast":null,"code":"var Container = require('../display/Container'),\n    CONST = require('../const');\n/**\n * The ParticleContainer class is a really fast version of the Container built solely for speed,\n * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that advanced\n * functionality will not work. ParticleContainer implements only the basic object transform (position, scale, rotation).\n * Any other functionality like tinting, masking, etc will not work on sprites in this batch.\n *\n * It's extremely easy to use :\n *\n * ```js\n * var container = new ParticleContainer();\n *\n * for (var i = 0; i < 100; ++i)\n * {\n *     var sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n *     container.addChild(sprite);\n * }\n * ```\n *\n * And here you have a hundred sprites that will be renderer at the speed of light.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n *\n * @param [size=15000] {number} The number of images in the SpriteBatch before it flushes.\n * @param [properties] {object} The properties of children that should be uploaded to the gpu and applied.\n * @param [properties.scale=false] {boolean} When true, scale be uploaded and applied.\n * @param [properties.position=true] {boolean} When true, position be uploaded and applied.\n * @param [properties.rotation=false] {boolean} When true, rotation be uploaded and applied.\n * @param [properties.uvs=false] {boolean} When true, uvs be uploaded and applied.\n * @param [properties.alpha=false] {boolean} When true, alpha be uploaded and applied.\n */\n\n\nfunction ParticleContainer(size, properties) {\n  Container.call(this);\n  /**\n   * Set properties to be dynamic (true) / static (false)\n   *\n   * @member {array}\n   * @private\n   */\n\n  this._properties = [false, true, false, false, false];\n  /**\n   * @member {number}\n   * @private\n   */\n\n  this._size = size || 15000;\n  /**\n   * @member {WebGLBuffer}\n   * @private\n   */\n\n  this._buffers = null;\n  /**\n   * @member {boolean}\n   * @private\n   */\n\n  this._updateStatic = false;\n  /**\n   * @member {boolean}\n   *\n   */\n\n  this.interactiveChildren = false;\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of blendModes.NORMAL to reset the blend mode.\n   *\n   * @member {number}\n   * @default CONST.BLEND_MODES.NORMAL;\n   */\n\n  this.blendMode = CONST.BLEND_MODES.NORMAL;\n  /**\n   * Used for canvas renderering. If true then the elements will be positioned at the nearest pixel. This provides a nice speed boost.\n   *\n   * @member {boolean}\n   * @default true;\n   */\n\n  this.roundPixels = true;\n  this.setProperties(properties);\n}\n\nParticleContainer.prototype = Object.create(Container.prototype);\nParticleContainer.prototype.constructor = ParticleContainer;\nmodule.exports = ParticleContainer;\n/**\n * Sets the private properties array to dynamic / static based on the passed properties object\n *\n * @param properties {object} The properties to be uploaded\n */\n\nParticleContainer.prototype.setProperties = function (properties) {\n  if (properties) {\n    this._properties[0] = 'scale' in properties ? !!properties.scale : this._properties[0];\n    this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];\n    this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];\n    this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];\n    this._properties[4] = 'alpha' in properties ? !!properties.alpha : this._properties[4];\n  }\n};\n/**\n * Updates the object transform for rendering\n *\n * @private\n */\n\n\nParticleContainer.prototype.updateTransform = function () {\n  // TODO don't need to!\n  this.displayObjectUpdateTransform(); //  PIXI.Container.prototype.updateTransform.call( this );\n};\n/**\n * Renders the container using the WebGL renderer\n *\n * @param renderer {WebGLRenderer} The webgl renderer\n * @private\n */\n\n\nParticleContainer.prototype.renderWebGL = function (renderer) {\n  if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {\n    return;\n  }\n\n  renderer.setObjectRenderer(renderer.plugins.particle);\n  renderer.plugins.particle.render(this);\n};\n/**\n * Adds a child to this particle container at a specified index. If the index is out of bounds an error will be thrown\n *\n * @param child {DisplayObject} The child to add\n * @param index {Number} The index to place the child in\n * @return {DisplayObject} The child that was added.\n */\n\n\nParticleContainer.prototype.addChildAt = function (child, index) {\n  // prevent adding self as child\n  if (child === this) {\n    return child;\n  }\n\n  if (index >= 0 && index <= this.children.length) {\n    if (child.parent) {\n      child.parent.removeChild(child);\n    }\n\n    child.parent = this;\n    this.children.splice(index, 0, child);\n    this._updateStatic = true;\n    return child;\n  } else {\n    throw new Error(child + 'addChildAt: The index ' + index + ' supplied is out of bounds ' + this.children.length);\n  }\n};\n/**\n * Removes a child from the specified index position.\n *\n * @param index {Number} The index to get the child from\n * @return {DisplayObject} The child that was removed.\n */\n\n\nParticleContainer.prototype.removeChildAt = function (index) {\n  var child = this.getChildAt(index);\n  child.parent = null;\n  this.children.splice(index, 1);\n  this._updateStatic = true;\n  return child;\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer} The canvas renderer\n * @private\n */\n\n\nParticleContainer.prototype.renderCanvas = function (renderer) {\n  if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) {\n    return;\n  }\n\n  var context = renderer.context;\n  var transform = this.worldTransform;\n  var isRotated = true;\n  var positionX = 0;\n  var positionY = 0;\n  var finalWidth = 0;\n  var finalHeight = 0;\n  context.globalAlpha = this.worldAlpha;\n  this.displayObjectUpdateTransform();\n\n  for (var i = 0; i < this.children.length; ++i) {\n    var child = this.children[i];\n\n    if (!child.visible) {\n      continue;\n    }\n\n    var frame = child.texture.frame;\n    context.globalAlpha = this.worldAlpha * child.alpha;\n\n    if (child.rotation % (Math.PI * 2) === 0) {\n      // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n      if (isRotated) {\n        context.setTransform(transform.a, transform.b, transform.c, transform.d, transform.tx, transform.ty);\n        isRotated = false;\n      }\n\n      positionX = child.anchor.x * (-frame.width * child.scale.x) + child.position.x + 0.5;\n      positionY = child.anchor.y * (-frame.height * child.scale.y) + child.position.y + 0.5;\n      finalWidth = frame.width * child.scale.x;\n      finalHeight = frame.height * child.scale.y;\n    } else {\n      if (!isRotated) {\n        isRotated = true;\n      }\n\n      child.displayObjectUpdateTransform();\n      var childTransform = child.worldTransform;\n\n      if (renderer.roundPixels) {\n        context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx | 0, childTransform.ty | 0);\n      } else {\n        context.setTransform(childTransform.a, childTransform.b, childTransform.c, childTransform.d, childTransform.tx, childTransform.ty);\n      }\n\n      positionX = child.anchor.x * -frame.width + 0.5;\n      positionY = child.anchor.y * -frame.height + 0.5;\n      finalWidth = frame.width;\n      finalHeight = frame.height;\n    }\n\n    context.drawImage(child.texture.baseTexture.source, frame.x, frame.y, frame.width, frame.height, positionX, positionY, finalWidth, finalHeight);\n  }\n};\n/**\n * Destroys the container\n *\n * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well\n */\n\n\nParticleContainer.prototype.destroy = function () {\n  Container.prototype.destroy.apply(this, arguments);\n\n  if (this._buffers) {\n    for (var i = 0; i < this._buffers.length; ++i) {\n      this._buffers[i].destroy();\n    }\n  }\n\n  this._properties = null;\n  this._buffers = null;\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/particles/ParticleContainer.js"],"names":["Container","require","CONST","ParticleContainer","size","properties","call","_properties","_size","_buffers","_updateStatic","interactiveChildren","blendMode","BLEND_MODES","NORMAL","roundPixels","setProperties","prototype","Object","create","constructor","module","exports","scale","position","rotation","uvs","alpha","updateTransform","displayObjectUpdateTransform","renderWebGL","renderer","visible","worldAlpha","children","length","renderable","setObjectRenderer","plugins","particle","render","addChildAt","child","index","parent","removeChild","splice","Error","removeChildAt","getChildAt","renderCanvas","context","transform","worldTransform","isRotated","positionX","positionY","finalWidth","finalHeight","globalAlpha","i","frame","texture","Math","PI","setTransform","a","b","c","d","tx","ty","anchor","x","width","y","height","childTransform","drawImage","baseTexture","source","destroy","apply","arguments"],"mappings":"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","sourcesContent":["var Container = require('../display/Container'),\n    CONST = require('../const');\n\n/**\n * The ParticleContainer class is a really fast version of the Container built solely for speed,\n * so use when you need a lot of sprites or particles. The tradeoff of the ParticleContainer is that advanced\n * functionality will not work. ParticleContainer implements only the basic object transform (position, scale, rotation).\n * Any other functionality like tinting, masking, etc will not work on sprites in this batch.\n *\n * It's extremely easy to use :\n *\n * ```js\n * var container = new ParticleContainer();\n *\n * for (var i = 0; i < 100; ++i)\n * {\n *     var sprite = new PIXI.Sprite.fromImage(\"myImage.png\");\n *     container.addChild(sprite);\n * }\n * ```\n *\n * And here you have a hundred sprites that will be renderer at the speed of light.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n *\n * @param [size=15000] {number} The number of images in the SpriteBatch before it flushes.\n * @param [properties] {object} The properties of children that should be uploaded to the gpu and applied.\n * @param [properties.scale=false] {boolean} When true, scale be uploaded and applied.\n * @param [properties.position=true] {boolean} When true, position be uploaded and applied.\n * @param [properties.rotation=false] {boolean} When true, rotation be uploaded and applied.\n * @param [properties.uvs=false] {boolean} When true, uvs be uploaded and applied.\n * @param [properties.alpha=false] {boolean} When true, alpha be uploaded and applied.\n */\nfunction ParticleContainer(size, properties)\n{\n    Container.call(this);\n\n    /**\n     * Set properties to be dynamic (true) / static (false)\n     *\n     * @member {array}\n     * @private\n     */\n    this._properties = [false, true, false, false, false];\n\n    /**\n     * @member {number}\n     * @private\n     */\n    this._size = size || 15000;\n\n    /**\n     * @member {WebGLBuffer}\n     * @private\n     */\n    this._buffers = null;\n\n    /**\n     * @member {boolean}\n     * @private\n     */\n    this._updateStatic = false;\n\n    /**\n     * @member {boolean}\n     *\n     */\n    this.interactiveChildren = false;\n\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of blendModes.NORMAL to reset the blend mode.\n     *\n     * @member {number}\n     * @default CONST.BLEND_MODES.NORMAL;\n     */\n    this.blendMode = CONST.BLEND_MODES.NORMAL;\n\n    /**\n     * Used for canvas renderering. If true then the elements will be positioned at the nearest pixel. This provides a nice speed boost.\n     *\n     * @member {boolean}\n     * @default true;\n     */\n    this.roundPixels = true;\n\n    this.setProperties(properties);\n}\n\nParticleContainer.prototype = Object.create(Container.prototype);\nParticleContainer.prototype.constructor = ParticleContainer;\nmodule.exports = ParticleContainer;\n\n/**\n * Sets the private properties array to dynamic / static based on the passed properties object\n *\n * @param properties {object} The properties to be uploaded\n */\nParticleContainer.prototype.setProperties = function(properties)\n{\n    if ( properties ) {\n        this._properties[0] = 'scale' in properties ? !!properties.scale : this._properties[0];\n        this._properties[1] = 'position' in properties ? !!properties.position : this._properties[1];\n        this._properties[2] = 'rotation' in properties ? !!properties.rotation : this._properties[2];\n        this._properties[3] = 'uvs' in properties ? !!properties.uvs : this._properties[3];\n        this._properties[4] = 'alpha' in properties ? !!properties.alpha : this._properties[4];\n    }\n};\n\n/**\n * Updates the object transform for rendering\n *\n * @private\n */\nParticleContainer.prototype.updateTransform = function ()\n{\n\n    // TODO don't need to!\n    this.displayObjectUpdateTransform();\n    //  PIXI.Container.prototype.updateTransform.call( this );\n};\n\n/**\n * Renders the container using the WebGL renderer\n *\n * @param renderer {WebGLRenderer} The webgl renderer\n * @private\n */\nParticleContainer.prototype.renderWebGL = function (renderer)\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n    {\n        return;\n    }\n\n    renderer.setObjectRenderer( renderer.plugins.particle );\n    renderer.plugins.particle.render( this );\n};\n\n/**\n * Adds a child to this particle container at a specified index. If the index is out of bounds an error will be thrown\n *\n * @param child {DisplayObject} The child to add\n * @param index {Number} The index to place the child in\n * @return {DisplayObject} The child that was added.\n */\nParticleContainer.prototype.addChildAt = function (child, index)\n{\n    // prevent adding self as child\n    if (child === this)\n    {\n        return child;\n    }\n\n    if (index >= 0 && index <= this.children.length)\n    {\n        if (child.parent)\n        {\n            child.parent.removeChild(child);\n        }\n\n        child.parent = this;\n\n        this.children.splice(index, 0, child);\n\n        this._updateStatic = true;\n\n        return child;\n    }\n    else\n    {\n        throw new Error(child + 'addChildAt: The index '+ index +' supplied is out of bounds ' + this.children.length);\n    }\n};\n\n/**\n * Removes a child from the specified index position.\n *\n * @param index {Number} The index to get the child from\n * @return {DisplayObject} The child that was removed.\n */\nParticleContainer.prototype.removeChildAt = function (index)\n{\n    var child = this.getChildAt(index);\n\n    child.parent = null;\n    this.children.splice(index, 1);\n    this._updateStatic = true;\n\n    return child;\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer} The canvas renderer\n * @private\n */\nParticleContainer.prototype.renderCanvas = function (renderer)\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)\n    {\n        return;\n    }\n\n    var context = renderer.context;\n    var transform = this.worldTransform;\n    var isRotated = true;\n\n    var positionX = 0;\n    var positionY = 0;\n\n    var finalWidth = 0;\n    var finalHeight = 0;\n\n    context.globalAlpha = this.worldAlpha;\n\n    this.displayObjectUpdateTransform();\n\n    for (var i = 0; i < this.children.length; ++i)\n    {\n        var child = this.children[i];\n\n        if (!child.visible)\n        {\n            continue;\n        }\n\n        var frame = child.texture.frame;\n\n        context.globalAlpha = this.worldAlpha * child.alpha;\n\n        if (child.rotation % (Math.PI * 2) === 0)\n        {\n            // this is the fastest  way to optimise! - if rotation is 0 then we can avoid any kind of setTransform call\n            if (isRotated)\n            {\n                context.setTransform(\n                    transform.a,\n                    transform.b,\n                    transform.c,\n                    transform.d,\n                    transform.tx,\n                    transform.ty\n                );\n\n                isRotated = false;\n            }\n\n            positionX = ((child.anchor.x) * (-frame.width * child.scale.x) + child.position.x  + 0.5);\n            positionY = ((child.anchor.y) * (-frame.height * child.scale.y) + child.position.y  + 0.5);\n\n            finalWidth = frame.width * child.scale.x;\n            finalHeight = frame.height * child.scale.y;\n\n        }\n        else\n        {\n            if (!isRotated)\n            {\n                isRotated = true;\n            }\n\n            child.displayObjectUpdateTransform();\n\n            var childTransform = child.worldTransform;\n\n            if (renderer.roundPixels)\n            {\n                context.setTransform(\n                    childTransform.a,\n                    childTransform.b,\n                    childTransform.c,\n                    childTransform.d,\n                    childTransform.tx | 0,\n                    childTransform.ty | 0\n                );\n            }\n            else\n            {\n                context.setTransform(\n                    childTransform.a,\n                    childTransform.b,\n                    childTransform.c,\n                    childTransform.d,\n                    childTransform.tx,\n                    childTransform.ty\n                );\n            }\n\n            positionX = ((child.anchor.x) * (-frame.width) + 0.5);\n            positionY = ((child.anchor.y) * (-frame.height) + 0.5);\n\n            finalWidth = frame.width;\n            finalHeight = frame.height;\n        }\n\n        context.drawImage(\n            child.texture.baseTexture.source,\n            frame.x,\n            frame.y,\n            frame.width,\n            frame.height,\n            positionX,\n            positionY,\n            finalWidth,\n            finalHeight\n        );\n    }\n};\n\n/**\n * Destroys the container\n *\n * @param [destroyChildren=false] {boolean} if set to true, all the children will have their destroy method called as well\n */\nParticleContainer.prototype.destroy = function () {\n    Container.prototype.destroy.apply(this, arguments);\n\n    if (this._buffers) {\n        for (var i = 0; i < this._buffers.length; ++i) {\n            this._buffers[i].destroy();\n        }\n    }\n\n    this._properties = null;\n    this._buffers = null;\n};\n"]},"metadata":{},"sourceType":"script"}