{"ast":null,"code":"var Mesh = require('./Mesh');\n\nvar core = require('../core');\n/**\n * The rope allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (var i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * var rope = new PIXI.Rope(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.Mesh\n * @memberof PIXI.mesh\n * @param {Texture} texture - The texture to use on the rope.\n * @param {Array} points - An array of {Point} objects to construct this rope.\n *\n */\n\n\nfunction Rope(texture, points) {\n  Mesh.call(this, texture);\n  /*\n   * @member {Array} An array of points that determine the rope\n   */\n\n  this.points = points;\n  /*\n   * @member {Float32Array} An array of vertices used to construct this rope.\n   */\n\n  this.vertices = new Float32Array(points.length * 4);\n  /*\n   * @member {Float32Array} The WebGL Uvs of the rope.\n   */\n\n  this.uvs = new Float32Array(points.length * 4);\n  /*\n   * @member {Float32Array} An array containing the color components\n   */\n\n  this.colors = new Float32Array(points.length * 2);\n  /*\n   * @member {Uint16Array} An array containing the indices of the vertices\n   */\n\n  this.indices = new Uint16Array(points.length * 2);\n  /**\n   * Tracker for if the rope is ready to be drawn. Needed because Mesh ctor can\n   * call _onTextureUpdated which could call refresh too early.\n   *\n   * @member {boolean}\n   * @private\n   */\n\n  this._ready = true;\n  this.refresh();\n} // constructor\n\n\nRope.prototype = Object.create(Mesh.prototype);\nRope.prototype.constructor = Rope;\nmodule.exports = Rope;\n/**\n * Refreshes\n *\n */\n\nRope.prototype.refresh = function () {\n  var points = this.points; // if too little points, or texture hasn't got UVs set yet just move on.\n\n  if (points.length < 1 || !this._texture._uvs) {\n    return;\n  }\n\n  var uvs = this.uvs;\n  var indices = this.indices;\n  var colors = this.colors;\n  var textureUvs = this._texture._uvs;\n  var offset = new core.Point(textureUvs.x0, textureUvs.y0);\n  var factor = new core.Point(textureUvs.x2 - textureUvs.x0, textureUvs.y2 - textureUvs.y0);\n  uvs[0] = 0 + offset.x;\n  uvs[1] = 0 + offset.y;\n  uvs[2] = 0 + offset.x;\n  uvs[3] = 1 * factor.y + offset.y;\n  colors[0] = 1;\n  colors[1] = 1;\n  indices[0] = 0;\n  indices[1] = 1;\n  var total = points.length,\n      point,\n      index,\n      amount;\n\n  for (var i = 1; i < total; i++) {\n    point = points[i];\n    index = i * 4; // time to do some smart drawing!\n\n    amount = i / (total - 1);\n    uvs[index] = amount * factor.x + offset.x;\n    uvs[index + 1] = 0 + offset.y;\n    uvs[index + 2] = amount * factor.x + offset.x;\n    uvs[index + 3] = 1 * factor.y + offset.y;\n    index = i * 2;\n    colors[index] = 1;\n    colors[index + 1] = 1;\n    index = i * 2;\n    indices[index] = index;\n    indices[index + 1] = index + 1;\n  }\n\n  this.dirty = true;\n};\n/**\n * Clear texture UVs when new texture is set\n *\n * @private\n */\n\n\nRope.prototype._onTextureUpdate = function () {\n  Mesh.prototype._onTextureUpdate.call(this); // wait for the Rope ctor to finish before calling refresh\n\n\n  if (this._ready) {\n    this.refresh();\n  }\n};\n/**\n * Updates the object transform for rendering\n *\n * @private\n */\n\n\nRope.prototype.updateTransform = function () {\n  var points = this.points;\n\n  if (points.length < 1) {\n    return;\n  }\n\n  var lastPoint = points[0];\n  var nextPoint;\n  var perpX = 0;\n  var perpY = 0; // this.count -= 0.2;\n\n  var vertices = this.vertices;\n  var total = points.length,\n      point,\n      index,\n      ratio,\n      perpLength,\n      num;\n\n  for (var i = 0; i < total; i++) {\n    point = points[i];\n    index = i * 4;\n\n    if (i < points.length - 1) {\n      nextPoint = points[i + 1];\n    } else {\n      nextPoint = point;\n    }\n\n    perpY = -(nextPoint.x - lastPoint.x);\n    perpX = nextPoint.y - lastPoint.y;\n    ratio = (1 - i / (total - 1)) * 10;\n\n    if (ratio > 1) {\n      ratio = 1;\n    }\n\n    perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n    num = this._texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n\n    perpX /= perpLength;\n    perpY /= perpLength;\n    perpX *= num;\n    perpY *= num;\n    vertices[index] = point.x + perpX;\n    vertices[index + 1] = point.y + perpY;\n    vertices[index + 2] = point.x - perpX;\n    vertices[index + 3] = point.y - perpY;\n    lastPoint = point;\n  }\n\n  this.containerUpdateTransform();\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/mesh/Rope.js"],"names":["Mesh","require","core","Rope","texture","points","call","vertices","Float32Array","length","uvs","colors","indices","Uint16Array","_ready","refresh","prototype","Object","create","constructor","module","exports","_texture","_uvs","textureUvs","offset","Point","x0","y0","factor","x2","y2","x","y","total","point","index","amount","i","dirty","_onTextureUpdate","updateTransform","lastPoint","nextPoint","perpX","perpY","ratio","perpLength","num","Math","sqrt","height","containerUpdateTransform"],"mappings":"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","sourcesContent":["var Mesh = require('./Mesh');\nvar core = require('../core');\n\n/**\n * The rope allows you to draw a texture across several points and them manipulate these points\n *\n *```js\n * for (var i = 0; i < 20; i++) {\n *     points.push(new PIXI.Point(i * 50, 0));\n * };\n * var rope = new PIXI.Rope(PIXI.Texture.fromImage(\"snake.png\"), points);\n *  ```\n *\n * @class\n * @extends PIXI.Mesh\n * @memberof PIXI.mesh\n * @param {Texture} texture - The texture to use on the rope.\n * @param {Array} points - An array of {Point} objects to construct this rope.\n *\n */\nfunction Rope(texture, points)\n{\n    Mesh.call(this, texture);\n\n    /*\n     * @member {Array} An array of points that determine the rope\n     */\n    this.points = points;\n\n    /*\n     * @member {Float32Array} An array of vertices used to construct this rope.\n     */\n    this.vertices = new Float32Array(points.length * 4);\n\n    /*\n     * @member {Float32Array} The WebGL Uvs of the rope.\n     */\n    this.uvs = new Float32Array(points.length * 4);\n\n    /*\n     * @member {Float32Array} An array containing the color components\n     */\n    this.colors = new Float32Array(points.length * 2);\n\n    /*\n     * @member {Uint16Array} An array containing the indices of the vertices\n     */\n    this.indices = new Uint16Array(points.length * 2);\n\n    /**\n     * Tracker for if the rope is ready to be drawn. Needed because Mesh ctor can\n     * call _onTextureUpdated which could call refresh too early.\n     *\n     * @member {boolean}\n     * @private\n     */\n     this._ready = true;\n\n     this.refresh();\n}\n\n\n// constructor\nRope.prototype = Object.create(Mesh.prototype);\nRope.prototype.constructor = Rope;\nmodule.exports = Rope;\n\n/**\n * Refreshes\n *\n */\nRope.prototype.refresh = function ()\n{\n    var points = this.points;\n\n    // if too little points, or texture hasn't got UVs set yet just move on.\n    if (points.length < 1 || !this._texture._uvs)\n    {\n        return;\n    }\n\n    var uvs = this.uvs;\n\n    var indices = this.indices;\n    var colors = this.colors;\n\n    var textureUvs = this._texture._uvs;\n    var offset = new core.Point(textureUvs.x0, textureUvs.y0);\n    var factor = new core.Point(textureUvs.x2 - textureUvs.x0, textureUvs.y2 - textureUvs.y0);\n\n    uvs[0] = 0 + offset.x;\n    uvs[1] = 0 + offset.y;\n    uvs[2] = 0 + offset.x;\n    uvs[3] = 1 * factor.y + offset.y;\n\n    colors[0] = 1;\n    colors[1] = 1;\n\n    indices[0] = 0;\n    indices[1] = 1;\n\n    var total = points.length,\n        point, index, amount;\n\n    for (var i = 1; i < total; i++)\n    {\n        point = points[i];\n        index = i * 4;\n        // time to do some smart drawing!\n        amount = i / (total-1);\n\n        uvs[index] = amount * factor.x + offset.x;\n        uvs[index+1] = 0 + offset.y;\n\n        uvs[index+2] = amount * factor.x + offset.x;\n        uvs[index+3] = 1 * factor.y + offset.y;\n\n        index = i * 2;\n        colors[index] = 1;\n        colors[index+1] = 1;\n\n        index = i * 2;\n        indices[index] = index;\n        indices[index + 1] = index + 1;\n    }\n\n    this.dirty = true;\n};\n\n/**\n * Clear texture UVs when new texture is set\n *\n * @private\n */\nRope.prototype._onTextureUpdate = function ()\n{\n    Mesh.prototype._onTextureUpdate.call(this);\n\n    // wait for the Rope ctor to finish before calling refresh\n    if (this._ready) {\n        this.refresh();\n    }\n};\n\n/**\n * Updates the object transform for rendering\n *\n * @private\n */\nRope.prototype.updateTransform = function ()\n{\n    var points = this.points;\n\n    if (points.length < 1)\n    {\n        return;\n    }\n\n    var lastPoint = points[0];\n    var nextPoint;\n    var perpX = 0;\n    var perpY = 0;\n\n    // this.count -= 0.2;\n\n    var vertices = this.vertices;\n    var total = points.length,\n        point, index, ratio, perpLength, num;\n\n    for (var i = 0; i < total; i++)\n    {\n        point = points[i];\n        index = i * 4;\n\n        if (i < points.length-1)\n        {\n            nextPoint = points[i+1];\n        }\n        else\n        {\n            nextPoint = point;\n        }\n\n        perpY = -(nextPoint.x - lastPoint.x);\n        perpX = nextPoint.y - lastPoint.y;\n\n        ratio = (1 - (i / (total-1))) * 10;\n\n        if (ratio > 1)\n        {\n            ratio = 1;\n        }\n\n        perpLength = Math.sqrt(perpX * perpX + perpY * perpY);\n        num = this._texture.height / 2; //(20 + Math.abs(Math.sin((i + this.count) * 0.3) * 50) )* ratio;\n        perpX /= perpLength;\n        perpY /= perpLength;\n\n        perpX *= num;\n        perpY *= num;\n\n        vertices[index] = point.x + perpX;\n        vertices[index+1] = point.y + perpY;\n        vertices[index+2] = point.x - perpX;\n        vertices[index+3] = point.y - perpY;\n\n        lastPoint = point;\n    }\n\n    this.containerUpdateTransform();\n};\n"]},"metadata":{},"sourceType":"script"}