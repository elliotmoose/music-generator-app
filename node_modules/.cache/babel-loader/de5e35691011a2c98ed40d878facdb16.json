{"ast":null,"code":"var Sprite = require('../sprites/Sprite'),\n    Texture = require('../textures/Texture'),\n    math = require('../math'),\n    utils = require('../utils'),\n    CONST = require('../const');\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * A Text can be created directly from a string and a style object\n *\n * ```js\n * var text = new PIXI.Text('This is a pixi text',{font : '24px Arial', fill : 0xff1010, align : 'center'});\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n * @param text {string} The copy that you would like the text to display\n * @param [style] {object} The style parameters\n * @param [style.font] {string} default 'bold 20px Arial' The style and size of the font\n * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'\n * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'\n * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {number} The width at which text will wrap, it needs wordWrap to be set to true\n * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses\n * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text\n * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow\n * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow\n * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will\n *      prevent this from happening by adding padding to the top and bottom of text height.\n * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.\n * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve\n *      spiked text issues. Default is 'miter' (creates a sharp corner).\n * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n *      or increase the spikiness of rendered text.\n */\n\n\nfunction Text(text, style, resolution) {\n  /**\n   * The canvas element that everything is drawn to\n   *\n   * @member {HTMLCanvasElement}\n   */\n  this.canvas = document.createElement('canvas');\n  /**\n   * The canvas 2d context that everything is drawn with\n   * @member {HTMLCanvasElement}\n   */\n\n  this.context = this.canvas.getContext('2d');\n  /**\n   * The resolution of the canvas.\n   * @member {number}\n   */\n\n  this.resolution = resolution || CONST.RESOLUTION;\n  /**\n   * Private tracker for the current text.\n   *\n   * @member {string}\n   * @private\n   */\n\n  this._text = null;\n  /**\n   * Private tracker for the current style.\n   *\n   * @member {object}\n   * @private\n   */\n\n  this._style = null;\n  var texture = Texture.fromCanvas(this.canvas);\n  texture.trim = new math.Rectangle();\n  Sprite.call(this, texture);\n  this.text = text;\n  this.style = style;\n} // constructor\n\n\nText.prototype = Object.create(Sprite.prototype);\nText.prototype.constructor = Text;\nmodule.exports = Text;\nText.fontPropertiesCache = {};\nText.fontPropertiesCanvas = document.createElement('canvas');\nText.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');\nObject.defineProperties(Text.prototype, {\n  /**\n   * The width of the Text, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   * @memberof Text#\n   */\n  width: {\n    get: function () {\n      if (this.dirty) {\n        this.updateText();\n      }\n\n      return this.scale.x * this._texture._frame.width;\n    },\n    set: function (value) {\n      this.scale.x = value / this._texture._frame.width;\n      this._width = value;\n    }\n  },\n\n  /**\n   * The height of the Text, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   * @memberof Text#\n   */\n  height: {\n    get: function () {\n      if (this.dirty) {\n        this.updateText();\n      }\n\n      return this.scale.y * this._texture._frame.height;\n    },\n    set: function (value) {\n      this.scale.y = value / this._texture._frame.height;\n      this._height = value;\n    }\n  },\n\n  /**\n   * Set the style of the text\n   *\n   * @param [style] {object} The style parameters\n   * @param [style.font='bold 20pt Arial'] {string} The style and size of the font\n   * @param [style.fill='black'] {string|number} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'\n   * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n   * @param [style.stroke='black'] {string|number} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'\n   * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n   * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used\n   * @param [style.wordWrapWidth=100] {number} The width at which text will wrap\n   * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses\n   * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text\n   * @param [style.dropShadowColor='#000000'] {string|number} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n   * @param [style.dropShadowAngle=Math.PI/6] {number} Set a angle of the drop shadow\n   * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow\n   * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will\n   *      prevent this from happening by adding padding to the top and bottom of text height.\n   * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.\n   * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve\n   *      spiked text issues. Default is 'miter' (creates a sharp corner).\n   * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n   *      or increase the spikiness of rendered text.\n   * @memberof Text#\n   */\n  style: {\n    get: function () {\n      return this._style;\n    },\n    set: function (style) {\n      style = style || {};\n\n      if (typeof style.fill === 'number') {\n        style.fill = utils.hex2string(style.fill);\n      }\n\n      if (typeof style.stroke === 'number') {\n        style.stroke = utils.hex2string(style.stroke);\n      }\n\n      if (typeof style.dropShadowColor === 'number') {\n        style.dropShadowColor = utils.hex2string(style.dropShadowColor);\n      }\n\n      style.font = style.font || 'bold 20pt Arial';\n      style.fill = style.fill || 'black';\n      style.align = style.align || 'left';\n      style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136\n\n      style.strokeThickness = style.strokeThickness || 0;\n      style.wordWrap = style.wordWrap || false;\n      style.wordWrapWidth = style.wordWrapWidth || 100;\n      style.dropShadow = style.dropShadow || false;\n      style.dropShadowColor = style.dropShadowColor || '#000000';\n      style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;\n      style.dropShadowDistance = style.dropShadowDistance || 5;\n      style.padding = style.padding || 0;\n      style.textBaseline = style.textBaseline || 'alphabetic';\n      style.lineJoin = style.lineJoin || 'miter';\n      style.miterLimit = style.miterLimit || 10;\n      this._style = style;\n      this.dirty = true;\n    }\n  },\n\n  /**\n   * Set the copy for the text object. To split a line you can use '\\n'.\n   *\n   * @param text {string} The copy that you would like the text to display\n   * @memberof Text#\n   */\n  text: {\n    get: function () {\n      return this._text;\n    },\n    set: function (text) {\n      text = text.toString() || ' ';\n\n      if (this._text === text) {\n        return;\n      }\n\n      this._text = text;\n      this.dirty = true;\n    }\n  }\n});\n/**\n * Renders text and updates it when needed\n *\n * @private\n */\n\nText.prototype.updateText = function () {\n  var style = this._style;\n  this.context.font = style.font; // word wrap\n  // preserve original text\n\n  var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text; // split text into lines\n\n  var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/); // calculate text width\n\n  var lineWidths = new Array(lines.length);\n  var maxLineWidth = 0;\n  var fontProperties = this.determineFontProperties(style.font);\n\n  for (var i = 0; i < lines.length; i++) {\n    var lineWidth = this.context.measureText(lines[i]).width;\n    lineWidths[i] = lineWidth;\n    maxLineWidth = Math.max(maxLineWidth, lineWidth);\n  }\n\n  var width = maxLineWidth + style.strokeThickness;\n\n  if (style.dropShadow) {\n    width += style.dropShadowDistance;\n  }\n\n  this.canvas.width = (width + this.context.lineWidth) * this.resolution; // calculate text height\n\n  var lineHeight = this.style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n  var height = lineHeight * lines.length;\n\n  if (style.dropShadow) {\n    height += style.dropShadowDistance;\n  }\n\n  this.canvas.height = (height + this._style.padding * 2) * this.resolution;\n  this.context.scale(this.resolution, this.resolution);\n\n  if (navigator.isCocoonJS) {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  } //this.context.fillStyle=\"#FF0000\";\n  //this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n\n  this.context.font = style.font;\n  this.context.strokeStyle = style.stroke;\n  this.context.lineWidth = style.strokeThickness;\n  this.context.textBaseline = style.textBaseline;\n  this.context.lineJoin = style.lineJoin;\n  this.context.miterLimit = style.miterLimit;\n  var linePositionX;\n  var linePositionY;\n\n  if (style.dropShadow) {\n    this.context.fillStyle = style.dropShadowColor;\n    var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n    var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n\n    for (i = 0; i < lines.length; i++) {\n      linePositionX = style.strokeThickness / 2;\n      linePositionY = style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent;\n\n      if (style.align === 'right') {\n        linePositionX += maxLineWidth - lineWidths[i];\n      } else if (style.align === 'center') {\n        linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n      }\n\n      if (style.fill) {\n        this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset + this._style.padding);\n      }\n    }\n  } //set canvas text styles\n\n\n  this.context.fillStyle = style.fill; //draw lines line by line\n\n  for (i = 0; i < lines.length; i++) {\n    linePositionX = style.strokeThickness / 2;\n    linePositionY = style.strokeThickness / 2 + i * lineHeight + fontProperties.ascent;\n\n    if (style.align === 'right') {\n      linePositionX += maxLineWidth - lineWidths[i];\n    } else if (style.align === 'center') {\n      linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n    }\n\n    if (style.stroke && style.strokeThickness) {\n      this.context.strokeText(lines[i], linePositionX, linePositionY + this._style.padding);\n    }\n\n    if (style.fill) {\n      this.context.fillText(lines[i], linePositionX, linePositionY + this._style.padding);\n    }\n  }\n\n  this.updateTexture();\n};\n/**\n * Updates texture size based on canvas size\n *\n * @private\n */\n\n\nText.prototype.updateTexture = function () {\n  var texture = this._texture;\n  texture.baseTexture.hasLoaded = true;\n  texture.baseTexture.resolution = this.resolution;\n  texture.baseTexture.width = this.canvas.width / this.resolution;\n  texture.baseTexture.height = this.canvas.height / this.resolution;\n  texture.crop.width = texture._frame.width = this.canvas.width / this.resolution;\n  texture.crop.height = texture._frame.height = this.canvas.height / this.resolution;\n  texture.trim.x = 0;\n  texture.trim.y = -this._style.padding;\n  texture.trim.width = texture._frame.width;\n  texture.trim.height = texture._frame.height - this._style.padding * 2;\n  this._width = this.canvas.width / this.resolution;\n  this._height = this.canvas.height / this.resolution;\n  texture.baseTexture.emit('update', texture.baseTexture);\n  this.dirty = false;\n};\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n */\n\n\nText.prototype.renderWebGL = function (renderer) {\n  if (this.dirty) {\n    //this.resolution = 1//renderer.resolution;\n    this.updateText();\n  }\n\n  Sprite.prototype.renderWebGL.call(this, renderer);\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer}\n * @private\n */\n\n\nText.prototype._renderCanvas = function (renderer) {\n  if (this.dirty) {\n    //   this.resolution = 1//renderer.resolution;\n    this.updateText();\n  }\n\n  Sprite.prototype._renderCanvas.call(this, renderer);\n};\n/**\n * Calculates the ascent, descent and fontSize of a given fontStyle\n *\n * @param fontStyle {object}\n * @private\n */\n\n\nText.prototype.determineFontProperties = function (fontStyle) {\n  var properties = Text.fontPropertiesCache[fontStyle];\n\n  if (!properties) {\n    properties = {};\n    var canvas = Text.fontPropertiesCanvas;\n    var context = Text.fontPropertiesContext;\n    context.font = fontStyle;\n    var width = Math.ceil(context.measureText('|MÉq').width);\n    var baseline = Math.ceil(context.measureText('M').width);\n    var height = 2 * baseline;\n    baseline = baseline * 1.4 | 0;\n    canvas.width = width;\n    canvas.height = height;\n    context.fillStyle = '#f00';\n    context.fillRect(0, 0, width, height);\n    context.font = fontStyle;\n    context.textBaseline = 'alphabetic';\n    context.fillStyle = '#000';\n    context.fillText('|MÉq', 0, baseline);\n    var imagedata = context.getImageData(0, 0, width, height).data;\n    var pixels = imagedata.length;\n    var line = width * 4;\n    var i, j;\n    var idx = 0;\n    var stop = false; // ascent. scan from top to bottom until we find a non red pixel\n\n    for (i = 0; i < baseline; i++) {\n      for (j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n\n      if (!stop) {\n        idx += line;\n      } else {\n        break;\n      }\n    }\n\n    properties.ascent = baseline - i;\n    idx = pixels - line;\n    stop = false; // descent. scan from bottom to top until we find a non red pixel\n\n    for (i = height; i > baseline; i--) {\n      for (j = 0; j < line; j += 4) {\n        if (imagedata[idx + j] !== 255) {\n          stop = true;\n          break;\n        }\n      }\n\n      if (!stop) {\n        idx -= line;\n      } else {\n        break;\n      }\n    }\n\n    properties.descent = i - baseline;\n    properties.fontSize = properties.ascent + properties.descent;\n    Text.fontPropertiesCache[fontStyle] = properties;\n  }\n\n  return properties;\n};\n/**\n * Applies newlines to a string to have it optimally fit into the horizontal\n * bounds set by the Text object's wordWrapWidth property.\n *\n * @param text {string}\n * @private\n */\n\n\nText.prototype.wordWrap = function (text) {\n  // Greedy wrapping algorithm that will wrap words as the line grows longer\n  // than its horizontal bounds.\n  var result = '';\n  var lines = text.split('\\n');\n  var wordWrapWidth = this._style.wordWrapWidth;\n\n  for (var i = 0; i < lines.length; i++) {\n    var spaceLeft = wordWrapWidth;\n    var words = lines[i].split(' ');\n\n    for (var j = 0; j < words.length; j++) {\n      var wordWidth = this.context.measureText(words[j]).width;\n      var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;\n\n      if (j === 0 || wordWidthWithSpace > spaceLeft) {\n        // Skip printing the newline if it's the first word of the line that is\n        // greater than the word wrap width.\n        if (j > 0) {\n          result += '\\n';\n        }\n\n        result += words[j];\n        spaceLeft = wordWrapWidth - wordWidth;\n      } else {\n        spaceLeft -= wordWidthWithSpace;\n        result += ' ' + words[j];\n      }\n    }\n\n    if (i < lines.length - 1) {\n      result += '\\n';\n    }\n  }\n\n  return result;\n};\n/**\n * Returns the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n *\n * @param matrix {Matrix} the transformation matrix of the Text\n * @return {Rectangle} the framing rectangle\n */\n\n\nText.prototype.getBounds = function (matrix) {\n  if (this.dirty) {\n    this.updateText();\n  }\n\n  return Sprite.prototype.getBounds.call(this, matrix);\n};\n/**\n * Destroys this text object.\n *\n * @param [destroyBaseTexture=true] {boolean} whether to destroy the base texture as well\n */\n\n\nText.prototype.destroy = function (destroyBaseTexture) {\n  // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n  this.context = null;\n  this.canvas = null;\n  this._style = null;\n\n  this._texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/text/Text.js"],"names":["Sprite","require","Texture","math","utils","CONST","Text","text","style","resolution","canvas","document","createElement","context","getContext","RESOLUTION","_text","_style","texture","fromCanvas","trim","Rectangle","call","prototype","Object","create","constructor","module","exports","fontPropertiesCache","fontPropertiesCanvas","fontPropertiesContext","defineProperties","width","get","dirty","updateText","scale","x","_texture","_frame","set","value","_width","height","y","_height","fill","hex2string","stroke","dropShadowColor","font","align","strokeThickness","wordWrap","wordWrapWidth","dropShadow","dropShadowAngle","Math","PI","dropShadowDistance","padding","textBaseline","lineJoin","miterLimit","toString","outputText","lines","split","lineWidths","Array","length","maxLineWidth","fontProperties","determineFontProperties","i","lineWidth","measureText","max","lineHeight","fontSize","navigator","isCocoonJS","clearRect","strokeStyle","linePositionX","linePositionY","fillStyle","xShadowOffset","cos","yShadowOffset","sin","ascent","fillText","strokeText","updateTexture","baseTexture","hasLoaded","crop","emit","renderWebGL","renderer","_renderCanvas","fontStyle","properties","ceil","baseline","fillRect","imagedata","getImageData","data","pixels","line","j","idx","stop","descent","result","spaceLeft","words","wordWidth","wordWidthWithSpace","getBounds","matrix","destroy","destroyBaseTexture","undefined"],"mappings":"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","sourcesContent":["var Sprite = require('../sprites/Sprite'),\n    Texture = require('../textures/Texture'),\n    math = require('../math'),\n    utils = require('../utils'),\n    CONST = require('../const');\n\n/**\n * A Text Object will create a line or multiple lines of text. To split a line you can use '\\n' in your text string,\n * or add a wordWrap property set to true and and wordWrapWidth property with a value in the style object.\n *\n * A Text can be created directly from a string and a style object\n *\n * ```js\n * var text = new PIXI.Text('This is a pixi text',{font : '24px Arial', fill : 0xff1010, align : 'center'});\n * ```\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI\n * @param text {string} The copy that you would like the text to display\n * @param [style] {object} The style parameters\n * @param [style.font] {string} default 'bold 20px Arial' The style and size of the font\n * @param [style.fill='black'] {String|Number} A canvas fillstyle that will be used on the text e.g 'red', '#00FF00'\n * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n * @param [style.stroke] {String|Number} A canvas fillstyle that will be used on the text stroke e.g 'blue', '#FCFF00'\n * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used\n * @param [style.wordWrapWidth=100] {number} The width at which text will wrap, it needs wordWrap to be set to true\n * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses\n * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text\n * @param [style.dropShadowColor='#000000'] {string} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n * @param [style.dropShadowAngle=Math.PI/4] {number} Set a angle of the drop shadow\n * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow\n * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will\n *      prevent this from happening by adding padding to the top and bottom of text height.\n * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.\n * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve\n *      spiked text issues. Default is 'miter' (creates a sharp corner).\n * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n *      or increase the spikiness of rendered text.\n */\nfunction Text(text, style, resolution)\n{\n    /**\n     * The canvas element that everything is drawn to\n     *\n     * @member {HTMLCanvasElement}\n     */\n    this.canvas = document.createElement('canvas');\n\n    /**\n     * The canvas 2d context that everything is drawn with\n     * @member {HTMLCanvasElement}\n     */\n    this.context = this.canvas.getContext('2d');\n\n    /**\n     * The resolution of the canvas.\n     * @member {number}\n     */\n    this.resolution = resolution || CONST.RESOLUTION;\n\n    /**\n     * Private tracker for the current text.\n     *\n     * @member {string}\n     * @private\n     */\n    this._text = null;\n\n    /**\n     * Private tracker for the current style.\n     *\n     * @member {object}\n     * @private\n     */\n    this._style = null;\n\n    var texture = Texture.fromCanvas(this.canvas);\n    texture.trim = new math.Rectangle();\n    Sprite.call(this, texture);\n\n    this.text = text;\n    this.style = style;\n}\n\n// constructor\nText.prototype = Object.create(Sprite.prototype);\nText.prototype.constructor = Text;\nmodule.exports = Text;\n\nText.fontPropertiesCache = {};\nText.fontPropertiesCanvas = document.createElement('canvas');\nText.fontPropertiesContext = Text.fontPropertiesCanvas.getContext('2d');\n\nObject.defineProperties(Text.prototype, {\n    /**\n     * The width of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof Text#\n     */\n    width: {\n        get: function ()\n        {\n            if (this.dirty)\n            {\n                this.updateText();\n            }\n\n            return this.scale.x * this._texture._frame.width;\n        },\n        set: function (value)\n        {\n            this.scale.x = value / this._texture._frame.width;\n            this._width = value;\n        }\n    },\n\n    /**\n     * The height of the Text, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof Text#\n     */\n    height: {\n        get: function ()\n        {\n            if (this.dirty)\n            {\n                this.updateText();\n            }\n\n            return  this.scale.y * this._texture._frame.height;\n        },\n        set: function (value)\n        {\n            this.scale.y = value / this._texture._frame.height;\n            this._height = value;\n        }\n    },\n\n    /**\n     * Set the style of the text\n     *\n     * @param [style] {object} The style parameters\n     * @param [style.font='bold 20pt Arial'] {string} The style and size of the font\n     * @param [style.fill='black'] {string|number} A canvas fillstyle that will be used on the text eg 'red', '#00FF00'\n     * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect single line text\n     * @param [style.stroke='black'] {string|number} A canvas fillstyle that will be used on the text stroke eg 'blue', '#FCFF00'\n     * @param [style.strokeThickness=0] {number} A number that represents the thickness of the stroke. Default is 0 (no stroke)\n     * @param [style.wordWrap=false] {boolean} Indicates if word wrap should be used\n     * @param [style.wordWrapWidth=100] {number} The width at which text will wrap\n     * @param [style.lineHeight] {number} The line height, a number that represents the vertical space that a letter uses\n     * @param [style.dropShadow=false] {boolean} Set a drop shadow for the text\n     * @param [style.dropShadowColor='#000000'] {string|number} A fill style to be used on the dropshadow e.g 'red', '#00FF00'\n     * @param [style.dropShadowAngle=Math.PI/6] {number} Set a angle of the drop shadow\n     * @param [style.dropShadowDistance=5] {number} Set a distance of the drop shadow\n     * @param [style.padding=0] {number} Occasionally some fonts are cropped on top or bottom. Adding some padding will\n     *      prevent this from happening by adding padding to the top and bottom of text height.\n     * @param [style.textBaseline='alphabetic'] {string} The baseline of the text that is rendered.\n     * @param [style.lineJoin='miter'] {string} The lineJoin property sets the type of corner created, it can resolve\n     *      spiked text issues. Default is 'miter' (creates a sharp corner).\n     * @param [style.miterLimit=10] {number} The miter limit to use when using the 'miter' lineJoin mode. This can reduce\n     *      or increase the spikiness of rendered text.\n     * @memberof Text#\n     */\n    style: {\n        get: function ()\n        {\n            return this._style;\n        },\n        set: function (style)\n        {\n            style = style || {};\n\n            if (typeof style.fill === 'number') {\n                style.fill = utils.hex2string(style.fill);\n            }\n\n            if (typeof style.stroke === 'number') {\n                style.stroke = utils.hex2string(style.stroke);\n            }\n\n            if (typeof style.dropShadowColor === 'number') {\n                style.dropShadowColor = utils.hex2string(style.dropShadowColor);\n            }\n\n            style.font = style.font || 'bold 20pt Arial';\n            style.fill = style.fill || 'black';\n            style.align = style.align || 'left';\n            style.stroke = style.stroke || 'black'; //provide a default, see: https://github.com/GoodBoyDigital/pixi.js/issues/136\n            style.strokeThickness = style.strokeThickness || 0;\n            style.wordWrap = style.wordWrap || false;\n            style.wordWrapWidth = style.wordWrapWidth || 100;\n\n            style.dropShadow = style.dropShadow || false;\n            style.dropShadowColor = style.dropShadowColor || '#000000';\n            style.dropShadowAngle = style.dropShadowAngle || Math.PI / 6;\n            style.dropShadowDistance = style.dropShadowDistance || 5;\n\n            style.padding = style.padding || 0;\n\n            style.textBaseline = style.textBaseline || 'alphabetic';\n\n            style.lineJoin = style.lineJoin || 'miter';\n            style.miterLimit = style.miterLimit || 10;\n\n            this._style = style;\n            this.dirty = true;\n        }\n    },\n\n    /**\n     * Set the copy for the text object. To split a line you can use '\\n'.\n     *\n     * @param text {string} The copy that you would like the text to display\n     * @memberof Text#\n     */\n    text: {\n        get: function()\n        {\n            return this._text;\n        },\n        set: function (text){\n            text = text.toString() || ' ';\n            if (this._text === text)\n            {\n                return;\n            }\n            this._text = text;\n            this.dirty = true;\n        }\n    }\n});\n\n/**\n * Renders text and updates it when needed\n *\n * @private\n */\nText.prototype.updateText = function ()\n{\n    var style = this._style;\n    this.context.font = style.font;\n\n    // word wrap\n    // preserve original text\n    var outputText = style.wordWrap ? this.wordWrap(this._text) : this._text;\n\n    // split text into lines\n    var lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n    // calculate text width\n    var lineWidths = new Array(lines.length);\n    var maxLineWidth = 0;\n    var fontProperties = this.determineFontProperties(style.font);\n    for (var i = 0; i < lines.length; i++)\n    {\n        var lineWidth = this.context.measureText(lines[i]).width;\n        lineWidths[i] = lineWidth;\n        maxLineWidth = Math.max(maxLineWidth, lineWidth);\n    }\n\n    var width = maxLineWidth + style.strokeThickness;\n    if (style.dropShadow)\n    {\n        width += style.dropShadowDistance;\n    }\n\n    this.canvas.width = ( width + this.context.lineWidth ) * this.resolution;\n\n    // calculate text height\n    var lineHeight = this.style.lineHeight || fontProperties.fontSize + style.strokeThickness;\n\n    var height = lineHeight * lines.length;\n    if (style.dropShadow)\n    {\n        height += style.dropShadowDistance;\n    }\n\n    this.canvas.height = ( height + this._style.padding * 2 ) * this.resolution;\n\n    this.context.scale( this.resolution, this.resolution);\n\n    if (navigator.isCocoonJS)\n    {\n        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n\n    }\n\n    //this.context.fillStyle=\"#FF0000\";\n    //this.context.fillRect(0, 0, this.canvas.width, this.canvas.height);\n\n    this.context.font = style.font;\n    this.context.strokeStyle = style.stroke;\n    this.context.lineWidth = style.strokeThickness;\n    this.context.textBaseline = style.textBaseline;\n    this.context.lineJoin = style.lineJoin;\n    this.context.miterLimit = style.miterLimit;\n\n    var linePositionX;\n    var linePositionY;\n\n    if (style.dropShadow)\n    {\n        this.context.fillStyle = style.dropShadowColor;\n\n        var xShadowOffset = Math.cos(style.dropShadowAngle) * style.dropShadowDistance;\n        var yShadowOffset = Math.sin(style.dropShadowAngle) * style.dropShadowDistance;\n\n        for (i = 0; i < lines.length; i++)\n        {\n            linePositionX = style.strokeThickness / 2;\n            linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;\n\n            if (style.align === 'right')\n            {\n                linePositionX += maxLineWidth - lineWidths[i];\n            }\n            else if (style.align === 'center')\n            {\n                linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n            }\n\n            if (style.fill)\n            {\n                this.context.fillText(lines[i], linePositionX + xShadowOffset, linePositionY + yShadowOffset + this._style.padding);\n            }\n        }\n    }\n\n    //set canvas text styles\n    this.context.fillStyle = style.fill;\n\n    //draw lines line by line\n    for (i = 0; i < lines.length; i++)\n    {\n        linePositionX = style.strokeThickness / 2;\n        linePositionY = (style.strokeThickness / 2 + i * lineHeight) + fontProperties.ascent;\n\n        if (style.align === 'right')\n        {\n            linePositionX += maxLineWidth - lineWidths[i];\n        }\n        else if (style.align === 'center')\n        {\n            linePositionX += (maxLineWidth - lineWidths[i]) / 2;\n        }\n\n        if (style.stroke && style.strokeThickness)\n        {\n            this.context.strokeText(lines[i], linePositionX, linePositionY + this._style.padding);\n        }\n\n        if (style.fill)\n        {\n            this.context.fillText(lines[i], linePositionX, linePositionY + this._style.padding);\n        }\n    }\n\n    this.updateTexture();\n};\n\n/**\n * Updates texture size based on canvas size\n *\n * @private\n */\nText.prototype.updateTexture = function ()\n{\n    var texture = this._texture;\n\n    texture.baseTexture.hasLoaded = true;\n    texture.baseTexture.resolution = this.resolution;\n\n    texture.baseTexture.width = this.canvas.width / this.resolution;\n    texture.baseTexture.height = this.canvas.height / this.resolution;\n    texture.crop.width = texture._frame.width = this.canvas.width / this.resolution;\n    texture.crop.height = texture._frame.height = this.canvas.height / this.resolution;\n\n    texture.trim.x = 0;\n    texture.trim.y = -this._style.padding;\n\n    texture.trim.width = texture._frame.width;\n    texture.trim.height = texture._frame.height - this._style.padding*2;\n\n    this._width = this.canvas.width / this.resolution;\n    this._height = this.canvas.height / this.resolution;\n\n    texture.baseTexture.emit('update',  texture.baseTexture);\n\n    this.dirty = false;\n};\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n */\nText.prototype.renderWebGL = function (renderer)\n{\n    if (this.dirty)\n    {\n        //this.resolution = 1//renderer.resolution;\n\n        this.updateText();\n    }\n\n    Sprite.prototype.renderWebGL.call(this, renderer);\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer}\n * @private\n */\nText.prototype._renderCanvas = function (renderer)\n{\n    if (this.dirty)\n    {\n     //   this.resolution = 1//renderer.resolution;\n\n        this.updateText();\n    }\n\n    Sprite.prototype._renderCanvas.call(this, renderer);\n};\n\n/**\n * Calculates the ascent, descent and fontSize of a given fontStyle\n *\n * @param fontStyle {object}\n * @private\n */\nText.prototype.determineFontProperties = function (fontStyle)\n{\n    var properties = Text.fontPropertiesCache[fontStyle];\n\n    if (!properties)\n    {\n        properties = {};\n\n        var canvas = Text.fontPropertiesCanvas;\n        var context = Text.fontPropertiesContext;\n\n        context.font = fontStyle;\n\n        var width = Math.ceil(context.measureText('|MÉq').width);\n        var baseline = Math.ceil(context.measureText('M').width);\n        var height = 2 * baseline;\n\n        baseline = baseline * 1.4 | 0;\n\n        canvas.width = width;\n        canvas.height = height;\n\n        context.fillStyle = '#f00';\n        context.fillRect(0, 0, width, height);\n\n        context.font = fontStyle;\n\n        context.textBaseline = 'alphabetic';\n        context.fillStyle = '#000';\n        context.fillText('|MÉq', 0, baseline);\n\n        var imagedata = context.getImageData(0, 0, width, height).data;\n        var pixels = imagedata.length;\n        var line = width * 4;\n\n        var i, j;\n\n        var idx = 0;\n        var stop = false;\n\n        // ascent. scan from top to bottom until we find a non red pixel\n        for (i = 0; i < baseline; i++)\n        {\n            for (j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop)\n            {\n                idx += line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.ascent = baseline - i;\n\n        idx = pixels - line;\n        stop = false;\n\n        // descent. scan from bottom to top until we find a non red pixel\n        for (i = height; i > baseline; i--)\n        {\n            for (j = 0; j < line; j += 4)\n            {\n                if (imagedata[idx + j] !== 255)\n                {\n                    stop = true;\n                    break;\n                }\n            }\n            if (!stop)\n            {\n                idx -= line;\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        properties.descent = i - baseline;\n        properties.fontSize = properties.ascent + properties.descent;\n\n        Text.fontPropertiesCache[fontStyle] = properties;\n    }\n\n    return properties;\n};\n\n/**\n * Applies newlines to a string to have it optimally fit into the horizontal\n * bounds set by the Text object's wordWrapWidth property.\n *\n * @param text {string}\n * @private\n */\nText.prototype.wordWrap = function (text)\n{\n    // Greedy wrapping algorithm that will wrap words as the line grows longer\n    // than its horizontal bounds.\n    var result = '';\n    var lines = text.split('\\n');\n    var wordWrapWidth = this._style.wordWrapWidth;\n    for (var i = 0; i < lines.length; i++)\n    {\n        var spaceLeft = wordWrapWidth;\n        var words = lines[i].split(' ');\n        for (var j = 0; j < words.length; j++)\n        {\n            var wordWidth = this.context.measureText(words[j]).width;\n            var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;\n            if (j === 0 || wordWidthWithSpace > spaceLeft)\n            {\n                // Skip printing the newline if it's the first word of the line that is\n                // greater than the word wrap width.\n                if (j > 0)\n                {\n                    result += '\\n';\n                }\n                result += words[j];\n                spaceLeft = wordWrapWidth - wordWidth;\n            }\n            else\n            {\n                spaceLeft -= wordWidthWithSpace;\n                result += ' ' + words[j];\n            }\n        }\n\n        if (i < lines.length-1)\n        {\n            result += '\\n';\n        }\n    }\n    return result;\n};\n\n/**\n * Returns the bounds of the Text as a rectangle. The bounds calculation takes the worldTransform into account.\n *\n * @param matrix {Matrix} the transformation matrix of the Text\n * @return {Rectangle} the framing rectangle\n */\nText.prototype.getBounds = function (matrix)\n{\n    if (this.dirty)\n    {\n        this.updateText();\n    }\n\n    return Sprite.prototype.getBounds.call(this, matrix);\n};\n\n/**\n * Destroys this text object.\n *\n * @param [destroyBaseTexture=true] {boolean} whether to destroy the base texture as well\n */\nText.prototype.destroy = function (destroyBaseTexture)\n{\n    // make sure to reset the the context and canvas.. dont want this hanging around in memory!\n    this.context = null;\n    this.canvas = null;\n\n    this._style = null;\n\n    this._texture.destroy(destroyBaseTexture === undefined ? true : destroyBaseTexture);\n};\n"]},"metadata":{},"sourceType":"script"}