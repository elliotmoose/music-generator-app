{"ast":null,"code":"import _regeneratorRuntime from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\n\nexport var OfflineContext = /*#__PURE__*/function (_Context) {\n  _inherits(OfflineContext, _Context);\n\n  var _super = _createSuper(OfflineContext);\n\n  function OfflineContext() {\n    var _this;\n\n    _classCallCheck(this, OfflineContext);\n\n    _this = _super.call(this, {\n      clockSource: \"offline\",\n      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n      lookAhead: 0,\n      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]\n    });\n    _this.name = \"OfflineContext\";\n    /**\n     * An artificial clock source\n     */\n\n    _this._currentTime = 0;\n    _this.isOffline = true;\n    _this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];\n    return _this;\n  }\n  /**\n   * Override the now method to point to the internal clock time\n   */\n\n\n  _createClass(OfflineContext, [{\n    key: \"now\",\n    value: function now() {\n      return this._currentTime;\n    }\n    /**\n     * Same as this.now()\n     */\n\n  }, {\n    key: \"_renderClock\",\n\n    /**\n     * Render just the clock portion of the audio context.\n     */\n    value: function _renderClock(asynchronous) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var index, yieldEvery;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                index = 0;\n\n              case 1:\n                if (!(this._duration - this._currentTime >= 0)) {\n                  _context.next = 11;\n                  break;\n                }\n\n                // invoke all the callbacks on that time\n                this.emit(\"tick\"); // increment the clock in block-sized chunks\n\n                this._currentTime += 128 / this.sampleRate; // yield once a second of audio\n\n                index++;\n                yieldEvery = Math.floor(this.sampleRate / 128);\n\n                if (!(asynchronous && index % yieldEvery === 0)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 9;\n                return new Promise(function (done) {\n                  return setTimeout(done, 1);\n                });\n\n              case 9:\n                _context.next = 1;\n                break;\n\n              case 11:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Render the output of the OfflineContext\n     * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      var asynchronous = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var buffer;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.workletsAreReady();\n\n              case 2:\n                _context2.next = 4;\n                return this._renderClock(asynchronous);\n\n              case 4:\n                _context2.next = 6;\n                return this._context.startRendering();\n\n              case 6:\n                buffer = _context2.sent;\n                return _context2.abrupt(\"return\", new ToneAudioBuffer(buffer));\n\n              case 8:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Close the context\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      return Promise.resolve();\n    }\n  }, {\n    key: \"currentTime\",\n    get: function get() {\n      return this._currentTime;\n    }\n  }]);\n\n  return OfflineContext;\n}(Context);","map":{"version":3,"sources":["../../../../Tone/core/context/OfflineContext.ts"],"names":[],"mappings":";;;;;;AAAA,SAAS,yBAAT,QAA0C,yBAA1C;AACA,SAAS,OAAT,QAAwB,oBAAxB;AAEA,SAAS,qBAAT,QAAsC,2BAAtC;AACA,SAAS,eAAT,QAAgC,mBAAhC;AAEA;;;;;;;;;;AAUG;;AACH,WAAa,cAAb;AAAA;;AAAA;;AAgCC,4BAAA;AAAA;;AAAA;;AAEC,8BAAM;AACL,MAAA,WAAW,EAAE,SADR;AAEL,MAAA,OAAO,EAAE,qBAAqB,CAAC,SAAS,CAAC,CAAD,CAAV,CAArB,GACR,SAAS,CAAC,CAAD,CADD,GACO,yBAAyB,CAAC,SAAS,CAAC,CAAD,CAAV,EAAe,SAAS,CAAC,CAAD,CAAT,GAAe,SAAS,CAAC,CAAD,CAAvC,EAA4C,SAAS,CAAC,CAAD,CAArD,CAHpC;AAIL,MAAA,SAAS,EAAE,CAJN;AAKL,MAAA,cAAc,EAAE,qBAAqB,CAAC,SAAS,CAAC,CAAD,CAAV,CAArB,GACf,MAAM,SAAS,CAAC,CAAD,CAAT,CAAa,UADJ,GACiB,MAAM,SAAS,CAAC,CAAD;AAN3C,KAAN;AAhCQ,UAAA,IAAA,GAAe,gBAAf;AAOT;;AAEG;;AACK,UAAA,YAAA,GAAwB,CAAxB;AAOC,UAAA,SAAA,GAAqB,IAArB;AAwBR,UAAK,SAAL,GAAiB,qBAAqB,CAAC,SAAS,CAAC,CAAD,CAAV,CAArB,GAChB,SAAS,CAAC,CAAD,CAAT,CAAa,MAAb,GAAsB,SAAS,CAAC,CAAD,CAAT,CAAa,UADnB,GACgC,SAAS,CAAC,CAAD,CAD1D;AAXD;AAaC;AAED;;AAEG;;;AAjDJ;AAAA;AAAA,0BAkDI;AACF,aAAO,KAAK,YAAZ;AACA;AAED;;AAEG;;AAxDJ;AAAA;;AA6DC;;AAEG;AA/DJ,iCAgE4B,YAhE5B,EAgEiD;;;;;;;AAC3C,gBAAA,K,GAAQ,C;;;sBACL,KAAK,SAAL,GAAiB,KAAK,YAAtB,IAAsC,C;;;;;AAE5C;AACA,qBAAK,IAAL,CAAU,MAAV,E,CAEA;;AACA,qBAAK,YAAL,IAAqB,MAAM,KAAK,UAAhC,C,CAEA;;AACA,gBAAA,KAAK;AACC,gBAAA,U,GAAa,IAAI,CAAC,KAAL,CAAW,KAAK,UAAL,GAAkB,GAA7B,C;;sBACf,YAAY,IAAI,KAAK,GAAG,UAAR,KAAuB,C;;;;;;AAC1C,uBAAM,IAAI,OAAJ,CAAY,UAAA,IAAI;AAAA,yBAAI,UAAU,CAAC,IAAD,EAAO,CAAP,CAAd;AAAA,iBAAhB,CAAN;;;;;;;;;;;;;AAGF;AAED;;;AAGG;;AAtFJ;AAAA;AAAA,6BAuFiC;AAAA,UAAnB,YAAmB,uEAAJ,IAAI;;;;;;;;AAC/B,uBAAM,KAAK,gBAAL,EAAN;;;;AACA,uBAAM,KAAK,YAAL,CAAkB,YAAlB,CAAN;;;;AACe,uBAAM,KAAK,QAAL,CAAc,cAAd,EAAN;;;AAAT,gBAAA,M;kDACC,IAAI,eAAJ,CAAoB,MAApB,C;;;;;;;;;AACP;AAED;;AAEG;;AAhGJ;AAAA;AAAA,4BAiGM;AACJ,aAAO,OAAO,CAAC,OAAR,EAAP;AACA;AAnGF;AAAA;AAAA,wBAyDgB;AACd,aAAO,KAAK,YAAZ;AACA;AA3DF;;AAAA;AAAA,EAAoC,OAApC","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport class OfflineContext extends Context {\n    constructor() {\n        super({\n            clockSource: \"offline\",\n            context: isOfflineAudioContext(arguments[0]) ?\n                arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n            lookAhead: 0,\n            updateInterval: isOfflineAudioContext(arguments[0]) ?\n                128 / arguments[0].sampleRate : 128 / arguments[2],\n        });\n        this.name = \"OfflineContext\";\n        /**\n         * An artificial clock source\n         */\n        this._currentTime = 0;\n        this.isOffline = true;\n        this._duration = isOfflineAudioContext(arguments[0]) ?\n            arguments[0].length / arguments[0].sampleRate : arguments[1];\n    }\n    /**\n     * Override the now method to point to the internal clock time\n     */\n    now() {\n        return this._currentTime;\n    }\n    /**\n     * Same as this.now()\n     */\n    get currentTime() {\n        return this._currentTime;\n    }\n    /**\n     * Render just the clock portion of the audio context.\n     */\n    _renderClock(asynchronous) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let index = 0;\n            while (this._duration - this._currentTime >= 0) {\n                // invoke all the callbacks on that time\n                this.emit(\"tick\");\n                // increment the clock in block-sized chunks\n                this._currentTime += 128 / this.sampleRate;\n                // yield once a second of audio\n                index++;\n                const yieldEvery = Math.floor(this.sampleRate / 128);\n                if (asynchronous && index % yieldEvery === 0) {\n                    yield new Promise(done => setTimeout(done, 1));\n                }\n            }\n        });\n    }\n    /**\n     * Render the output of the OfflineContext\n     * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n     */\n    render(asynchronous = true) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.workletsAreReady();\n            yield this._renderClock(asynchronous);\n            const buffer = yield this._context.startRendering();\n            return new ToneAudioBuffer(buffer);\n        });\n    }\n    /**\n     * Close the context\n     */\n    close() {\n        return Promise.resolve();\n    }\n}\n//# sourceMappingURL=OfflineContext.js.map"]},"metadata":{},"sourceType":"module"}