{"ast":null,"code":"'use strict';\n/**\n * Smaller version of the async library constructs.\n *\n */\n\nmodule.exports = {\n  eachSeries: asyncEachSeries,\n  queue: asyncQueue\n};\n\nfunction _noop() {\n  /* empty */\n}\n/**\n * Iterates an array in series.\n *\n * @param {*[]} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n */\n\n\nfunction asyncEachSeries(array, iterator, callback) {\n  var i = 0;\n  var len = array.length;\n\n  (function next(err) {\n    if (err || i === len) {\n      if (callback) {\n        callback(err);\n      }\n\n      return;\n    }\n\n    iterator(array[i++], next);\n  })();\n}\n/**\n * Ensures a function is only called once.\n *\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\n\n\nfunction onlyOnce(fn) {\n  return function onceWrapper() {\n    if (fn === null) {\n      throw new Error('Callback was already called.');\n    }\n\n    var callFn = fn;\n    fn = null;\n    callFn.apply(this, arguments);\n  };\n}\n/**\n * Async queue implementation,\n *\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\n\n\nfunction asyncQueue(worker, concurrency) {\n  if (concurrency == null) {\n    // eslint-disable-line no-eq-null,eqeqeq\n    concurrency = 1;\n  } else if (concurrency === 0) {\n    throw new Error('Concurrency must not be zero');\n  }\n\n  var workers = 0;\n  var q = {\n    _tasks: [],\n    concurrency: concurrency,\n    saturated: _noop,\n    unsaturated: _noop,\n    buffer: concurrency / 4,\n    empty: _noop,\n    drain: _noop,\n    error: _noop,\n    started: false,\n    paused: false,\n    push: function (data, callback) {\n      _insert(data, false, callback);\n    },\n    kill: function () {\n      q.drain = _noop;\n      q._tasks = [];\n    },\n    unshift: function (data, callback) {\n      _insert(data, true, callback);\n    },\n    process: function () {\n      while (!q.paused && workers < q.concurrency && q._tasks.length) {\n        var task = q._tasks.shift();\n\n        if (q._tasks.length === 0) {\n          q.empty();\n        }\n\n        workers += 1;\n\n        if (workers === q.concurrency) {\n          q.saturated();\n        }\n\n        worker(task.data, onlyOnce(_next(task)));\n      }\n    },\n    length: function () {\n      return q._tasks.length;\n    },\n    running: function () {\n      return workers;\n    },\n    idle: function () {\n      return q._tasks.length + workers === 0;\n    },\n    pause: function () {\n      if (q.paused === true) {\n        return;\n      }\n\n      q.paused = true;\n    },\n    resume: function () {\n      if (q.paused === false) {\n        return;\n      }\n\n      q.paused = false; // Need to call q.process once per concurrent\n      // worker to preserve full concurrency after pause\n\n      for (var w = 1; w <= q.concurrency; w++) {\n        q.process();\n      }\n    }\n  };\n\n  function _insert(data, insertAtFront, callback) {\n    if (callback != null && typeof callback !== 'function') {\n      // eslint-disable-line no-eq-null,eqeqeq\n      throw new Error('task callback must be a function');\n    }\n\n    q.started = true;\n\n    if (data == null && q.idle()) {\n      // eslint-disable-line no-eq-null,eqeqeq\n      // call drain immediately if there are no tasks\n      setTimeout(function () {\n        q.drain();\n      }, 1);\n      return;\n    }\n\n    var item = {\n      data: data,\n      callback: typeof callback === 'function' ? callback : _noop\n    };\n\n    if (insertAtFront) {\n      q._tasks.unshift(item);\n    } else {\n      q._tasks.push(item);\n    }\n\n    setTimeout(function () {\n      q.process();\n    }, 1);\n  }\n\n  function _next(task) {\n    return function () {\n      workers -= 1;\n      task.callback.apply(task, arguments);\n\n      if (arguments[0] != null) {\n        // eslint-disable-line no-eq-null,eqeqeq\n        q.error(arguments[0], task.data);\n      }\n\n      if (workers <= q.concurrency - q.buffer) {\n        q.unsaturated();\n      }\n\n      if (q.idle()) {\n        q.drain();\n      }\n\n      q.process();\n    };\n  }\n\n  return q;\n}","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/resource-loader/src/async.js"],"names":["module","exports","eachSeries","asyncEachSeries","queue","asyncQueue","_noop","array","iterator","callback","i","len","length","next","err","onlyOnce","fn","onceWrapper","Error","callFn","apply","arguments","worker","concurrency","workers","q","_tasks","saturated","unsaturated","buffer","empty","drain","error","started","paused","push","data","_insert","kill","unshift","process","task","shift","_next","running","idle","pause","resume","w","insertAtFront","setTimeout","item"],"mappings":"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","sourcesContent":["'use strict';\n\n/**\n * Smaller version of the async library constructs.\n *\n */\n\nmodule.exports = {\n    eachSeries: asyncEachSeries,\n    queue: asyncQueue\n};\n\nfunction _noop() { /* empty */ }\n\n/**\n * Iterates an array in series.\n *\n * @param {*[]} array - Array to iterate.\n * @param {function} iterator - Function to call for each element.\n * @param {function} callback - Function to call when done, or on error.\n */\nfunction asyncEachSeries(array, iterator, callback) {\n    var i = 0;\n    var len = array.length;\n\n    (function next(err) {\n        if (err || i === len) {\n            if (callback) {\n                callback(err);\n            }\n\n            return;\n        }\n\n        iterator(array[i++], next);\n    })();\n}\n\n/**\n * Ensures a function is only called once.\n *\n * @param {function} fn - The function to wrap.\n * @return {function} The wrapping function.\n */\nfunction onlyOnce(fn) {\n    return function onceWrapper() {\n        if (fn === null) {\n            throw new Error('Callback was already called.');\n        }\n\n        var callFn = fn;\n\n        fn = null;\n        callFn.apply(this, arguments);\n    };\n}\n\n/**\n * Async queue implementation,\n *\n * @param {function} worker - The worker function to call for each task.\n * @param {number} concurrency - How many workers to run in parrallel.\n * @return {*} The async queue object.\n */\nfunction asyncQueue(worker, concurrency) {\n    if (concurrency == null) { // eslint-disable-line no-eq-null,eqeqeq\n        concurrency = 1;\n    }\n    else if (concurrency === 0) {\n        throw new Error('Concurrency must not be zero');\n    }\n\n    var workers = 0;\n    var q = {\n        _tasks: [],\n        concurrency: concurrency,\n        saturated: _noop,\n        unsaturated: _noop,\n        buffer: concurrency / 4,\n        empty: _noop,\n        drain: _noop,\n        error: _noop,\n        started: false,\n        paused: false,\n        push: function (data, callback) {\n            _insert(data, false, callback);\n        },\n        kill: function () {\n            q.drain = _noop;\n            q._tasks = [];\n        },\n        unshift: function (data, callback) {\n            _insert(data, true, callback);\n        },\n        process: function () {\n            while (!q.paused && workers < q.concurrency && q._tasks.length) {\n                var task = q._tasks.shift();\n\n                if (q._tasks.length === 0) {\n                    q.empty();\n                }\n\n                workers += 1;\n\n                if (workers === q.concurrency) {\n                    q.saturated();\n                }\n\n                worker(task.data, onlyOnce(_next(task)));\n            }\n        },\n        length: function () {\n            return q._tasks.length;\n        },\n        running: function () {\n            return workers;\n        },\n        idle: function () {\n            return q._tasks.length + workers === 0;\n        },\n        pause: function () {\n            if (q.paused === true) {\n                return;\n            }\n\n            q.paused = true;\n        },\n        resume: function () {\n            if (q.paused === false) {\n                return;\n            }\n\n            q.paused = false;\n\n            // Need to call q.process once per concurrent\n            // worker to preserve full concurrency after pause\n            for (var w = 1; w <= q.concurrency; w++) {\n                q.process();\n            }\n        }\n    };\n\n    function _insert(data, insertAtFront, callback) {\n        if (callback != null && typeof callback !== 'function') { // eslint-disable-line no-eq-null,eqeqeq\n            throw new Error('task callback must be a function');\n        }\n\n        q.started = true;\n\n        if (data == null && q.idle()) { // eslint-disable-line no-eq-null,eqeqeq\n            // call drain immediately if there are no tasks\n            setTimeout(function () {\n                q.drain();\n            }, 1);\n\n            return;\n        }\n\n        var item = {\n            data: data,\n            callback: typeof callback === 'function' ? callback : _noop\n        };\n\n        if (insertAtFront) {\n            q._tasks.unshift(item);\n        }\n        else {\n            q._tasks.push(item);\n        }\n\n        setTimeout(function () {\n            q.process();\n        }, 1);\n    }\n\n    function _next(task) {\n        return function () {\n            workers -= 1;\n\n            task.callback.apply(task, arguments);\n\n            if (arguments[0] != null) { // eslint-disable-line no-eq-null,eqeqeq\n                q.error(arguments[0], task.data);\n            }\n\n            if (workers <= (q.concurrency - q.buffer)) {\n                q.unsaturated();\n            }\n\n            if (q.idle()) {\n                q.drain();\n            }\n\n            q.process();\n        };\n    }\n\n    return q;\n}\n"]},"metadata":{},"sourceType":"script"}