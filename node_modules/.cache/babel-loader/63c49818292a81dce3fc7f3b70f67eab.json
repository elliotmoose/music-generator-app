{"ast":null,"code":"import _regeneratorRuntime from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _slicedToArray from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { __awaiter } from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\n\nexport var Oscillator = /*#__PURE__*/function (_Source) {\n  _inherits(Oscillator, _Source);\n\n  var _super = _createSuper(Oscillator);\n\n  function Oscillator() {\n    var _this;\n\n    _classCallCheck(this, Oscillator);\n\n    _this = _super.call(this, optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    _this.name = \"Oscillator\";\n    /**\n     * the main oscillator\n     */\n\n    _this._oscillator = null;\n    var options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    _this.frequency = new Signal({\n      context: _this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    readOnly(_assertThisInitialized(_this), \"frequency\");\n    _this.detune = new Signal({\n      context: _this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(_assertThisInitialized(_this), \"detune\");\n    _this._partials = options.partials;\n    _this._partialCount = options.partialCount;\n    _this._type = options.type;\n\n    if (options.partialCount && options.type !== \"custom\") {\n      _this._type = _this.baseType + options.partialCount.toString();\n    }\n\n    _this.phase = options.phase;\n    return _this;\n  }\n\n  _createClass(Oscillator, [{\n    key: \"_start\",\n\n    /**\n     * start the oscillator\n     */\n    value: function _start(time) {\n      var _this2 = this;\n\n      var computedTime = this.toSeconds(time); // new oscillator with previous values\n\n      var oscillator = new ToneOscillatorNode({\n        context: this.context,\n        onended: function onended() {\n          return _this2.onstop(_this2);\n        }\n      });\n      this._oscillator = oscillator;\n\n      if (this._wave) {\n        this._oscillator.setPeriodicWave(this._wave);\n      } else {\n        this._oscillator.type = this._type;\n      } // connect the control signal to the oscillator frequency & detune\n\n\n      this._oscillator.connect(this.output);\n\n      this.frequency.connect(this._oscillator.frequency);\n      this.detune.connect(this._oscillator.detune); // start the oscillator\n\n      this._oscillator.start(computedTime);\n    }\n    /**\n     * stop the oscillator\n     */\n\n  }, {\n    key: \"_stop\",\n    value: function _stop(time) {\n      var computedTime = this.toSeconds(time);\n\n      if (this._oscillator) {\n        this._oscillator.stop(computedTime);\n      }\n    }\n    /**\n     * Restart the oscillator. Does not stop the oscillator, but instead\n     * just cancels any scheduled 'stop' from being invoked.\n     */\n\n  }, {\n    key: \"_restart\",\n    value: function _restart(time) {\n      var computedTime = this.toSeconds(time);\n      this.log(\"restart\", computedTime);\n\n      if (this._oscillator) {\n        this._oscillator.cancelStop();\n      }\n\n      this._state.cancel(computedTime);\n\n      return this;\n    }\n    /**\n     * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n     * will also affect the oscillators frequency.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * osc.frequency.value = 440;\n     * // the ratio between the bpm and the frequency will be maintained\n     * osc.syncFrequency();\n     * // double the tempo\n     * Tone.Transport.bpm.value *= 2;\n     * // the frequency of the oscillator is doubled to 880\n     */\n\n  }, {\n    key: \"syncFrequency\",\n    value: function syncFrequency() {\n      this.context.transport.syncSignal(this.frequency);\n      return this;\n    }\n    /**\n     * Unsync the oscillator's frequency from the Transport.\n     * See Oscillator.syncFrequency\n     */\n\n  }, {\n    key: \"unsyncFrequency\",\n    value: function unsyncFrequency() {\n      this.context.transport.unsyncSignal(this.frequency);\n      return this;\n    }\n    /**\n     * Get a cached periodic wave. Avoids having to recompute\n     * the oscillator values when they have already been computed\n     * with the same values.\n     */\n\n  }, {\n    key: \"_getCachedPeriodicWave\",\n    value: function _getCachedPeriodicWave() {\n      var _this3 = this;\n\n      if (this._type === \"custom\") {\n        var oscProps = Oscillator._periodicWaveCache.find(function (description) {\n          return description.phase === _this3._phase && deepEquals(description.partials, _this3._partials);\n        });\n\n        return oscProps;\n      } else {\n        var _oscProps = Oscillator._periodicWaveCache.find(function (description) {\n          return description.type === _this3._type && description.phase === _this3._phase;\n        });\n\n        this._partialCount = _oscProps ? _oscProps.partialCount : this._partialCount;\n        return _oscProps;\n      }\n    }\n  }, {\n    key: \"_getRealImaginary\",\n\n    /**\n     * Returns the real and imaginary components based\n     * on the oscillator type.\n     * @returns [real: Float32Array, imaginary: Float32Array]\n     */\n    value: function _getRealImaginary(type, phase) {\n      var fftSize = 4096;\n      var periodicWaveSize = fftSize / 2;\n      var real = new Float32Array(periodicWaveSize);\n      var imag = new Float32Array(periodicWaveSize);\n      var partialCount = 1;\n\n      if (type === \"custom\") {\n        partialCount = this._partials.length + 1;\n        this._partialCount = this._partials.length;\n        periodicWaveSize = partialCount; // if the partial count is 0, don't bother doing any computation\n\n        if (this._partials.length === 0) {\n          return [real, imag];\n        }\n      } else {\n        var partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\n        if (partial) {\n          partialCount = parseInt(partial[2], 10) + 1;\n          this._partialCount = parseInt(partial[2], 10);\n          type = partial[1];\n          partialCount = Math.max(partialCount, 2);\n          periodicWaveSize = partialCount;\n        } else {\n          this._partialCount = 0;\n        }\n\n        this._partials = [];\n      }\n\n      for (var n = 1; n < periodicWaveSize; ++n) {\n        var piFactor = 2 / (n * Math.PI);\n        var b = void 0;\n\n        switch (type) {\n          case \"sine\":\n            b = n <= partialCount ? 1 : 0;\n            this._partials[n - 1] = b;\n            break;\n\n          case \"square\":\n            b = n & 1 ? 2 * piFactor : 0;\n            this._partials[n - 1] = b;\n            break;\n\n          case \"sawtooth\":\n            b = piFactor * (n & 1 ? 1 : -1);\n            this._partials[n - 1] = b;\n            break;\n\n          case \"triangle\":\n            if (n & 1) {\n              b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);\n            } else {\n              b = 0;\n            }\n\n            this._partials[n - 1] = b;\n            break;\n\n          case \"custom\":\n            b = this._partials[n - 1];\n            break;\n\n          default:\n            throw new TypeError(\"Oscillator: invalid type: \" + type);\n        }\n\n        if (b !== 0) {\n          real[n] = -b * Math.sin(phase * n);\n          imag[n] = b * Math.cos(phase * n);\n        } else {\n          real[n] = 0;\n          imag[n] = 0;\n        }\n      }\n\n      return [real, imag];\n    }\n    /**\n     * Compute the inverse FFT for a given phase.\n     */\n\n  }, {\n    key: \"_inverseFFT\",\n    value: function _inverseFFT(real, imag, phase) {\n      var sum = 0;\n      var len = real.length;\n\n      for (var i = 0; i < len; i++) {\n        sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n      }\n\n      return sum;\n    }\n    /**\n     * Returns the initial value of the oscillator when stopped.\n     * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n     */\n\n  }, {\n    key: \"getInitialValue\",\n    value: function getInitialValue() {\n      var _this$_getRealImagina = this._getRealImaginary(this._type, 0),\n          _this$_getRealImagina2 = _slicedToArray(_this$_getRealImagina, 2),\n          real = _this$_getRealImagina2[0],\n          imag = _this$_getRealImagina2[1];\n\n      var maxValue = 0;\n      var twoPi = Math.PI * 2;\n      var testPositions = 32; // check for peaks in 16 places\n\n      for (var i = 0; i < testPositions; i++) {\n        maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);\n      }\n\n      return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n    }\n  }, {\n    key: \"asArray\",\n    value: function asArray() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", generateWaveform(this, length));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Oscillator.prototype), \"dispose\", this).call(this);\n\n      if (this._oscillator !== null) {\n        this._oscillator.dispose();\n      }\n\n      this._wave = undefined;\n      this.frequency.dispose();\n      this.detune.dispose();\n      return this;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      this._type = type;\n      var isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\n      if (this._phase === 0 && isBasicType) {\n        this._wave = undefined;\n        this._partialCount = 0; // just go with the basic approach\n\n        if (this._oscillator !== null) {\n          // already tested that it's a basic type\n          this._oscillator.type = type;\n        }\n      } else {\n        // first check if the value is cached\n        var cache = this._getCachedPeriodicWave();\n\n        if (isDefined(cache)) {\n          var partials = cache.partials,\n              wave = cache.wave;\n          this._wave = wave;\n          this._partials = partials;\n\n          if (this._oscillator !== null) {\n            this._oscillator.setPeriodicWave(this._wave);\n          }\n        } else {\n          var _this$_getRealImagina3 = this._getRealImaginary(type, this._phase),\n              _this$_getRealImagina4 = _slicedToArray(_this$_getRealImagina3, 2),\n              real = _this$_getRealImagina4[0],\n              imag = _this$_getRealImagina4[1];\n\n          var periodicWave = this.context.createPeriodicWave(real, imag);\n          this._wave = periodicWave;\n\n          if (this._oscillator !== null) {\n            this._oscillator.setPeriodicWave(this._wave);\n          } // set the cache\n\n\n          Oscillator._periodicWaveCache.push({\n            imag: imag,\n            partialCount: this._partialCount,\n            partials: this._partials,\n            phase: this._phase,\n            real: real,\n            type: this._type,\n            wave: this._wave\n          });\n\n          if (Oscillator._periodicWaveCache.length > 100) {\n            Oscillator._periodicWaveCache.shift();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"baseType\",\n    get: function get() {\n      return this._type.replace(this.partialCount.toString(), \"\");\n    },\n    set: function set(baseType) {\n      if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n        this.type = baseType + this.partialCount;\n      } else {\n        this.type = baseType;\n      }\n    }\n  }, {\n    key: \"partialCount\",\n    get: function get() {\n      return this._partialCount;\n    },\n    set: function set(p) {\n      assertRange(p, 0);\n      var type = this._type;\n      var partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\n      if (partial) {\n        type = partial[1];\n      }\n\n      if (this._type !== \"custom\") {\n        if (p === 0) {\n          this.type = type;\n        } else {\n          this.type = type + p.toString();\n        }\n      } else {\n        // extend or shorten the partials array\n        var fullPartials = new Float32Array(p); // copy over the partials array\n\n        this._partials.forEach(function (v, i) {\n          return fullPartials[i] = v;\n        });\n\n        this._partials = Array.from(fullPartials);\n        this.type = this._type;\n      }\n    }\n  }, {\n    key: \"partials\",\n    get: function get() {\n      return this._partials.slice(0, this.partialCount);\n    },\n    set: function set(partials) {\n      this._partials = partials;\n      this._partialCount = this._partials.length;\n\n      if (partials.length) {\n        this.type = \"custom\";\n      }\n    }\n  }, {\n    key: \"phase\",\n    get: function get() {\n      return this._phase * (180 / Math.PI);\n    },\n    set: function set(phase) {\n      this._phase = phase * Math.PI / 180; // reset the type\n\n      this.type = this._type;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Source.getDefaults(), {\n        detune: 0,\n        frequency: 440,\n        partialCount: 0,\n        partials: [],\n        phase: 0,\n        type: \"sine\"\n      });\n    }\n  }]);\n\n  return Oscillator;\n}(Source);\n/**\n * Cache the periodic waves to avoid having to redo computations\n */\n\nOscillator._periodicWaveCache = [];","map":{"version":3,"sources":["../../../../Tone/source/oscillator/Oscillator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n        this.name = \"Oscillator\";\n        /**\n         * the main oscillator\n         */\n        this._oscillator = null;\n        const options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n        this.frequency = new Signal({\n            context: this.context,\n            units: \"frequency\",\n            value: options.frequency,\n        });\n        readOnly(this, \"frequency\");\n        this.detune = new Signal({\n            context: this.context,\n            units: \"cents\",\n            value: options.detune,\n        });\n        readOnly(this, \"detune\");\n        this._partials = options.partials;\n        this._partialCount = options.partialCount;\n        this._type = options.type;\n        if (options.partialCount && options.type !== \"custom\") {\n            this._type = this.baseType + options.partialCount.toString();\n        }\n        this.phase = options.phase;\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            partialCount: 0,\n            partials: [],\n            phase: 0,\n            type: \"sine\",\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        const computedTime = this.toSeconds(time);\n        // new oscillator with previous values\n        const oscillator = new ToneOscillatorNode({\n            context: this.context,\n            onended: () => this.onstop(this),\n        });\n        this._oscillator = oscillator;\n        if (this._wave) {\n            this._oscillator.setPeriodicWave(this._wave);\n        }\n        else {\n            this._oscillator.type = this._type;\n        }\n        // connect the control signal to the oscillator frequency & detune\n        this._oscillator.connect(this.output);\n        this.frequency.connect(this._oscillator.frequency);\n        this.detune.connect(this._oscillator.detune);\n        // start the oscillator\n        this._oscillator.start(computedTime);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._oscillator) {\n            this._oscillator.stop(computedTime);\n        }\n    }\n    /**\n     * Restart the oscillator. Does not stop the oscillator, but instead\n     * just cancels any scheduled 'stop' from being invoked.\n     */\n    _restart(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"restart\", computedTime);\n        if (this._oscillator) {\n            this._oscillator.cancelStop();\n        }\n        this._state.cancel(computedTime);\n        return this;\n    }\n    /**\n     * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n     * will also affect the oscillators frequency.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * osc.frequency.value = 440;\n     * // the ratio between the bpm and the frequency will be maintained\n     * osc.syncFrequency();\n     * // double the tempo\n     * Tone.Transport.bpm.value *= 2;\n     * // the frequency of the oscillator is doubled to 880\n     */\n    syncFrequency() {\n        this.context.transport.syncSignal(this.frequency);\n        return this;\n    }\n    /**\n     * Unsync the oscillator's frequency from the Transport.\n     * See Oscillator.syncFrequency\n     */\n    unsyncFrequency() {\n        this.context.transport.unsyncSignal(this.frequency);\n        return this;\n    }\n    /**\n     * Get a cached periodic wave. Avoids having to recompute\n     * the oscillator values when they have already been computed\n     * with the same values.\n     */\n    _getCachedPeriodicWave() {\n        if (this._type === \"custom\") {\n            const oscProps = Oscillator._periodicWaveCache.find(description => {\n                return description.phase === this._phase &&\n                    deepEquals(description.partials, this._partials);\n            });\n            return oscProps;\n        }\n        else {\n            const oscProps = Oscillator._periodicWaveCache.find(description => {\n                return description.type === this._type &&\n                    description.phase === this._phase;\n            });\n            this._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n            return oscProps;\n        }\n    }\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        this._type = type;\n        const isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n        if (this._phase === 0 && isBasicType) {\n            this._wave = undefined;\n            this._partialCount = 0;\n            // just go with the basic approach\n            if (this._oscillator !== null) {\n                // already tested that it's a basic type\n                this._oscillator.type = type;\n            }\n        }\n        else {\n            // first check if the value is cached\n            const cache = this._getCachedPeriodicWave();\n            if (isDefined(cache)) {\n                const { partials, wave } = cache;\n                this._wave = wave;\n                this._partials = partials;\n                if (this._oscillator !== null) {\n                    this._oscillator.setPeriodicWave(this._wave);\n                }\n            }\n            else {\n                const [real, imag] = this._getRealImaginary(type, this._phase);\n                const periodicWave = this.context.createPeriodicWave(real, imag);\n                this._wave = periodicWave;\n                if (this._oscillator !== null) {\n                    this._oscillator.setPeriodicWave(this._wave);\n                }\n                // set the cache\n                Oscillator._periodicWaveCache.push({\n                    imag,\n                    partialCount: this._partialCount,\n                    partials: this._partials,\n                    phase: this._phase,\n                    real,\n                    type: this._type,\n                    wave: this._wave,\n                });\n                if (Oscillator._periodicWaveCache.length > 100) {\n                    Oscillator._periodicWaveCache.shift();\n                }\n            }\n        }\n    }\n    get baseType() {\n        return this._type.replace(this.partialCount.toString(), \"\");\n    }\n    set baseType(baseType) {\n        if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n            this.type = baseType + this.partialCount;\n        }\n        else {\n            this.type = baseType;\n        }\n    }\n    get partialCount() {\n        return this._partialCount;\n    }\n    set partialCount(p) {\n        assertRange(p, 0);\n        let type = this._type;\n        const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n        if (partial) {\n            type = partial[1];\n        }\n        if (this._type !== \"custom\") {\n            if (p === 0) {\n                this.type = type;\n            }\n            else {\n                this.type = type + p.toString();\n            }\n        }\n        else {\n            // extend or shorten the partials array\n            const fullPartials = new Float32Array(p);\n            // copy over the partials array\n            this._partials.forEach((v, i) => fullPartials[i] = v);\n            this._partials = Array.from(fullPartials);\n            this.type = this._type;\n        }\n    }\n    /**\n     * Returns the real and imaginary components based\n     * on the oscillator type.\n     * @returns [real: Float32Array, imaginary: Float32Array]\n     */\n    _getRealImaginary(type, phase) {\n        const fftSize = 4096;\n        let periodicWaveSize = fftSize / 2;\n        const real = new Float32Array(periodicWaveSize);\n        const imag = new Float32Array(periodicWaveSize);\n        let partialCount = 1;\n        if (type === \"custom\") {\n            partialCount = this._partials.length + 1;\n            this._partialCount = this._partials.length;\n            periodicWaveSize = partialCount;\n            // if the partial count is 0, don't bother doing any computation\n            if (this._partials.length === 0) {\n                return [real, imag];\n            }\n        }\n        else {\n            const partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n            if (partial) {\n                partialCount = parseInt(partial[2], 10) + 1;\n                this._partialCount = parseInt(partial[2], 10);\n                type = partial[1];\n                partialCount = Math.max(partialCount, 2);\n                periodicWaveSize = partialCount;\n            }\n            else {\n                this._partialCount = 0;\n            }\n            this._partials = [];\n        }\n        for (let n = 1; n < periodicWaveSize; ++n) {\n            const piFactor = 2 / (n * Math.PI);\n            let b;\n            switch (type) {\n                case \"sine\":\n                    b = (n <= partialCount) ? 1 : 0;\n                    this._partials[n - 1] = b;\n                    break;\n                case \"square\":\n                    b = (n & 1) ? 2 * piFactor : 0;\n                    this._partials[n - 1] = b;\n                    break;\n                case \"sawtooth\":\n                    b = piFactor * ((n & 1) ? 1 : -1);\n                    this._partials[n - 1] = b;\n                    break;\n                case \"triangle\":\n                    if (n & 1) {\n                        b = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n                    }\n                    else {\n                        b = 0;\n                    }\n                    this._partials[n - 1] = b;\n                    break;\n                case \"custom\":\n                    b = this._partials[n - 1];\n                    break;\n                default:\n                    throw new TypeError(\"Oscillator: invalid type: \" + type);\n            }\n            if (b !== 0) {\n                real[n] = -b * Math.sin(phase * n);\n                imag[n] = b * Math.cos(phase * n);\n            }\n            else {\n                real[n] = 0;\n                imag[n] = 0;\n            }\n        }\n        return [real, imag];\n    }\n    /**\n     * Compute the inverse FFT for a given phase.\n     */\n    _inverseFFT(real, imag, phase) {\n        let sum = 0;\n        const len = real.length;\n        for (let i = 0; i < len; i++) {\n            sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n        }\n        return sum;\n    }\n    /**\n     * Returns the initial value of the oscillator when stopped.\n     * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n     */\n    getInitialValue() {\n        const [real, imag] = this._getRealImaginary(this._type, 0);\n        let maxValue = 0;\n        const twoPi = Math.PI * 2;\n        const testPositions = 32;\n        // check for peaks in 16 places\n        for (let i = 0; i < testPositions; i++) {\n            maxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n        }\n        return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n    }\n    get partials() {\n        return this._partials.slice(0, this.partialCount);\n    }\n    set partials(partials) {\n        this._partials = partials;\n        this._partialCount = this._partials.length;\n        if (partials.length) {\n            this.type = \"custom\";\n        }\n    }\n    get phase() {\n        return this._phase * (180 / Math.PI);\n    }\n    set phase(phase) {\n        this._phase = phase * Math.PI / 180;\n        // reset the type\n        this.type = this._type;\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    dispose() {\n        super.dispose();\n        if (this._oscillator !== null) {\n            this._oscillator.dispose();\n        }\n        this._wave = undefined;\n        this.frequency.dispose();\n        this.detune.dispose();\n        return this;\n    }\n}\n/**\n * Cache the periodic waves to avoid having to redo computations\n */\nOscillator._periodicWaveCache = [];\n//# sourceMappingURL=Oscillator.js.map"]},"metadata":{},"sourceType":"module"}