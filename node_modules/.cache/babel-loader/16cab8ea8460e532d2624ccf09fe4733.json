{"ast":null,"code":"import _regeneratorRuntime from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { __awaiter } from \"tslib\";\nimport { Ticker } from \"../clock/Ticker\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { createAudioContext, createAudioWorkletNode as _createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\n\nexport var Context = /*#__PURE__*/function (_BaseContext) {\n  _inherits(Context, _BaseContext);\n\n  var _super = _createSuper(Context);\n\n  function Context() {\n    var _this;\n\n    _classCallCheck(this, Context);\n\n    _this = _super.call(this);\n    _this.name = \"Context\";\n    /**\n     * An object containing all of the constants AudioBufferSourceNodes\n     */\n\n    _this._constants = new Map();\n    /**\n     * All of the setTimeout events.\n     */\n\n    _this._timeouts = new Timeline();\n    /**\n     * The timeout id counter\n     */\n\n    _this._timeoutIds = 0;\n    /**\n     * Private indicator if the context has been initialized\n     */\n\n    _this._initialized = false;\n    /**\n     * Indicates if the context is an OfflineAudioContext or an AudioContext\n     */\n\n    _this.isOffline = false; //--------------------------------------------\n    // AUDIO WORKLET\n    //--------------------------------------------\n\n    /**\n     * Maps a module name to promise of the addModule method\n     */\n\n    _this._workletModules = new Map();\n    var options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n\n    if (options.context) {\n      _this._context = options.context;\n    } else {\n      _this._context = createAudioContext({\n        latencyHint: options.latencyHint\n      });\n    }\n\n    _this._ticker = new Ticker(_this.emit.bind(_assertThisInitialized(_this), \"tick\"), options.clockSource, options.updateInterval);\n\n    _this.on(\"tick\", _this._timeoutLoop.bind(_assertThisInitialized(_this))); // fwd events from the context\n\n\n    _this._context.onstatechange = function () {\n      _this.emit(\"statechange\", _this.state);\n    };\n\n    _this._setLatencyHint(options.latencyHint);\n\n    _this.lookAhead = options.lookAhead;\n    return _this;\n  }\n\n  _createClass(Context, [{\n    key: \"initialize\",\n\n    /**\n     * Finish setting up the context. **You usually do not need to do this manually.**\n     */\n    value: function initialize() {\n      if (!this._initialized) {\n        // add any additional modules\n        initializeContext(this);\n        this._initialized = true;\n      }\n\n      return this;\n    } //---------------------------\n    // BASE AUDIO CONTEXT METHODS\n    //---------------------------\n\n  }, {\n    key: \"createAnalyser\",\n    value: function createAnalyser() {\n      return this._context.createAnalyser();\n    }\n  }, {\n    key: \"createOscillator\",\n    value: function createOscillator() {\n      return this._context.createOscillator();\n    }\n  }, {\n    key: \"createBufferSource\",\n    value: function createBufferSource() {\n      return this._context.createBufferSource();\n    }\n  }, {\n    key: \"createBiquadFilter\",\n    value: function createBiquadFilter() {\n      return this._context.createBiquadFilter();\n    }\n  }, {\n    key: \"createBuffer\",\n    value: function createBuffer(numberOfChannels, length, sampleRate) {\n      return this._context.createBuffer(numberOfChannels, length, sampleRate);\n    }\n  }, {\n    key: \"createChannelMerger\",\n    value: function createChannelMerger(numberOfInputs) {\n      return this._context.createChannelMerger(numberOfInputs);\n    }\n  }, {\n    key: \"createChannelSplitter\",\n    value: function createChannelSplitter(numberOfOutputs) {\n      return this._context.createChannelSplitter(numberOfOutputs);\n    }\n  }, {\n    key: \"createConstantSource\",\n    value: function createConstantSource() {\n      return this._context.createConstantSource();\n    }\n  }, {\n    key: \"createConvolver\",\n    value: function createConvolver() {\n      return this._context.createConvolver();\n    }\n  }, {\n    key: \"createDelay\",\n    value: function createDelay(maxDelayTime) {\n      return this._context.createDelay(maxDelayTime);\n    }\n  }, {\n    key: \"createDynamicsCompressor\",\n    value: function createDynamicsCompressor() {\n      return this._context.createDynamicsCompressor();\n    }\n  }, {\n    key: \"createGain\",\n    value: function createGain() {\n      return this._context.createGain();\n    }\n  }, {\n    key: \"createIIRFilter\",\n    value: function createIIRFilter(feedForward, feedback) {\n      // @ts-ignore\n      return this._context.createIIRFilter(feedForward, feedback);\n    }\n  }, {\n    key: \"createPanner\",\n    value: function createPanner() {\n      return this._context.createPanner();\n    }\n  }, {\n    key: \"createPeriodicWave\",\n    value: function createPeriodicWave(real, imag, constraints) {\n      return this._context.createPeriodicWave(real, imag, constraints);\n    }\n  }, {\n    key: \"createStereoPanner\",\n    value: function createStereoPanner() {\n      return this._context.createStereoPanner();\n    }\n  }, {\n    key: \"createWaveShaper\",\n    value: function createWaveShaper() {\n      return this._context.createWaveShaper();\n    }\n  }, {\n    key: \"createMediaStreamSource\",\n    value: function createMediaStreamSource(stream) {\n      assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n      var context = this._context;\n      return context.createMediaStreamSource(stream);\n    }\n  }, {\n    key: \"createMediaStreamDestination\",\n    value: function createMediaStreamDestination() {\n      assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n      var context = this._context;\n      return context.createMediaStreamDestination();\n    }\n  }, {\n    key: \"decodeAudioData\",\n    value: function decodeAudioData(audioData) {\n      return this._context.decodeAudioData(audioData);\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n\n  }, {\n    key: \"createAudioWorkletNode\",\n\n    /**\n     * Create an audio worklet node from a name and options. The module\n     * must first be loaded using [[addAudioWorkletModule]].\n     */\n    value: function createAudioWorkletNode(name, options) {\n      return _createAudioWorkletNode(this.rawContext, name, options);\n    }\n    /**\n     * Add an AudioWorkletProcessor module\n     * @param url The url of the module\n     * @param name The name of the module\n     */\n\n  }, {\n    key: \"addAudioWorkletModule\",\n    value: function addAudioWorkletModule(url, name) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n\n                if (!this._workletModules.has(name)) {\n                  this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n                }\n\n                _context.next = 4;\n                return this._workletModules.get(name);\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Returns a promise which resolves when all of the worklets have been loaded on this context\n     */\n\n  }, {\n    key: \"workletsAreReady\",\n    value: function workletsAreReady() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var promises;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                promises = [];\n\n                this._workletModules.forEach(function (promise) {\n                  return promises.push(promise);\n                });\n\n                _context2.next = 4;\n                return Promise.all(promises);\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    } //---------------------------\n    // TICKER\n    //---------------------------\n\n    /**\n     * How often the interval callback is invoked.\n     * This number corresponds to how responsive the scheduling\n     * can be. context.updateInterval + context.lookAhead gives you the\n     * total latency between scheduling an event and hearing it.\n     */\n\n  }, {\n    key: \"_setLatencyHint\",\n\n    /**\n     * Update the lookAhead and updateInterval based on the latencyHint\n     */\n    value: function _setLatencyHint(hint) {\n      var lookAheadValue = 0;\n      this._latencyHint = hint;\n\n      if (isString(hint)) {\n        switch (hint) {\n          case \"interactive\":\n            lookAheadValue = 0.1;\n            break;\n\n          case \"playback\":\n            lookAheadValue = 0.5;\n            break;\n\n          case \"balanced\":\n            lookAheadValue = 0.25;\n            break;\n        }\n      }\n\n      this.lookAhead = lookAheadValue;\n      this.updateInterval = lookAheadValue / 2;\n    }\n    /**\n     * The unwrapped AudioContext or OfflineAudioContext\n     */\n\n  }, {\n    key: \"now\",\n\n    /**\n     * The current audio context time plus a short [[lookAhead]].\n     */\n    value: function now() {\n      return this._context.currentTime + this.lookAhead;\n    }\n    /**\n     * The current audio context time without the [[lookAhead]].\n     * In most cases it is better to use [[now]] instead of [[immediate]] since\n     * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n     * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n     * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n     */\n\n  }, {\n    key: \"immediate\",\n    value: function immediate() {\n      return this._context.currentTime;\n    }\n    /**\n     * Starts the audio context from a suspended state. This is required\n     * to initially start the AudioContext. See [[Tone.start]]\n     */\n\n  }, {\n    key: \"resume\",\n    value: function resume() {\n      if (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n        return this._context.resume();\n      } else {\n        return Promise.resolve();\n      }\n    }\n    /**\n     * Close the context. Once closed, the context can no longer be used and\n     * any AudioNodes created from the context will be silent.\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (!isAudioContext(this._context)) {\n                  _context3.next = 3;\n                  break;\n                }\n\n                _context3.next = 3;\n                return this._context.close();\n\n              case 3:\n                if (this._initialized) {\n                  closeContext(this);\n                }\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n    /**\n     * **Internal** Generate a looped buffer at some constant value.\n     */\n\n  }, {\n    key: \"getConstant\",\n    value: function getConstant(val) {\n      if (this._constants.has(val)) {\n        return this._constants.get(val);\n      } else {\n        var buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n\n        var arr = buffer.getChannelData(0);\n\n        for (var i = 0; i < arr.length; i++) {\n          arr[i] = val;\n        }\n\n        var constant = this._context.createBufferSource();\n\n        constant.channelCount = 1;\n        constant.channelCountMode = \"explicit\";\n        constant.buffer = buffer;\n        constant.loop = true;\n        constant.start(0);\n\n        this._constants.set(val, constant);\n\n        return constant;\n      }\n    }\n    /**\n     * Clean up. Also closes the audio context.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      var _this2 = this;\n\n      _get(_getPrototypeOf(Context.prototype), \"dispose\", this).call(this);\n\n      this._ticker.dispose();\n\n      this._timeouts.dispose();\n\n      Object.keys(this._constants).map(function (val) {\n        return _this2._constants[val].disconnect();\n      });\n      return this;\n    } //---------------------------\n    // TIMEOUTS\n    //---------------------------\n\n    /**\n     * The private loop which keeps track of the context scheduled timeouts\n     * Is invoked from the clock source\n     */\n\n  }, {\n    key: \"_timeoutLoop\",\n    value: function _timeoutLoop() {\n      var now = this.now();\n\n      var firstEvent = this._timeouts.peek();\n\n      while (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n        // invoke the callback\n        firstEvent.callback(); // shift the first event off\n\n        this._timeouts.shift(); // get the next one\n\n\n        firstEvent = this._timeouts.peek();\n      }\n    }\n    /**\n     * A setTimeout which is guaranteed by the clock source.\n     * Also runs in the offline context.\n     * @param  fn       The callback to invoke\n     * @param  timeout  The timeout in seconds\n     * @returns ID to use when invoking Context.clearTimeout\n     */\n\n  }, {\n    key: \"setTimeout\",\n    value: function setTimeout(fn, timeout) {\n      this._timeoutIds++;\n      var now = this.now();\n\n      this._timeouts.add({\n        callback: fn,\n        id: this._timeoutIds,\n        time: now + timeout\n      });\n\n      return this._timeoutIds;\n    }\n    /**\n     * Clears a previously scheduled timeout with Tone.context.setTimeout\n     * @param  id  The ID returned from setTimeout\n     */\n\n  }, {\n    key: \"clearTimeout\",\n    value: function clearTimeout(id) {\n      var _this3 = this;\n\n      this._timeouts.forEach(function (event) {\n        if (event.id === id) {\n          _this3._timeouts.remove(event);\n        }\n      });\n\n      return this;\n    }\n    /**\n     * Clear the function scheduled by [[setInterval]]\n     */\n\n  }, {\n    key: \"clearInterval\",\n    value: function clearInterval(id) {\n      return this.clearTimeout(id);\n    }\n    /**\n     * Adds a repeating event to the context's callback clock\n     */\n\n  }, {\n    key: \"setInterval\",\n    value: function setInterval(fn, interval) {\n      var _this4 = this;\n\n      var id = ++this._timeoutIds;\n\n      var intervalFn = function intervalFn() {\n        var now = _this4.now();\n\n        _this4._timeouts.add({\n          callback: function callback() {\n            // invoke the callback\n            fn(); // invoke the event to repeat it\n\n            intervalFn();\n          },\n          id: id,\n          time: now + interval\n        });\n      }; // kick it off\n\n\n      intervalFn();\n      return id;\n    }\n  }, {\n    key: \"currentTime\",\n    get: function get() {\n      return this._context.currentTime;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._context.state;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n\n  }, {\n    key: \"sampleRate\",\n    get: function get() {\n      return this._context.sampleRate;\n    }\n    /**\n     * The listener\n     */\n\n  }, {\n    key: \"listener\",\n    get: function get() {\n      this.initialize();\n      return this._listener;\n    },\n    set: function set(l) {\n      assert(!this._initialized, \"The listener cannot be set after initialization.\");\n      this._listener = l;\n    }\n    /**\n     * There is only one Transport per Context. It is created on initialization.\n     */\n\n  }, {\n    key: \"transport\",\n    get: function get() {\n      this.initialize();\n      return this._transport;\n    },\n    set: function set(t) {\n      assert(!this._initialized, \"The transport cannot be set after initialization.\");\n      this._transport = t;\n    }\n    /**\n     * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n     */\n\n  }, {\n    key: \"draw\",\n    get: function get() {\n      this.initialize();\n      return this._draw;\n    },\n    set: function set(d) {\n      assert(!this._initialized, \"Draw cannot be set after initialization.\");\n      this._draw = d;\n    }\n    /**\n     * A reference to the Context's destination node.\n     */\n\n  }, {\n    key: \"destination\",\n    get: function get() {\n      this.initialize();\n      return this._destination;\n    },\n    set: function set(d) {\n      assert(!this._initialized, \"The destination cannot be set after initialization.\");\n      this._destination = d;\n    }\n  }, {\n    key: \"updateInterval\",\n    get: function get() {\n      return this._ticker.updateInterval;\n    },\n    set: function set(interval) {\n      this._ticker.updateInterval = interval;\n    }\n    /**\n     * What the source of the clock is, either \"worker\" (default),\n     * \"timeout\", or \"offline\" (none).\n     */\n\n  }, {\n    key: \"clockSource\",\n    get: function get() {\n      return this._ticker.type;\n    },\n    set: function set(type) {\n      this._ticker.type = type;\n    }\n    /**\n     * The type of playback, which affects tradeoffs between audio\n     * output latency and responsiveness.\n     * In addition to setting the value in seconds, the latencyHint also\n     * accepts the strings \"interactive\" (prioritizes low latency),\n     * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n     * latency and performance).\n     * @example\n     * // prioritize sustained playback\n     * const context = new Tone.Context({ latencyHint: \"playback\" });\n     * // set this context as the global Context\n     * Tone.setContext(context);\n     * // the global context is gettable with Tone.getContext()\n     * console.log(Tone.getContext().latencyHint);\n     */\n\n  }, {\n    key: \"latencyHint\",\n    get: function get() {\n      return this._latencyHint;\n    }\n  }, {\n    key: \"rawContext\",\n    get: function get() {\n      return this._context;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return {\n        clockSource: \"worker\",\n        latencyHint: \"interactive\",\n        lookAhead: 0.1,\n        updateInterval: 0.05\n      };\n    }\n  }]);\n\n  return Context;\n}(BaseContext);","map":{"version":3,"sources":["../../../../Tone/core/context/Context.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { Ticker } from \"../clock/Ticker\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport { createAudioContext, createAudioWorkletNode } from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nexport class Context extends BaseContext {\n    constructor() {\n        super();\n        this.name = \"Context\";\n        /**\n         * An object containing all of the constants AudioBufferSourceNodes\n         */\n        this._constants = new Map();\n        /**\n         * All of the setTimeout events.\n         */\n        this._timeouts = new Timeline();\n        /**\n         * The timeout id counter\n         */\n        this._timeoutIds = 0;\n        /**\n         * Private indicator if the context has been initialized\n         */\n        this._initialized = false;\n        /**\n         * Indicates if the context is an OfflineAudioContext or an AudioContext\n         */\n        this.isOffline = false;\n        //--------------------------------------------\n        // AUDIO WORKLET\n        //--------------------------------------------\n        /**\n         * Maps a module name to promise of the addModule method\n         */\n        this._workletModules = new Map();\n        const options = optionsFromArguments(Context.getDefaults(), arguments, [\"context\"]);\n        if (options.context) {\n            this._context = options.context;\n        }\n        else {\n            this._context = createAudioContext({\n                latencyHint: options.latencyHint,\n            });\n        }\n        this._ticker = new Ticker(this.emit.bind(this, \"tick\"), options.clockSource, options.updateInterval);\n        this.on(\"tick\", this._timeoutLoop.bind(this));\n        // fwd events from the context\n        this._context.onstatechange = () => {\n            this.emit(\"statechange\", this.state);\n        };\n        this._setLatencyHint(options.latencyHint);\n        this.lookAhead = options.lookAhead;\n    }\n    static getDefaults() {\n        return {\n            clockSource: \"worker\",\n            latencyHint: \"interactive\",\n            lookAhead: 0.1,\n            updateInterval: 0.05,\n        };\n    }\n    /**\n     * Finish setting up the context. **You usually do not need to do this manually.**\n     */\n    initialize() {\n        if (!this._initialized) {\n            // add any additional modules\n            initializeContext(this);\n            this._initialized = true;\n        }\n        return this;\n    }\n    //---------------------------\n    // BASE AUDIO CONTEXT METHODS\n    //---------------------------\n    createAnalyser() {\n        return this._context.createAnalyser();\n    }\n    createOscillator() {\n        return this._context.createOscillator();\n    }\n    createBufferSource() {\n        return this._context.createBufferSource();\n    }\n    createBiquadFilter() {\n        return this._context.createBiquadFilter();\n    }\n    createBuffer(numberOfChannels, length, sampleRate) {\n        return this._context.createBuffer(numberOfChannels, length, sampleRate);\n    }\n    createChannelMerger(numberOfInputs) {\n        return this._context.createChannelMerger(numberOfInputs);\n    }\n    createChannelSplitter(numberOfOutputs) {\n        return this._context.createChannelSplitter(numberOfOutputs);\n    }\n    createConstantSource() {\n        return this._context.createConstantSource();\n    }\n    createConvolver() {\n        return this._context.createConvolver();\n    }\n    createDelay(maxDelayTime) {\n        return this._context.createDelay(maxDelayTime);\n    }\n    createDynamicsCompressor() {\n        return this._context.createDynamicsCompressor();\n    }\n    createGain() {\n        return this._context.createGain();\n    }\n    createIIRFilter(feedForward, feedback) {\n        // @ts-ignore\n        return this._context.createIIRFilter(feedForward, feedback);\n    }\n    createPanner() {\n        return this._context.createPanner();\n    }\n    createPeriodicWave(real, imag, constraints) {\n        return this._context.createPeriodicWave(real, imag, constraints);\n    }\n    createStereoPanner() {\n        return this._context.createStereoPanner();\n    }\n    createWaveShaper() {\n        return this._context.createWaveShaper();\n    }\n    createMediaStreamSource(stream) {\n        assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n        const context = this._context;\n        return context.createMediaStreamSource(stream);\n    }\n    createMediaStreamDestination() {\n        assert(isAudioContext(this._context), \"Not available if OfflineAudioContext\");\n        const context = this._context;\n        return context.createMediaStreamDestination();\n    }\n    decodeAudioData(audioData) {\n        return this._context.decodeAudioData(audioData);\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get currentTime() {\n        return this._context.currentTime;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get state() {\n        return this._context.state;\n    }\n    /**\n     * The current time in seconds of the AudioContext.\n     */\n    get sampleRate() {\n        return this._context.sampleRate;\n    }\n    /**\n     * The listener\n     */\n    get listener() {\n        this.initialize();\n        return this._listener;\n    }\n    set listener(l) {\n        assert(!this._initialized, \"The listener cannot be set after initialization.\");\n        this._listener = l;\n    }\n    /**\n     * There is only one Transport per Context. It is created on initialization.\n     */\n    get transport() {\n        this.initialize();\n        return this._transport;\n    }\n    set transport(t) {\n        assert(!this._initialized, \"The transport cannot be set after initialization.\");\n        this._transport = t;\n    }\n    /**\n     * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n     */\n    get draw() {\n        this.initialize();\n        return this._draw;\n    }\n    set draw(d) {\n        assert(!this._initialized, \"Draw cannot be set after initialization.\");\n        this._draw = d;\n    }\n    /**\n     * A reference to the Context's destination node.\n     */\n    get destination() {\n        this.initialize();\n        return this._destination;\n    }\n    set destination(d) {\n        assert(!this._initialized, \"The destination cannot be set after initialization.\");\n        this._destination = d;\n    }\n    /**\n     * Create an audio worklet node from a name and options. The module\n     * must first be loaded using [[addAudioWorkletModule]].\n     */\n    createAudioWorkletNode(name, options) {\n        return createAudioWorkletNode(this.rawContext, name, options);\n    }\n    /**\n     * Add an AudioWorkletProcessor module\n     * @param url The url of the module\n     * @param name The name of the module\n     */\n    addAudioWorkletModule(url, name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(isDefined(this.rawContext.audioWorklet), \"AudioWorkletNode is only available in a secure context (https or localhost)\");\n            if (!this._workletModules.has(name)) {\n                this._workletModules.set(name, this.rawContext.audioWorklet.addModule(url));\n            }\n            yield this._workletModules.get(name);\n        });\n    }\n    /**\n     * Returns a promise which resolves when all of the worklets have been loaded on this context\n     */\n    workletsAreReady() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const promises = [];\n            this._workletModules.forEach(promise => promises.push(promise));\n            yield Promise.all(promises);\n        });\n    }\n    //---------------------------\n    // TICKER\n    //---------------------------\n    /**\n     * How often the interval callback is invoked.\n     * This number corresponds to how responsive the scheduling\n     * can be. context.updateInterval + context.lookAhead gives you the\n     * total latency between scheduling an event and hearing it.\n     */\n    get updateInterval() {\n        return this._ticker.updateInterval;\n    }\n    set updateInterval(interval) {\n        this._ticker.updateInterval = interval;\n    }\n    /**\n     * What the source of the clock is, either \"worker\" (default),\n     * \"timeout\", or \"offline\" (none).\n     */\n    get clockSource() {\n        return this._ticker.type;\n    }\n    set clockSource(type) {\n        this._ticker.type = type;\n    }\n    /**\n     * The type of playback, which affects tradeoffs between audio\n     * output latency and responsiveness.\n     * In addition to setting the value in seconds, the latencyHint also\n     * accepts the strings \"interactive\" (prioritizes low latency),\n     * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n     * latency and performance).\n     * @example\n     * // prioritize sustained playback\n     * const context = new Tone.Context({ latencyHint: \"playback\" });\n     * // set this context as the global Context\n     * Tone.setContext(context);\n     * // the global context is gettable with Tone.getContext()\n     * console.log(Tone.getContext().latencyHint);\n     */\n    get latencyHint() {\n        return this._latencyHint;\n    }\n    /**\n     * Update the lookAhead and updateInterval based on the latencyHint\n     */\n    _setLatencyHint(hint) {\n        let lookAheadValue = 0;\n        this._latencyHint = hint;\n        if (isString(hint)) {\n            switch (hint) {\n                case \"interactive\":\n                    lookAheadValue = 0.1;\n                    break;\n                case \"playback\":\n                    lookAheadValue = 0.5;\n                    break;\n                case \"balanced\":\n                    lookAheadValue = 0.25;\n                    break;\n            }\n        }\n        this.lookAhead = lookAheadValue;\n        this.updateInterval = lookAheadValue / 2;\n    }\n    /**\n     * The unwrapped AudioContext or OfflineAudioContext\n     */\n    get rawContext() {\n        return this._context;\n    }\n    /**\n     * The current audio context time plus a short [[lookAhead]].\n     */\n    now() {\n        return this._context.currentTime + this.lookAhead;\n    }\n    /**\n     * The current audio context time without the [[lookAhead]].\n     * In most cases it is better to use [[now]] instead of [[immediate]] since\n     * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n     * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n     * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n     */\n    immediate() {\n        return this._context.currentTime;\n    }\n    /**\n     * Starts the audio context from a suspended state. This is required\n     * to initially start the AudioContext. See [[Tone.start]]\n     */\n    resume() {\n        if (this._context.state === \"suspended\" && isAudioContext(this._context)) {\n            return this._context.resume();\n        }\n        else {\n            return Promise.resolve();\n        }\n    }\n    /**\n     * Close the context. Once closed, the context can no longer be used and\n     * any AudioNodes created from the context will be silent.\n     */\n    close() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (isAudioContext(this._context)) {\n                yield this._context.close();\n            }\n            if (this._initialized) {\n                closeContext(this);\n            }\n        });\n    }\n    /**\n     * **Internal** Generate a looped buffer at some constant value.\n     */\n    getConstant(val) {\n        if (this._constants.has(val)) {\n            return this._constants.get(val);\n        }\n        else {\n            const buffer = this._context.createBuffer(1, 128, this._context.sampleRate);\n            const arr = buffer.getChannelData(0);\n            for (let i = 0; i < arr.length; i++) {\n                arr[i] = val;\n            }\n            const constant = this._context.createBufferSource();\n            constant.channelCount = 1;\n            constant.channelCountMode = \"explicit\";\n            constant.buffer = buffer;\n            constant.loop = true;\n            constant.start(0);\n            this._constants.set(val, constant);\n            return constant;\n        }\n    }\n    /**\n     * Clean up. Also closes the audio context.\n     */\n    dispose() {\n        super.dispose();\n        this._ticker.dispose();\n        this._timeouts.dispose();\n        Object.keys(this._constants).map(val => this._constants[val].disconnect());\n        return this;\n    }\n    //---------------------------\n    // TIMEOUTS\n    //---------------------------\n    /**\n     * The private loop which keeps track of the context scheduled timeouts\n     * Is invoked from the clock source\n     */\n    _timeoutLoop() {\n        const now = this.now();\n        let firstEvent = this._timeouts.peek();\n        while (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n            // invoke the callback\n            firstEvent.callback();\n            // shift the first event off\n            this._timeouts.shift();\n            // get the next one\n            firstEvent = this._timeouts.peek();\n        }\n    }\n    /**\n     * A setTimeout which is guaranteed by the clock source.\n     * Also runs in the offline context.\n     * @param  fn       The callback to invoke\n     * @param  timeout  The timeout in seconds\n     * @returns ID to use when invoking Context.clearTimeout\n     */\n    setTimeout(fn, timeout) {\n        this._timeoutIds++;\n        const now = this.now();\n        this._timeouts.add({\n            callback: fn,\n            id: this._timeoutIds,\n            time: now + timeout,\n        });\n        return this._timeoutIds;\n    }\n    /**\n     * Clears a previously scheduled timeout with Tone.context.setTimeout\n     * @param  id  The ID returned from setTimeout\n     */\n    clearTimeout(id) {\n        this._timeouts.forEach(event => {\n            if (event.id === id) {\n                this._timeouts.remove(event);\n            }\n        });\n        return this;\n    }\n    /**\n     * Clear the function scheduled by [[setInterval]]\n     */\n    clearInterval(id) {\n        return this.clearTimeout(id);\n    }\n    /**\n     * Adds a repeating event to the context's callback clock\n     */\n    setInterval(fn, interval) {\n        const id = ++this._timeoutIds;\n        const intervalFn = () => {\n            const now = this.now();\n            this._timeouts.add({\n                callback: () => {\n                    // invoke the callback\n                    fn();\n                    // invoke the event to repeat it\n                    intervalFn();\n                },\n                id,\n                time: now + interval,\n            });\n        };\n        // kick it off\n        intervalFn();\n        return id;\n    }\n}\n//# sourceMappingURL=Context.js.map"]},"metadata":{},"sourceType":"module"}