{"ast":null,"code":"var Point = require('../Point'),\n    CONST = require('../../const');\n/**\n * @class\n * @memberof PIXI\n * @param points {Point[]|number[]|...Point|...number} This can be an array of Points that form the polygon,\n *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be\n *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the\n *      arguments passed can be flat x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are\n *      Numbers.\n */\n\n\nfunction Polygon(points_) {\n  // prevents an argument assignment deopt\n  // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n  var points = points_; //if points isn't an array, use arguments as the array\n\n  if (!Array.isArray(points)) {\n    // prevents an argument leak deopt\n    // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    points = new Array(arguments.length);\n\n    for (var a = 0; a < points.length; ++a) {\n      points[a] = arguments[a];\n    }\n  } // if this is an array of points, convert it to a flat array of numbers\n\n\n  if (points[0] instanceof Point) {\n    var p = [];\n\n    for (var i = 0, il = points.length; i < il; i++) {\n      p.push(points[i].x, points[i].y);\n    }\n\n    points = p;\n  }\n\n  this.closed = true;\n  /**\n   * An array of the points of this polygon\n   *\n   * @member {number[]}\n   */\n\n  this.points = points;\n  /**\n   * The type of the object, mainly used to avoid `instanceof` checks\n   *\n   * @member {number}\n   */\n\n  this.type = CONST.SHAPES.POLY;\n}\n\nPolygon.prototype.constructor = Polygon;\nmodule.exports = Polygon;\n/**\n * Creates a clone of this polygon\n *\n * @return {Polygon} a copy of the polygon\n */\n\nPolygon.prototype.clone = function () {\n  return new Polygon(this.points.slice());\n};\n/**\n * Checks whether the x and y coordinates passed to this function are contained within this polygon\n *\n * @param x {number} The X coordinate of the point to test\n * @param y {number} The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this polygon\n */\n\n\nPolygon.prototype.contains = function (x, y) {\n  var inside = false; // use some raycasting to test hits\n  // https://github.com/substack/point-in-polygon/blob/master/index.js\n\n  var length = this.points.length / 2;\n\n  for (var i = 0, j = length - 1; i < length; j = i++) {\n    var xi = this.points[i * 2],\n        yi = this.points[i * 2 + 1],\n        xj = this.points[j * 2],\n        yj = this.points[j * 2 + 1],\n        intersect = yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi;\n\n    if (intersect) {\n      inside = !inside;\n    }\n  }\n\n  return inside;\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/math/shapes/Polygon.js"],"names":["Point","require","CONST","Polygon","points_","points","Array","isArray","arguments","length","a","p","i","il","push","x","y","closed","type","SHAPES","POLY","prototype","constructor","module","exports","clone","slice","contains","inside","j","xi","yi","xj","yj","intersect"],"mappings":"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","sourcesContent":["var Point = require('../Point'),\n    CONST = require('../../const');\n\n/**\n * @class\n * @memberof PIXI\n * @param points {Point[]|number[]|...Point|...number} This can be an array of Points that form the polygon,\n *      a flat array of numbers that will be interpreted as [x,y, x,y, ...], or the arguments passed can be\n *      all the points of the polygon e.g. `new PIXI.Polygon(new PIXI.Point(), new PIXI.Point(), ...)`, or the\n *      arguments passed can be flat x,y values e.g. `new Polygon(x,y, x,y, x,y, ...)` where `x` and `y` are\n *      Numbers.\n */\nfunction Polygon(points_)\n{\n    // prevents an argument assignment deopt\n    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    var points = points_;\n\n    //if points isn't an array, use arguments as the array\n    if (!Array.isArray(points))\n    {\n        // prevents an argument leak deopt\n        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        points = new Array(arguments.length);\n\n        for (var a = 0; a < points.length; ++a) {\n            points[a] = arguments[a];\n        }\n    }\n\n    // if this is an array of points, convert it to a flat array of numbers\n    if (points[0] instanceof Point)\n    {\n        var p = [];\n        for (var i = 0, il = points.length; i < il; i++)\n        {\n            p.push(points[i].x, points[i].y);\n        }\n\n        points = p;\n    }\n\n    this.closed = true;\n\n    /**\n     * An array of the points of this polygon\n     *\n     * @member {number[]}\n     */\n    this.points = points;\n\n    /**\n     * The type of the object, mainly used to avoid `instanceof` checks\n     *\n     * @member {number}\n     */\n    this.type = CONST.SHAPES.POLY;\n}\n\nPolygon.prototype.constructor = Polygon;\nmodule.exports = Polygon;\n\n/**\n * Creates a clone of this polygon\n *\n * @return {Polygon} a copy of the polygon\n */\nPolygon.prototype.clone = function ()\n{\n    return new Polygon(this.points.slice());\n};\n\n/**\n * Checks whether the x and y coordinates passed to this function are contained within this polygon\n *\n * @param x {number} The X coordinate of the point to test\n * @param y {number} The Y coordinate of the point to test\n * @return {boolean} Whether the x/y coordinates are within this polygon\n */\nPolygon.prototype.contains = function (x, y)\n{\n    var inside = false;\n\n    // use some raycasting to test hits\n    // https://github.com/substack/point-in-polygon/blob/master/index.js\n    var length = this.points.length / 2;\n\n    for (var i = 0, j = length - 1; i < length; j = i++)\n    {\n        var xi = this.points[i * 2], yi = this.points[i * 2 + 1],\n            xj = this.points[j * 2], yj = this.points[j * 2 + 1],\n            intersect = ((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n\n        if (intersect)\n        {\n            inside = !inside;\n        }\n    }\n\n    return inside;\n};\n"]},"metadata":{},"sourceType":"script"}