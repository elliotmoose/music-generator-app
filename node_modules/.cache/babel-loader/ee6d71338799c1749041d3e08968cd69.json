{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\n\nexport var Param = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(Param, _ToneWithContext);\n\n  var _super = _createSuper(Param);\n\n  function Param() {\n    var _this;\n\n    _classCallCheck(this, Param);\n\n    _this = _super.call(this, optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n    _this.name = \"Param\";\n    _this.overridden = false;\n    /**\n     * The minimum output value\n     */\n\n    _this._minOutput = 1e-7;\n    var options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n    assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n    while (!isAudioParam(options.param)) {\n      options.param = options.param._param;\n    }\n\n    _this._swappable = isDefined(options.swappable) ? options.swappable : false;\n\n    if (_this._swappable) {\n      _this.input = _this.context.createGain(); // initialize\n\n      _this._param = options.param;\n\n      _this.input.connect(_this._param);\n    } else {\n      _this._param = _this.input = options.param;\n    }\n\n    _this._events = new Timeline(1000);\n    _this._initialValue = _this._param.defaultValue;\n    _this.units = options.units;\n    _this.convert = options.convert;\n    _this._minValue = options.minValue;\n    _this._maxValue = options.maxValue; // if the value is defined, set it immediately\n\n    if (isDefined(options.value) && options.value !== _this._toType(_this._initialValue)) {\n      _this.setValueAtTime(options.value, 0);\n    }\n\n    return _this;\n  }\n\n  _createClass(Param, [{\n    key: \"_is\",\n\n    /**\n     * Type guard based on the unit name\n     */\n    value: function _is(arg, type) {\n      return this.units === type;\n    }\n    /**\n     * Make sure the value is always in the defined range\n     */\n\n  }, {\n    key: \"_assertRange\",\n    value: function _assertRange(value) {\n      if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n        assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n      }\n\n      return value;\n    }\n    /**\n     * Convert the given value from the type specified by Param.units\n     * into the destination value (such as Gain or Frequency).\n     */\n\n  }, {\n    key: \"_fromType\",\n    value: function _fromType(val) {\n      if (this.convert && !this.overridden) {\n        if (this._is(val, \"time\")) {\n          return this.toSeconds(val);\n        } else if (this._is(val, \"decibels\")) {\n          return dbToGain(val);\n        } else if (this._is(val, \"frequency\")) {\n          return this.toFrequency(val);\n        } else {\n          return val;\n        }\n      } else if (this.overridden) {\n        // if it's overridden, should only schedule 0s\n        return 0;\n      } else {\n        return val;\n      }\n    }\n    /**\n     * Convert the parameters value into the units specified by Param.units.\n     */\n\n  }, {\n    key: \"_toType\",\n    value: function _toType(val) {\n      if (this.convert && this.units === \"decibels\") {\n        return gainToDb(val);\n      } else {\n        return val;\n      }\n    } //-------------------------------------\n    // ABSTRACT PARAM INTERFACE\n    // all docs are generated from ParamInterface.ts\n    //-------------------------------------\n\n  }, {\n    key: \"setValueAtTime\",\n    value: function setValueAtTime(value, time) {\n      var computedTime = this.toSeconds(time);\n\n      var numericValue = this._fromType(value);\n\n      assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to setValueAtTime: \".concat(JSON.stringify(value), \", \").concat(JSON.stringify(time)));\n\n      this._assertRange(numericValue);\n\n      this.log(this.units, \"setValueAtTime\", value, computedTime);\n\n      this._events.add({\n        time: computedTime,\n        type: \"setValueAtTime\",\n        value: numericValue\n      });\n\n      this._param.setValueAtTime(numericValue, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"getValueAtTime\",\n    value: function getValueAtTime(time) {\n      var computedTime = Math.max(this.toSeconds(time), 0);\n\n      var after = this._events.getAfter(computedTime);\n\n      var before = this._events.get(computedTime);\n\n      var value = this._initialValue; // if it was set by\n\n      if (before === null) {\n        value = this._initialValue;\n      } else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n        var previous = this._events.getBefore(before.time);\n\n        var previousVal;\n\n        if (previous === null) {\n          previousVal = this._initialValue;\n        } else {\n          previousVal = previous.value;\n        }\n\n        if (before.type === \"setTargetAtTime\") {\n          value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n        }\n      } else if (after === null) {\n        value = before.value;\n      } else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n        var beforeValue = before.value;\n\n        if (before.type === \"setTargetAtTime\") {\n          var _previous = this._events.getBefore(before.time);\n\n          if (_previous === null) {\n            beforeValue = this._initialValue;\n          } else {\n            beforeValue = _previous.value;\n          }\n        }\n\n        if (after.type === \"linearRampToValueAtTime\") {\n          value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n        } else {\n          value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n        }\n      } else {\n        value = before.value;\n      }\n\n      return this._toType(value);\n    }\n  }, {\n    key: \"setRampPoint\",\n    value: function setRampPoint(time) {\n      time = this.toSeconds(time);\n      var currentVal = this.getValueAtTime(time);\n      this.cancelAndHoldAtTime(time);\n\n      if (this._fromType(currentVal) === 0) {\n        currentVal = this._toType(this._minOutput);\n      }\n\n      this.setValueAtTime(currentVal, time);\n      return this;\n    }\n  }, {\n    key: \"linearRampToValueAtTime\",\n    value: function linearRampToValueAtTime(value, endTime) {\n      var numericValue = this._fromType(value);\n\n      var computedTime = this.toSeconds(endTime);\n      assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to linearRampToValueAtTime: \".concat(JSON.stringify(value), \", \").concat(JSON.stringify(endTime)));\n\n      this._assertRange(numericValue);\n\n      this._events.add({\n        time: computedTime,\n        type: \"linearRampToValueAtTime\",\n        value: numericValue\n      });\n\n      this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\n      this._param.linearRampToValueAtTime(numericValue, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"exponentialRampToValueAtTime\",\n    value: function exponentialRampToValueAtTime(value, endTime) {\n      var numericValue = this._fromType(value);\n\n      numericValue = Math.max(this._minOutput, numericValue);\n\n      this._assertRange(numericValue);\n\n      var computedTime = this.toSeconds(endTime);\n      assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to exponentialRampToValueAtTime: \".concat(JSON.stringify(value), \", \").concat(JSON.stringify(endTime))); // store the event\n\n      this._events.add({\n        time: computedTime,\n        type: \"exponentialRampToValueAtTime\",\n        value: numericValue\n      });\n\n      this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\n      this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"exponentialRampTo\",\n    value: function exponentialRampTo(value, rampTime, startTime) {\n      startTime = this.toSeconds(startTime);\n      this.setRampPoint(startTime);\n      this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n      return this;\n    }\n  }, {\n    key: \"linearRampTo\",\n    value: function linearRampTo(value, rampTime, startTime) {\n      startTime = this.toSeconds(startTime);\n      this.setRampPoint(startTime);\n      this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n      return this;\n    }\n  }, {\n    key: \"targetRampTo\",\n    value: function targetRampTo(value, rampTime, startTime) {\n      startTime = this.toSeconds(startTime);\n      this.setRampPoint(startTime);\n      this.exponentialApproachValueAtTime(value, startTime, rampTime);\n      return this;\n    }\n  }, {\n    key: \"exponentialApproachValueAtTime\",\n    value: function exponentialApproachValueAtTime(value, time, rampTime) {\n      time = this.toSeconds(time);\n      rampTime = this.toSeconds(rampTime);\n      var timeConstant = Math.log(rampTime + 1) / Math.log(200);\n      this.setTargetAtTime(value, time, timeConstant); // at 90% start a linear ramp to the final value\n\n      this.cancelAndHoldAtTime(time + rampTime * 0.9);\n      this.linearRampToValueAtTime(value, time + rampTime);\n      return this;\n    }\n  }, {\n    key: \"setTargetAtTime\",\n    value: function setTargetAtTime(value, startTime, timeConstant) {\n      var numericValue = this._fromType(value); // The value will never be able to approach without timeConstant > 0.\n\n\n      assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n      var computedTime = this.toSeconds(startTime);\n\n      this._assertRange(numericValue);\n\n      assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to setTargetAtTime: \".concat(JSON.stringify(value), \", \").concat(JSON.stringify(startTime)));\n\n      this._events.add({\n        constant: timeConstant,\n        time: computedTime,\n        type: \"setTargetAtTime\",\n        value: numericValue\n      });\n\n      this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\n      this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\n      return this;\n    }\n  }, {\n    key: \"setValueCurveAtTime\",\n    value: function setValueCurveAtTime(values, startTime, duration) {\n      var scaling = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      duration = this.toSeconds(duration);\n      startTime = this.toSeconds(startTime);\n      var startingValue = this._fromType(values[0]) * scaling;\n      this.setValueAtTime(this._toType(startingValue), startTime);\n      var segTime = duration / (values.length - 1);\n\n      for (var i = 1; i < values.length; i++) {\n        var numericValue = this._fromType(values[i]) * scaling;\n        this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"cancelScheduledValues\",\n    value: function cancelScheduledValues(time) {\n      var computedTime = this.toSeconds(time);\n      assert(isFinite(computedTime), \"Invalid argument to cancelScheduledValues: \".concat(JSON.stringify(time)));\n\n      this._events.cancel(computedTime);\n\n      this._param.cancelScheduledValues(computedTime);\n\n      this.log(this.units, \"cancelScheduledValues\", computedTime);\n      return this;\n    }\n  }, {\n    key: \"cancelAndHoldAtTime\",\n    value: function cancelAndHoldAtTime(time) {\n      var computedTime = this.toSeconds(time);\n\n      var valueAtTime = this._fromType(this.getValueAtTime(computedTime)); // remove the schedule events\n\n\n      assert(isFinite(computedTime), \"Invalid argument to cancelAndHoldAtTime: \".concat(JSON.stringify(time)));\n      this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime); // if there is an event at the given computedTime\n      // and that even is not a \"set\"\n\n      var before = this._events.get(computedTime);\n\n      var after = this._events.getAfter(computedTime);\n\n      if (before && EQ(before.time, computedTime)) {\n        // remove everything after\n        if (after) {\n          this._param.cancelScheduledValues(after.time);\n\n          this._events.cancel(after.time);\n        } else {\n          this._param.cancelAndHoldAtTime(computedTime);\n\n          this._events.cancel(computedTime + this.sampleTime);\n        }\n      } else if (after) {\n        this._param.cancelScheduledValues(after.time); // cancel the next event(s)\n\n\n        this._events.cancel(after.time);\n\n        if (after.type === \"linearRampToValueAtTime\") {\n          this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n        } else if (after.type === \"exponentialRampToValueAtTime\") {\n          this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n        }\n      } // set the value at the given time\n\n\n      this._events.add({\n        time: computedTime,\n        type: \"setValueAtTime\",\n        value: valueAtTime\n      });\n\n      this._param.setValueAtTime(valueAtTime, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"rampTo\",\n    value: function rampTo(value) {\n      var rampTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n      var startTime = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n        this.exponentialRampTo(value, rampTime, startTime);\n      } else {\n        this.linearRampTo(value, rampTime, startTime);\n      }\n\n      return this;\n    }\n    /**\n     * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n     * The applied values will start at the context's current time and schedule\n     * all of the events which are scheduled on this Param onto the passed in param.\n     */\n\n  }, {\n    key: \"apply\",\n    value: function apply(param) {\n      var now = this.context.currentTime; // set the param's value at the current time and schedule everything else\n\n      param.setValueAtTime(this.getValueAtTime(now), now); // if the previous event was a curve, then set the rest of it\n\n      var previousEvent = this._events.get(now);\n\n      if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n        // approx it until the next event with linear ramps\n        var nextEvent = this._events.getAfter(previousEvent.time); // or for 2 seconds if there is no event\n\n\n        var endTime = nextEvent ? nextEvent.time : now + 2;\n        var subdivisions = (endTime - now) / 10;\n\n        for (var i = now; i < endTime; i += subdivisions) {\n          param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n        }\n      }\n\n      this._events.forEachAfter(this.context.currentTime, function (event) {\n        if (event.type === \"cancelScheduledValues\") {\n          param.cancelScheduledValues(event.time);\n        } else if (event.type === \"setTargetAtTime\") {\n          param.setTargetAtTime(event.value, event.time, event.constant);\n        } else {\n          param[event.type](event.value, event.time);\n        }\n      });\n\n      return this;\n    }\n    /**\n     * Replace the Param's internal AudioParam. Will apply scheduled curves\n     * onto the parameter and replace the connections.\n     */\n\n  }, {\n    key: \"setParam\",\n    value: function setParam(param) {\n      assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n      var input = this.input;\n      input.disconnect(this._param);\n      this.apply(param);\n      this._param = param;\n      input.connect(this._param);\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Param.prototype), \"dispose\", this).call(this);\n\n      this._events.dispose();\n\n      return this;\n    }\n  }, {\n    key: \"_exponentialApproach\",\n    //-------------------------------------\n    // \tAUTOMATION CURVE CALCULATIONS\n    // \tMIT License, copyright (c) 2014 Jordan Santell\n    //-------------------------------------\n    // Calculates the the value along the curve produced by setTargetAtTime\n    value: function _exponentialApproach(t0, v0, v1, timeConstant, t) {\n      return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n    } // Calculates the the value along the curve produced by linearRampToValueAtTime\n\n  }, {\n    key: \"_linearInterpolate\",\n    value: function _linearInterpolate(t0, v0, t1, v1, t) {\n      return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n    } // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\n  }, {\n    key: \"_exponentialInterpolate\",\n    value: function _exponentialInterpolate(t0, v0, t1, v1, t) {\n      return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n    }\n  }, {\n    key: \"value\",\n    get: function get() {\n      var now = this.now();\n      return this.getValueAtTime(now);\n    },\n    set: function set(value) {\n      this.cancelScheduledValues(this.now());\n      this.setValueAtTime(value, this.now());\n    }\n  }, {\n    key: \"minValue\",\n    get: function get() {\n      // if it's not the default minValue, return it\n      if (isDefined(this._minValue)) {\n        return this._minValue;\n      } else if (this.units === \"time\" || this.units === \"frequency\" || this.units === \"normalRange\" || this.units === \"positive\" || this.units === \"transportTime\" || this.units === \"ticks\" || this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n        return 0;\n      } else if (this.units === \"audioRange\") {\n        return -1;\n      } else if (this.units === \"decibels\") {\n        return -Infinity;\n      } else {\n        return this._param.minValue;\n      }\n    }\n  }, {\n    key: \"maxValue\",\n    get: function get() {\n      if (isDefined(this._maxValue)) {\n        return this._maxValue;\n      } else if (this.units === \"normalRange\" || this.units === \"audioRange\") {\n        return 1;\n      } else {\n        return this._param.maxValue;\n      }\n    }\n  }, {\n    key: \"defaultValue\",\n    get: function get() {\n      return this._toType(this._param.defaultValue);\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneWithContext.getDefaults(), {\n        convert: true,\n        units: \"number\"\n      });\n    }\n  }]);\n\n  return Param;\n}(ToneWithContext);","map":{"version":3,"sources":["../../../../Tone/core/context/Param.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n        this.name = \"Param\";\n        this.overridden = false;\n        /**\n         * The minimum output value\n         */\n        this._minOutput = 1e-7;\n        const options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n        assert(isDefined(options.param) &&\n            (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n        while (!isAudioParam(options.param)) {\n            options.param = options.param._param;\n        }\n        this._swappable = isDefined(options.swappable) ? options.swappable : false;\n        if (this._swappable) {\n            this.input = this.context.createGain();\n            // initialize\n            this._param = options.param;\n            this.input.connect(this._param);\n        }\n        else {\n            this._param = this.input = options.param;\n        }\n        this._events = new Timeline(1000);\n        this._initialValue = this._param.defaultValue;\n        this.units = options.units;\n        this.convert = options.convert;\n        this._minValue = options.minValue;\n        this._maxValue = options.maxValue;\n        // if the value is defined, set it immediately\n        if (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n            this.setValueAtTime(options.value, 0);\n        }\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            convert: true,\n            units: \"number\",\n        });\n    }\n    get value() {\n        const now = this.now();\n        return this.getValueAtTime(now);\n    }\n    set value(value) {\n        this.cancelScheduledValues(this.now());\n        this.setValueAtTime(value, this.now());\n    }\n    get minValue() {\n        // if it's not the default minValue, return it\n        if (isDefined(this._minValue)) {\n            return this._minValue;\n        }\n        else if (this.units === \"time\" || this.units === \"frequency\" ||\n            this.units === \"normalRange\" || this.units === \"positive\" ||\n            this.units === \"transportTime\" || this.units === \"ticks\" ||\n            this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n            return 0;\n        }\n        else if (this.units === \"audioRange\") {\n            return -1;\n        }\n        else if (this.units === \"decibels\") {\n            return -Infinity;\n        }\n        else {\n            return this._param.minValue;\n        }\n    }\n    get maxValue() {\n        if (isDefined(this._maxValue)) {\n            return this._maxValue;\n        }\n        else if (this.units === \"normalRange\" ||\n            this.units === \"audioRange\") {\n            return 1;\n        }\n        else {\n            return this._param.maxValue;\n        }\n    }\n    /**\n     * Type guard based on the unit name\n     */\n    _is(arg, type) {\n        return this.units === type;\n    }\n    /**\n     * Make sure the value is always in the defined range\n     */\n    _assertRange(value) {\n        if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n            assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n        }\n        return value;\n    }\n    /**\n     * Convert the given value from the type specified by Param.units\n     * into the destination value (such as Gain or Frequency).\n     */\n    _fromType(val) {\n        if (this.convert && !this.overridden) {\n            if (this._is(val, \"time\")) {\n                return this.toSeconds(val);\n            }\n            else if (this._is(val, \"decibels\")) {\n                return dbToGain(val);\n            }\n            else if (this._is(val, \"frequency\")) {\n                return this.toFrequency(val);\n            }\n            else {\n                return val;\n            }\n        }\n        else if (this.overridden) {\n            // if it's overridden, should only schedule 0s\n            return 0;\n        }\n        else {\n            return val;\n        }\n    }\n    /**\n     * Convert the parameters value into the units specified by Param.units.\n     */\n    _toType(val) {\n        if (this.convert && this.units === \"decibels\") {\n            return gainToDb(val);\n        }\n        else {\n            return val;\n        }\n    }\n    //-------------------------------------\n    // ABSTRACT PARAM INTERFACE\n    // all docs are generated from ParamInterface.ts\n    //-------------------------------------\n    setValueAtTime(value, time) {\n        const computedTime = this.toSeconds(time);\n        const numericValue = this._fromType(value);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n        this._assertRange(numericValue);\n        this.log(this.units, \"setValueAtTime\", value, computedTime);\n        this._events.add({\n            time: computedTime,\n            type: \"setValueAtTime\",\n            value: numericValue,\n        });\n        this._param.setValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    getValueAtTime(time) {\n        const computedTime = Math.max(this.toSeconds(time), 0);\n        const after = this._events.getAfter(computedTime);\n        const before = this._events.get(computedTime);\n        let value = this._initialValue;\n        // if it was set by\n        if (before === null) {\n            value = this._initialValue;\n        }\n        else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n            const previous = this._events.getBefore(before.time);\n            let previousVal;\n            if (previous === null) {\n                previousVal = this._initialValue;\n            }\n            else {\n                previousVal = previous.value;\n            }\n            if (before.type === \"setTargetAtTime\") {\n                value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n            }\n        }\n        else if (after === null) {\n            value = before.value;\n        }\n        else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n            let beforeValue = before.value;\n            if (before.type === \"setTargetAtTime\") {\n                const previous = this._events.getBefore(before.time);\n                if (previous === null) {\n                    beforeValue = this._initialValue;\n                }\n                else {\n                    beforeValue = previous.value;\n                }\n            }\n            if (after.type === \"linearRampToValueAtTime\") {\n                value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n            }\n            else {\n                value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n            }\n        }\n        else {\n            value = before.value;\n        }\n        return this._toType(value);\n    }\n    setRampPoint(time) {\n        time = this.toSeconds(time);\n        let currentVal = this.getValueAtTime(time);\n        this.cancelAndHoldAtTime(time);\n        if (this._fromType(currentVal) === 0) {\n            currentVal = this._toType(this._minOutput);\n        }\n        this.setValueAtTime(currentVal, time);\n        return this;\n    }\n    linearRampToValueAtTime(value, endTime) {\n        const numericValue = this._fromType(value);\n        const computedTime = this.toSeconds(endTime);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n        this._assertRange(numericValue);\n        this._events.add({\n            time: computedTime,\n            type: \"linearRampToValueAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n        this._param.linearRampToValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    exponentialRampToValueAtTime(value, endTime) {\n        let numericValue = this._fromType(value);\n        numericValue = Math.max(this._minOutput, numericValue);\n        this._assertRange(numericValue);\n        const computedTime = this.toSeconds(endTime);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n        // store the event\n        this._events.add({\n            time: computedTime,\n            type: \"exponentialRampToValueAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n        this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n        return this;\n    }\n    exponentialRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n        return this;\n    }\n    linearRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n        return this;\n    }\n    targetRampTo(value, rampTime, startTime) {\n        startTime = this.toSeconds(startTime);\n        this.setRampPoint(startTime);\n        this.exponentialApproachValueAtTime(value, startTime, rampTime);\n        return this;\n    }\n    exponentialApproachValueAtTime(value, time, rampTime) {\n        time = this.toSeconds(time);\n        rampTime = this.toSeconds(rampTime);\n        const timeConstant = Math.log(rampTime + 1) / Math.log(200);\n        this.setTargetAtTime(value, time, timeConstant);\n        // at 90% start a linear ramp to the final value\n        this.cancelAndHoldAtTime(time + rampTime * 0.9);\n        this.linearRampToValueAtTime(value, time + rampTime);\n        return this;\n    }\n    setTargetAtTime(value, startTime, timeConstant) {\n        const numericValue = this._fromType(value);\n        // The value will never be able to approach without timeConstant > 0.\n        assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n        const computedTime = this.toSeconds(startTime);\n        this._assertRange(numericValue);\n        assert(isFinite(numericValue) && isFinite(computedTime), `Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n        this._events.add({\n            constant: timeConstant,\n            time: computedTime,\n            type: \"setTargetAtTime\",\n            value: numericValue,\n        });\n        this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n        this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n        return this;\n    }\n    setValueCurveAtTime(values, startTime, duration, scaling = 1) {\n        duration = this.toSeconds(duration);\n        startTime = this.toSeconds(startTime);\n        const startingValue = this._fromType(values[0]) * scaling;\n        this.setValueAtTime(this._toType(startingValue), startTime);\n        const segTime = duration / (values.length - 1);\n        for (let i = 1; i < values.length; i++) {\n            const numericValue = this._fromType(values[i]) * scaling;\n            this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n        }\n        return this;\n    }\n    cancelScheduledValues(time) {\n        const computedTime = this.toSeconds(time);\n        assert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n        this._events.cancel(computedTime);\n        this._param.cancelScheduledValues(computedTime);\n        this.log(this.units, \"cancelScheduledValues\", computedTime);\n        return this;\n    }\n    cancelAndHoldAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        const valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n        // remove the schedule events\n        assert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n        this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n        // if there is an event at the given computedTime\n        // and that even is not a \"set\"\n        const before = this._events.get(computedTime);\n        const after = this._events.getAfter(computedTime);\n        if (before && EQ(before.time, computedTime)) {\n            // remove everything after\n            if (after) {\n                this._param.cancelScheduledValues(after.time);\n                this._events.cancel(after.time);\n            }\n            else {\n                this._param.cancelAndHoldAtTime(computedTime);\n                this._events.cancel(computedTime + this.sampleTime);\n            }\n        }\n        else if (after) {\n            this._param.cancelScheduledValues(after.time);\n            // cancel the next event(s)\n            this._events.cancel(after.time);\n            if (after.type === \"linearRampToValueAtTime\") {\n                this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n            }\n            else if (after.type === \"exponentialRampToValueAtTime\") {\n                this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n            }\n        }\n        // set the value at the given time\n        this._events.add({\n            time: computedTime,\n            type: \"setValueAtTime\",\n            value: valueAtTime,\n        });\n        this._param.setValueAtTime(valueAtTime, computedTime);\n        return this;\n    }\n    rampTo(value, rampTime = 0.1, startTime) {\n        if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n            this.exponentialRampTo(value, rampTime, startTime);\n        }\n        else {\n            this.linearRampTo(value, rampTime, startTime);\n        }\n        return this;\n    }\n    /**\n     * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n     * The applied values will start at the context's current time and schedule\n     * all of the events which are scheduled on this Param onto the passed in param.\n     */\n    apply(param) {\n        const now = this.context.currentTime;\n        // set the param's value at the current time and schedule everything else\n        param.setValueAtTime(this.getValueAtTime(now), now);\n        // if the previous event was a curve, then set the rest of it\n        const previousEvent = this._events.get(now);\n        if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n            // approx it until the next event with linear ramps\n            const nextEvent = this._events.getAfter(previousEvent.time);\n            // or for 2 seconds if there is no event\n            const endTime = nextEvent ? nextEvent.time : now + 2;\n            const subdivisions = (endTime - now) / 10;\n            for (let i = now; i < endTime; i += subdivisions) {\n                param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n            }\n        }\n        this._events.forEachAfter(this.context.currentTime, event => {\n            if (event.type === \"cancelScheduledValues\") {\n                param.cancelScheduledValues(event.time);\n            }\n            else if (event.type === \"setTargetAtTime\") {\n                param.setTargetAtTime(event.value, event.time, event.constant);\n            }\n            else {\n                param[event.type](event.value, event.time);\n            }\n        });\n        return this;\n    }\n    /**\n     * Replace the Param's internal AudioParam. Will apply scheduled curves\n     * onto the parameter and replace the connections.\n     */\n    setParam(param) {\n        assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n        const input = this.input;\n        input.disconnect(this._param);\n        this.apply(param);\n        this._param = param;\n        input.connect(this._param);\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._events.dispose();\n        return this;\n    }\n    get defaultValue() {\n        return this._toType(this._param.defaultValue);\n    }\n    //-------------------------------------\n    // \tAUTOMATION CURVE CALCULATIONS\n    // \tMIT License, copyright (c) 2014 Jordan Santell\n    //-------------------------------------\n    // Calculates the the value along the curve produced by setTargetAtTime\n    _exponentialApproach(t0, v0, v1, timeConstant, t) {\n        return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n    }\n    // Calculates the the value along the curve produced by linearRampToValueAtTime\n    _linearInterpolate(t0, v0, t1, v1, t) {\n        return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n    }\n    // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n    _exponentialInterpolate(t0, v0, t1, v1, t) {\n        return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n    }\n}\n//# sourceMappingURL=Param.js.map"]},"metadata":{},"sourceType":"module"}