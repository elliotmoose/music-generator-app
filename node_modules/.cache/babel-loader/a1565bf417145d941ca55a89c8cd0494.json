{"ast":null,"code":"var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),\n    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),\n    CONST = require('../../const');\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's SpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\n */\n\n\nfunction SpriteRenderer(renderer) {\n  ObjectRenderer.call(this, renderer);\n  /**\n   * Number of values sent in the vertex buffer.\n   * positionX, positionY, colorR, colorG, colorB = 5\n   *\n   * @member {number}\n   */\n\n  this.vertSize = 5;\n  /**\n   * The size of the vertex information in bytes.\n   *\n   * @member {number}\n   */\n\n  this.vertByteSize = this.vertSize * 4;\n  /**\n   * The number of images in the SpriteBatch before it flushes.\n   *\n   * @member {number}\n   */\n\n  this.size = CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n  // the total number of bytes in our batch\n\n  var numVerts = this.size * 4 * this.vertByteSize; // the total number of indices in our batch, there are 6 points per quad.\n\n  var numIndices = this.size * 6;\n  /**\n   * Holds the vertex data that will be sent to the vertex shader.\n   *\n   * @member {ArrayBuffer}\n   */\n\n  this.vertices = new ArrayBuffer(numVerts);\n  /**\n   * View on the vertices as a Float32Array for positions\n   *\n   * @member {Float32Array}\n   */\n\n  this.positions = new Float32Array(this.vertices);\n  /**\n   * View on the vertices as a Uint32Array for colors\n   *\n   * @member {Uint32Array}\n   */\n\n  this.colors = new Uint32Array(this.vertices);\n  /**\n   * Holds the indices of the geometry (quads) to draw\n   *\n   * @member {Uint16Array}\n   */\n\n  this.indices = new Uint16Array(numIndices); // fill the indices with the quads to draw\n\n  for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {\n    this.indices[i + 0] = j + 0;\n    this.indices[i + 1] = j + 1;\n    this.indices[i + 2] = j + 2;\n    this.indices[i + 3] = j + 0;\n    this.indices[i + 4] = j + 2;\n    this.indices[i + 5] = j + 3;\n  }\n  /**\n   * The current size of the batch, each render() call adds to this number.\n   *\n   * @member {number}\n   */\n\n\n  this.currentBatchSize = 0;\n  /**\n   * The current sprites in the batch.\n   *\n   * @member {Array}\n   */\n\n  this.sprites = [];\n  /**\n   * The default shader that is used if a sprite doesn't have a more specific one.\n   *\n   * @member {Shader}\n   */\n\n  this.shader = null;\n}\n\nSpriteRenderer.prototype = Object.create(ObjectRenderer.prototype);\nSpriteRenderer.prototype.constructor = SpriteRenderer;\nmodule.exports = SpriteRenderer;\nWebGLRenderer.registerPlugin('sprite', SpriteRenderer);\n/**\n * Sets up the renderer context and necessary buffers.\n *\n * @private\n * @param gl {WebGLRenderingContext} the current WebGL drawing context\n */\n\nSpriteRenderer.prototype.onContextChange = function () {\n  var gl = this.renderer.gl; // setup default shader\n\n  this.shader = this.renderer.shaderManager.defaultShader; // create a couple of buffers\n\n  this.vertexBuffer = gl.createBuffer();\n  this.indexBuffer = gl.createBuffer(); //upload the index data\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n  gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n  this.currentBlendMode = 99999;\n};\n/**\n * Renders the sprite object.\n *\n * @param sprite {Sprite} the sprite to render when using this spritebatch\n */\n\n\nSpriteRenderer.prototype.render = function (sprite) {\n  var texture = sprite._texture; //TODO set blend modes..\n  // check texture..\n\n  if (this.currentBatchSize >= this.size) {\n    this.flush();\n  } // get the uvs for the texture\n\n\n  var uvs = texture._uvs; // if the uvs have not updated then no point rendering just yet!\n\n  if (!uvs) {\n    return;\n  } // TODO trim??\n\n\n  var aX = sprite.anchor.x;\n  var aY = sprite.anchor.y;\n  var w0, w1, h0, h1;\n\n  if (texture.trim) {\n    // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n    var trim = texture.trim;\n    w1 = trim.x - aX * trim.width;\n    w0 = w1 + texture.crop.width;\n    h1 = trim.y - aY * trim.height;\n    h0 = h1 + texture.crop.height;\n  } else {\n    w0 = texture._frame.width * (1 - aX);\n    w1 = texture._frame.width * -aX;\n    h0 = texture._frame.height * (1 - aY);\n    h1 = texture._frame.height * -aY;\n  }\n\n  var index = this.currentBatchSize * this.vertByteSize;\n  var worldTransform = sprite.worldTransform;\n  var a = worldTransform.a;\n  var b = worldTransform.b;\n  var c = worldTransform.c;\n  var d = worldTransform.d;\n  var tx = worldTransform.tx;\n  var ty = worldTransform.ty;\n  var colors = this.colors;\n  var positions = this.positions;\n\n  if (this.renderer.roundPixels) {\n    // xy\n    positions[index] = a * w1 + c * h1 + tx | 0;\n    positions[index + 1] = d * h1 + b * w1 + ty | 0; // xy\n\n    positions[index + 5] = a * w0 + c * h1 + tx | 0;\n    positions[index + 6] = d * h1 + b * w0 + ty | 0; // xy\n\n    positions[index + 10] = a * w0 + c * h0 + tx | 0;\n    positions[index + 11] = d * h0 + b * w0 + ty | 0; // xy\n\n    positions[index + 15] = a * w1 + c * h0 + tx | 0;\n    positions[index + 16] = d * h0 + b * w1 + ty | 0;\n  } else {\n    // xy\n    positions[index] = a * w1 + c * h1 + tx;\n    positions[index + 1] = d * h1 + b * w1 + ty; // xy\n\n    positions[index + 5] = a * w0 + c * h1 + tx;\n    positions[index + 6] = d * h1 + b * w0 + ty; // xy\n\n    positions[index + 10] = a * w0 + c * h0 + tx;\n    positions[index + 11] = d * h0 + b * w0 + ty; // xy\n\n    positions[index + 15] = a * w1 + c * h0 + tx;\n    positions[index + 16] = d * h0 + b * w1 + ty;\n  } // uv\n\n\n  positions[index + 2] = uvs.x0;\n  positions[index + 3] = uvs.y0; // uv\n\n  positions[index + 7] = uvs.x1;\n  positions[index + 8] = uvs.y1; // uv\n\n  positions[index + 12] = uvs.x2;\n  positions[index + 13] = uvs.y2; // uv\n\n  positions[index + 17] = uvs.x3;\n  positions[index + 18] = uvs.y3; // color and alpha\n\n  var tint = sprite.tint;\n  colors[index + 4] = colors[index + 9] = colors[index + 14] = colors[index + 19] = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24); // increment the batchsize\n\n  this.sprites[this.currentBatchSize++] = sprite;\n};\n/**\n * Renders the content and empties the current batch.\n *\n */\n\n\nSpriteRenderer.prototype.flush = function () {\n  // If the batch is length 0 then return as there is nothing to draw\n  if (this.currentBatchSize === 0) {\n    return;\n  }\n\n  var gl = this.renderer.gl;\n  var shader; // upload the verts to the buffer\n\n  if (this.currentBatchSize > this.size * 0.5) {\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n  } else {\n    var view = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);\n    gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n  }\n\n  var nextTexture, nextBlendMode, nextShader;\n  var batchSize = 0;\n  var start = 0;\n  var currentBaseTexture = null;\n  var currentBlendMode = this.renderer.blendModeManager.currentBlendMode;\n  var currentShader = null;\n  var blendSwap = false;\n  var shaderSwap = false;\n  var sprite;\n\n  for (var i = 0, j = this.currentBatchSize; i < j; i++) {\n    sprite = this.sprites[i];\n    nextTexture = sprite._texture.baseTexture;\n    nextBlendMode = sprite.blendMode;\n    nextShader = sprite.shader || this.shader;\n    blendSwap = currentBlendMode !== nextBlendMode;\n    shaderSwap = currentShader !== nextShader; // should I use uidS???\n\n    if (currentBaseTexture !== nextTexture || blendSwap || shaderSwap) {\n      this.renderBatch(currentBaseTexture, batchSize, start);\n      start = i;\n      batchSize = 0;\n      currentBaseTexture = nextTexture;\n\n      if (blendSwap) {\n        currentBlendMode = nextBlendMode;\n        this.renderer.blendModeManager.setBlendMode(currentBlendMode);\n      }\n\n      if (shaderSwap) {\n        currentShader = nextShader;\n        shader = currentShader.shaders ? currentShader.shaders[gl.id] : currentShader;\n\n        if (!shader) {\n          shader = currentShader.getShader(this.renderer);\n        } // set shader function???\n\n\n        this.renderer.shaderManager.setShader(shader); //TODO - i KNOW this can be optimised! Once v3 is stable il look at this next...\n\n        shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true); //Make this a little more dynamic / intelligent!\n\n        shader.syncUniforms(); //TODO investigate some kind of texture state managment??\n        // need to make sure this texture is the active one for all the batch swaps..\n\n        gl.activeTexture(gl.TEXTURE0); // both thease only need to be set if they are changing..\n        // set the projection\n        //gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));\n      }\n    }\n\n    batchSize++;\n  }\n\n  this.renderBatch(currentBaseTexture, batchSize, start); // then reset the batch!\n\n  this.currentBatchSize = 0;\n};\n/**\n * Draws the currently batches sprites.\n *\n * @private\n * @param texture {Texture}\n * @param size {number}\n * @param startIndex {number}\n */\n\n\nSpriteRenderer.prototype.renderBatch = function (texture, size, startIndex) {\n  if (size === 0) {\n    return;\n  }\n\n  var gl = this.renderer.gl;\n\n  if (!texture._glTextures[gl.id]) {\n    this.renderer.updateTexture(texture);\n  } else {\n    // bind the current texture\n    gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n  } // now draw those suckas!\n\n\n  gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2); // increment the draw count\n\n  this.renderer.drawCount++;\n};\n/**\n * Starts a new sprite batch.\n *\n */\n\n\nSpriteRenderer.prototype.start = function () {\n  var gl = this.renderer.gl; // bind the main texture\n  // bind the buffers\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer); // this is the same for each shader?\n\n  var stride = this.vertByteSize;\n  gl.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n  gl.vertexAttribPointer(this.shader.attributes.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4); // color attributes will be interpreted as unsigned bytes and normalized\n\n  gl.vertexAttribPointer(this.shader.attributes.aColor, 4, gl.UNSIGNED_BYTE, true, stride, 4 * 4);\n};\n/**\n * Destroys the SpriteBatch.\n *\n */\n\n\nSpriteRenderer.prototype.destroy = function () {\n  this.renderer.gl.deleteBuffer(this.vertexBuffer);\n  this.renderer.gl.deleteBuffer(this.indexBuffer);\n  this.shader.destroy();\n  this.renderer = null;\n  this.vertices = null;\n  this.positions = null;\n  this.colors = null;\n  this.indices = null;\n  this.vertexBuffer = null;\n  this.indexBuffer = null;\n  this.sprites = null;\n  this.shader = null;\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/sprites/webgl/SpriteRenderer.js"],"names":["ObjectRenderer","require","WebGLRenderer","CONST","SpriteRenderer","renderer","call","vertSize","vertByteSize","size","SPRITE_BATCH_SIZE","numVerts","numIndices","vertices","ArrayBuffer","positions","Float32Array","colors","Uint32Array","indices","Uint16Array","i","j","currentBatchSize","sprites","shader","prototype","Object","create","constructor","module","exports","registerPlugin","onContextChange","gl","shaderManager","defaultShader","vertexBuffer","createBuffer","indexBuffer","bindBuffer","ELEMENT_ARRAY_BUFFER","bufferData","STATIC_DRAW","ARRAY_BUFFER","DYNAMIC_DRAW","currentBlendMode","render","sprite","texture","_texture","flush","uvs","_uvs","aX","anchor","x","aY","y","w0","w1","h0","h1","trim","width","crop","height","_frame","index","worldTransform","a","b","c","d","tx","ty","roundPixels","x0","y0","x1","y1","x2","y2","x3","y3","tint","worldAlpha","bufferSubData","view","subarray","nextTexture","nextBlendMode","nextShader","batchSize","start","currentBaseTexture","blendModeManager","currentShader","blendSwap","shaderSwap","baseTexture","blendMode","renderBatch","setBlendMode","shaders","id","getShader","setShader","uniforms","projectionMatrix","value","currentRenderTarget","toArray","syncUniforms","activeTexture","TEXTURE0","startIndex","_glTextures","updateTexture","bindTexture","TEXTURE_2D","drawElements","TRIANGLES","UNSIGNED_SHORT","drawCount","stride","vertexAttribPointer","attributes","aVertexPosition","FLOAT","aTextureCoord","aColor","UNSIGNED_BYTE","destroy","deleteBuffer"],"mappings":"AAAA,IAAIA,cAAc,GAAGC,OAAO,CAAC,4CAAD,CAA5B;AAAA,IACIC,aAAa,GAAGD,OAAO,CAAC,qCAAD,CAD3B;AAAA,IAEIE,KAAK,GAAGF,OAAO,CAAC,aAAD,CAFnB;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASG,cAAT,CAAwBC,QAAxB,EACA;AACIL,EAAAA,cAAc,CAACM,IAAf,CAAoB,IAApB,EAA0BD,QAA1B;AAEA;AACJ;AACA;AACA;AACA;AACA;;AACI,OAAKE,QAAL,GAAgB,CAAhB;AAEA;AACJ;AACA;AACA;AACA;;AACI,OAAKC,YAAL,GAAoB,KAAKD,QAAL,GAAgB,CAApC;AAEA;AACJ;AACA;AACA;AACA;;AACI,OAAKE,IAAL,GAAYN,KAAK,CAACO,iBAAlB,CAvBJ,CAuByC;AAErC;;AACA,MAAIC,QAAQ,GAAI,KAAKF,IAAL,GAAY,CAAb,GAAkB,KAAKD,YAAtC,CA1BJ,CA4BI;;AACA,MAAII,UAAU,GAAG,KAAKH,IAAL,GAAY,CAA7B;AAEA;AACJ;AACA;AACA;AACA;;AACI,OAAKI,QAAL,GAAgB,IAAIC,WAAJ,CAAgBH,QAAhB,CAAhB;AAEA;AACJ;AACA;AACA;AACA;;AACI,OAAKI,SAAL,GAAiB,IAAIC,YAAJ,CAAiB,KAAKH,QAAtB,CAAjB;AAEA;AACJ;AACA;AACA;AACA;;AACI,OAAKI,MAAL,GAAc,IAAIC,WAAJ,CAAgB,KAAKL,QAArB,CAAd;AAEA;AACJ;AACA;AACA;AACA;;AACI,OAAKM,OAAL,GAAe,IAAIC,WAAJ,CAAgBR,UAAhB,CAAf,CAzDJ,CA2DI;;AACA,OAAK,IAAIS,CAAC,GAAC,CAAN,EAASC,CAAC,GAAC,CAAhB,EAAmBD,CAAC,GAAGT,UAAvB,EAAmCS,CAAC,IAAI,CAAL,EAAQC,CAAC,IAAI,CAAhD,EACA;AACI,SAAKH,OAAL,CAAaE,CAAC,GAAG,CAAjB,IAAsBC,CAAC,GAAG,CAA1B;AACA,SAAKH,OAAL,CAAaE,CAAC,GAAG,CAAjB,IAAsBC,CAAC,GAAG,CAA1B;AACA,SAAKH,OAAL,CAAaE,CAAC,GAAG,CAAjB,IAAsBC,CAAC,GAAG,CAA1B;AACA,SAAKH,OAAL,CAAaE,CAAC,GAAG,CAAjB,IAAsBC,CAAC,GAAG,CAA1B;AACA,SAAKH,OAAL,CAAaE,CAAC,GAAG,CAAjB,IAAsBC,CAAC,GAAG,CAA1B;AACA,SAAKH,OAAL,CAAaE,CAAC,GAAG,CAAjB,IAAsBC,CAAC,GAAG,CAA1B;AACH;AAED;AACJ;AACA;AACA;AACA;;;AACI,OAAKC,gBAAL,GAAwB,CAAxB;AAEA;AACJ;AACA;AACA;AACA;;AACI,OAAKC,OAAL,GAAe,EAAf;AAEA;AACJ;AACA;AACA;AACA;;AACI,OAAKC,MAAL,GAAc,IAAd;AAEH;;AAEDrB,cAAc,CAACsB,SAAf,GAA2BC,MAAM,CAACC,MAAP,CAAc5B,cAAc,CAAC0B,SAA7B,CAA3B;AACAtB,cAAc,CAACsB,SAAf,CAAyBG,WAAzB,GAAuCzB,cAAvC;AACA0B,MAAM,CAACC,OAAP,GAAiB3B,cAAjB;AAEAF,aAAa,CAAC8B,cAAd,CAA6B,QAA7B,EAAuC5B,cAAvC;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAA,cAAc,CAACsB,SAAf,CAAyBO,eAAzB,GAA2C,YAC3C;AACI,MAAIC,EAAE,GAAG,KAAK7B,QAAL,CAAc6B,EAAvB,CADJ,CAGI;;AACA,OAAKT,MAAL,GAAc,KAAKpB,QAAL,CAAc8B,aAAd,CAA4BC,aAA1C,CAJJ,CAMI;;AACA,OAAKC,YAAL,GAAoBH,EAAE,CAACI,YAAH,EAApB;AACA,OAAKC,WAAL,GAAmBL,EAAE,CAACI,YAAH,EAAnB,CARJ,CAUI;;AACAJ,EAAAA,EAAE,CAACM,UAAH,CAAcN,EAAE,CAACO,oBAAjB,EAAuC,KAAKF,WAA5C;AACAL,EAAAA,EAAE,CAACQ,UAAH,CAAcR,EAAE,CAACO,oBAAjB,EAAuC,KAAKtB,OAA5C,EAAqDe,EAAE,CAACS,WAAxD;AAEAT,EAAAA,EAAE,CAACM,UAAH,CAAcN,EAAE,CAACU,YAAjB,EAA+B,KAAKP,YAApC;AACAH,EAAAA,EAAE,CAACQ,UAAH,CAAcR,EAAE,CAACU,YAAjB,EAA+B,KAAK/B,QAApC,EAA8CqB,EAAE,CAACW,YAAjD;AAEA,OAAKC,gBAAL,GAAwB,KAAxB;AACH,CAnBD;AAqBA;AACA;AACA;AACA;AACA;;;AACA1C,cAAc,CAACsB,SAAf,CAAyBqB,MAAzB,GAAkC,UAAUC,MAAV,EAClC;AACI,MAAIC,OAAO,GAAGD,MAAM,CAACE,QAArB,CADJ,CAGI;AACA;;AACA,MAAI,KAAK3B,gBAAL,IAAyB,KAAKd,IAAlC,EACA;AACI,SAAK0C,KAAL;AACH,GARL,CAUI;;;AACA,MAAIC,GAAG,GAAGH,OAAO,CAACI,IAAlB,CAXJ,CAaI;;AACA,MAAI,CAACD,GAAL,EACA;AACI;AACH,GAjBL,CAmBI;;;AACA,MAAIE,EAAE,GAAGN,MAAM,CAACO,MAAP,CAAcC,CAAvB;AACA,MAAIC,EAAE,GAAGT,MAAM,CAACO,MAAP,CAAcG,CAAvB;AAEA,MAAIC,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;;AAEA,MAAIb,OAAO,CAACc,IAAZ,EACA;AACI;AACA,QAAIA,IAAI,GAAGd,OAAO,CAACc,IAAnB;AAEAH,IAAAA,EAAE,GAAGG,IAAI,CAACP,CAAL,GAASF,EAAE,GAAGS,IAAI,CAACC,KAAxB;AACAL,IAAAA,EAAE,GAAGC,EAAE,GAAGX,OAAO,CAACgB,IAAR,CAAaD,KAAvB;AAEAF,IAAAA,EAAE,GAAGC,IAAI,CAACL,CAAL,GAASD,EAAE,GAAGM,IAAI,CAACG,MAAxB;AACAL,IAAAA,EAAE,GAAGC,EAAE,GAAGb,OAAO,CAACgB,IAAR,CAAaC,MAAvB;AAEH,GAXD,MAaA;AACIP,IAAAA,EAAE,GAAIV,OAAO,CAACkB,MAAR,CAAeH,KAAhB,IAA2B,IAAEV,EAA7B,CAAL;AACAM,IAAAA,EAAE,GAAIX,OAAO,CAACkB,MAAR,CAAeH,KAAhB,GAA0B,CAACV,EAAhC;AAEAO,IAAAA,EAAE,GAAGZ,OAAO,CAACkB,MAAR,CAAeD,MAAf,IAAyB,IAAET,EAA3B,CAAL;AACAK,IAAAA,EAAE,GAAGb,OAAO,CAACkB,MAAR,CAAeD,MAAf,GAAwB,CAACT,EAA9B;AACH;;AAED,MAAIW,KAAK,GAAG,KAAK7C,gBAAL,GAAwB,KAAKf,YAAzC;AAEA,MAAI6D,cAAc,GAAGrB,MAAM,CAACqB,cAA5B;AAEA,MAAIC,CAAC,GAAGD,cAAc,CAACC,CAAvB;AACA,MAAIC,CAAC,GAAGF,cAAc,CAACE,CAAvB;AACA,MAAIC,CAAC,GAAGH,cAAc,CAACG,CAAvB;AACA,MAAIC,CAAC,GAAGJ,cAAc,CAACI,CAAvB;AACA,MAAIC,EAAE,GAAGL,cAAc,CAACK,EAAxB;AACA,MAAIC,EAAE,GAAGN,cAAc,CAACM,EAAxB;AAEA,MAAI1D,MAAM,GAAG,KAAKA,MAAlB;AACA,MAAIF,SAAS,GAAG,KAAKA,SAArB;;AAEA,MAAI,KAAKV,QAAL,CAAcuE,WAAlB,EACA;AACI;AACA7D,IAAAA,SAAS,CAACqD,KAAD,CAAT,GAAmBE,CAAC,GAAGV,EAAJ,GAASY,CAAC,GAAGV,EAAb,GAAkBY,EAAlB,GAAuB,CAA1C;AACA3D,IAAAA,SAAS,CAACqD,KAAK,GAAC,CAAP,CAAT,GAAqBK,CAAC,GAAGX,EAAJ,GAASS,CAAC,GAAGX,EAAb,GAAkBe,EAAlB,GAAuB,CAA5C,CAHJ,CAKI;;AACA5D,IAAAA,SAAS,CAACqD,KAAK,GAAC,CAAP,CAAT,GAAqBE,CAAC,GAAGX,EAAJ,GAASa,CAAC,GAAGV,EAAb,GAAkBY,EAAlB,GAAuB,CAA5C;AACA3D,IAAAA,SAAS,CAACqD,KAAK,GAAC,CAAP,CAAT,GAAqBK,CAAC,GAAGX,EAAJ,GAASS,CAAC,GAAGZ,EAAb,GAAkBgB,EAAlB,GAAuB,CAA5C,CAPJ,CASK;;AACD5D,IAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBE,CAAC,GAAGX,EAAJ,GAASa,CAAC,GAAGX,EAAb,GAAkBa,EAAlB,GAAuB,CAA7C;AACA3D,IAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBK,CAAC,GAAGZ,EAAJ,GAASU,CAAC,GAAGZ,EAAb,GAAkBgB,EAAlB,GAAuB,CAA7C,CAXJ,CAaI;;AACA5D,IAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBE,CAAC,GAAGV,EAAJ,GAASY,CAAC,GAAGX,EAAb,GAAkBa,EAAlB,GAAuB,CAA7C;AACA3D,IAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBK,CAAC,GAAGZ,EAAJ,GAASU,CAAC,GAAGX,EAAb,GAAkBe,EAAlB,GAAuB,CAA7C;AACH,GAjBD,MAmBA;AACI;AACA5D,IAAAA,SAAS,CAACqD,KAAD,CAAT,GAAmBE,CAAC,GAAGV,EAAJ,GAASY,CAAC,GAAGV,EAAb,GAAkBY,EAArC;AACA3D,IAAAA,SAAS,CAACqD,KAAK,GAAC,CAAP,CAAT,GAAqBK,CAAC,GAAGX,EAAJ,GAASS,CAAC,GAAGX,EAAb,GAAkBe,EAAvC,CAHJ,CAKI;;AACA5D,IAAAA,SAAS,CAACqD,KAAK,GAAC,CAAP,CAAT,GAAqBE,CAAC,GAAGX,EAAJ,GAASa,CAAC,GAAGV,EAAb,GAAkBY,EAAvC;AACA3D,IAAAA,SAAS,CAACqD,KAAK,GAAC,CAAP,CAAT,GAAqBK,CAAC,GAAGX,EAAJ,GAASS,CAAC,GAAGZ,EAAb,GAAkBgB,EAAvC,CAPJ,CASK;;AACD5D,IAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBE,CAAC,GAAGX,EAAJ,GAASa,CAAC,GAAGX,EAAb,GAAkBa,EAAxC;AACA3D,IAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBK,CAAC,GAAGZ,EAAJ,GAASU,CAAC,GAAGZ,EAAb,GAAkBgB,EAAxC,CAXJ,CAaI;;AACA5D,IAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBE,CAAC,GAAGV,EAAJ,GAASY,CAAC,GAAGX,EAAb,GAAkBa,EAAxC;AACA3D,IAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBK,CAAC,GAAGZ,EAAJ,GAASU,CAAC,GAAGX,EAAb,GAAkBe,EAAxC;AACH,GA/FL,CAiGI;;;AACA5D,EAAAA,SAAS,CAACqD,KAAK,GAAC,CAAP,CAAT,GAAqBhB,GAAG,CAACyB,EAAzB;AACA9D,EAAAA,SAAS,CAACqD,KAAK,GAAC,CAAP,CAAT,GAAqBhB,GAAG,CAAC0B,EAAzB,CAnGJ,CAqGI;;AACA/D,EAAAA,SAAS,CAACqD,KAAK,GAAC,CAAP,CAAT,GAAqBhB,GAAG,CAAC2B,EAAzB;AACAhE,EAAAA,SAAS,CAACqD,KAAK,GAAC,CAAP,CAAT,GAAqBhB,GAAG,CAAC4B,EAAzB,CAvGJ,CAyGK;;AACDjE,EAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBhB,GAAG,CAAC6B,EAA1B;AACAlE,EAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBhB,GAAG,CAAC8B,EAA1B,CA3GJ,CA6GI;;AACAnE,EAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBhB,GAAG,CAAC+B,EAA1B;AACApE,EAAAA,SAAS,CAACqD,KAAK,GAAC,EAAP,CAAT,GAAsBhB,GAAG,CAACgC,EAA1B,CA/GJ,CAiHI;;AACA,MAAIC,IAAI,GAAGrC,MAAM,CAACqC,IAAlB;AACApE,EAAAA,MAAM,CAACmD,KAAK,GAAC,CAAP,CAAN,GAAkBnD,MAAM,CAACmD,KAAK,GAAC,CAAP,CAAN,GAAkBnD,MAAM,CAACmD,KAAK,GAAC,EAAP,CAAN,GAAmBnD,MAAM,CAACmD,KAAK,GAAC,EAAP,CAAN,GAAmB,CAACiB,IAAI,IAAI,EAAT,KAAgBA,IAAI,GAAG,MAAvB,KAAkC,CAACA,IAAI,GAAG,IAAR,KAAiB,EAAnD,KAA0DrC,MAAM,CAACsC,UAAP,GAAoB,GAApB,IAA2B,EAArF,CAA1E,CAnHJ,CAqHI;;AACA,OAAK9D,OAAL,CAAa,KAAKD,gBAAL,EAAb,IAAwCyB,MAAxC;AACH,CAxHD;AA0HA;AACA;AACA;AACA;;;AACA5C,cAAc,CAACsB,SAAf,CAAyByB,KAAzB,GAAiC,YACjC;AACI;AACA,MAAI,KAAK5B,gBAAL,KAA0B,CAA9B,EACA;AACI;AACH;;AAED,MAAIW,EAAE,GAAG,KAAK7B,QAAL,CAAc6B,EAAvB;AACA,MAAIT,MAAJ,CARJ,CAUI;;AACA,MAAI,KAAKF,gBAAL,GAA0B,KAAKd,IAAL,GAAY,GAA1C,EACA;AACIyB,IAAAA,EAAE,CAACqD,aAAH,CAAiBrD,EAAE,CAACU,YAApB,EAAkC,CAAlC,EAAqC,KAAK/B,QAA1C;AACH,GAHD,MAKA;AACI,QAAI2E,IAAI,GAAG,KAAKzE,SAAL,CAAe0E,QAAf,CAAwB,CAAxB,EAA2B,KAAKlE,gBAAL,GAAwB,KAAKf,YAAxD,CAAX;AACA0B,IAAAA,EAAE,CAACqD,aAAH,CAAiBrD,EAAE,CAACU,YAApB,EAAkC,CAAlC,EAAqC4C,IAArC;AACH;;AAED,MAAIE,WAAJ,EAAiBC,aAAjB,EAAgCC,UAAhC;AACA,MAAIC,SAAS,GAAG,CAAhB;AACA,MAAIC,KAAK,GAAG,CAAZ;AAEA,MAAIC,kBAAkB,GAAG,IAAzB;AACA,MAAIjD,gBAAgB,GAAG,KAAKzC,QAAL,CAAc2F,gBAAd,CAA+BlD,gBAAtD;AACA,MAAImD,aAAa,GAAG,IAApB;AAEA,MAAIC,SAAS,GAAG,KAAhB;AACA,MAAIC,UAAU,GAAG,KAAjB;AACA,MAAInD,MAAJ;;AAEA,OAAK,IAAI3B,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG,KAAKC,gBAAzB,EAA2CF,CAAC,GAAGC,CAA/C,EAAkDD,CAAC,EAAnD,EACA;AAEI2B,IAAAA,MAAM,GAAG,KAAKxB,OAAL,CAAaH,CAAb,CAAT;AAEAqE,IAAAA,WAAW,GAAG1C,MAAM,CAACE,QAAP,CAAgBkD,WAA9B;AACAT,IAAAA,aAAa,GAAG3C,MAAM,CAACqD,SAAvB;AACAT,IAAAA,UAAU,GAAG5C,MAAM,CAACvB,MAAP,IAAiB,KAAKA,MAAnC;AAEAyE,IAAAA,SAAS,GAAGpD,gBAAgB,KAAK6C,aAAjC;AACAQ,IAAAA,UAAU,GAAGF,aAAa,KAAKL,UAA/B,CATJ,CAS+C;;AAE3C,QAAIG,kBAAkB,KAAKL,WAAvB,IAAsCQ,SAAtC,IAAmDC,UAAvD,EACA;AACI,WAAKG,WAAL,CAAiBP,kBAAjB,EAAqCF,SAArC,EAAgDC,KAAhD;AAEAA,MAAAA,KAAK,GAAGzE,CAAR;AACAwE,MAAAA,SAAS,GAAG,CAAZ;AACAE,MAAAA,kBAAkB,GAAGL,WAArB;;AAEA,UAAIQ,SAAJ,EACA;AACIpD,QAAAA,gBAAgB,GAAG6C,aAAnB;AACA,aAAKtF,QAAL,CAAc2F,gBAAd,CAA+BO,YAA/B,CAA6CzD,gBAA7C;AACH;;AAED,UAAIqD,UAAJ,EACA;AACIF,QAAAA,aAAa,GAAGL,UAAhB;AAIAnE,QAAAA,MAAM,GAAGwE,aAAa,CAACO,OAAd,GAAwBP,aAAa,CAACO,OAAd,CAAsBtE,EAAE,CAACuE,EAAzB,CAAxB,GAAuDR,aAAhE;;AAEA,YAAI,CAACxE,MAAL,EACA;AACIA,UAAAA,MAAM,GAAGwE,aAAa,CAACS,SAAd,CAAwB,KAAKrG,QAA7B,CAAT;AAEH,SAXL,CAaI;;;AACA,aAAKA,QAAL,CAAc8B,aAAd,CAA4BwE,SAA5B,CAAsClF,MAAtC,EAdJ,CAgBI;;AACAA,QAAAA,MAAM,CAACmF,QAAP,CAAgBC,gBAAhB,CAAiCC,KAAjC,GAAyC,KAAKzG,QAAL,CAAc0G,mBAAd,CAAkCF,gBAAlC,CAAmDG,OAAnD,CAA2D,IAA3D,CAAzC,CAjBJ,CAkBI;;AACAvF,QAAAA,MAAM,CAACwF,YAAP,GAnBJ,CAqBI;AACA;;AACA/E,QAAAA,EAAE,CAACgF,aAAH,CAAiBhF,EAAE,CAACiF,QAApB,EAvBJ,CAyBI;AACA;AACA;AAGH;AACJ;;AAEDtB,IAAAA,SAAS;AACZ;;AAED,OAAKS,WAAL,CAAiBP,kBAAjB,EAAqCF,SAArC,EAAgDC,KAAhD,EAhGJ,CAkGI;;AACA,OAAKvE,gBAAL,GAAwB,CAAxB;AACH,CArGD;AAuGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAnB,cAAc,CAACsB,SAAf,CAAyB4E,WAAzB,GAAuC,UAAUrD,OAAV,EAAmBxC,IAAnB,EAAyB2G,UAAzB,EACvC;AACI,MAAI3G,IAAI,KAAK,CAAb,EACA;AACI;AACH;;AAED,MAAIyB,EAAE,GAAG,KAAK7B,QAAL,CAAc6B,EAAvB;;AAEA,MAAI,CAACe,OAAO,CAACoE,WAAR,CAAoBnF,EAAE,CAACuE,EAAvB,CAAL,EACA;AACI,SAAKpG,QAAL,CAAciH,aAAd,CAA4BrE,OAA5B;AACH,GAHD,MAKA;AACI;AACAf,IAAAA,EAAE,CAACqF,WAAH,CAAerF,EAAE,CAACsF,UAAlB,EAA8BvE,OAAO,CAACoE,WAAR,CAAoBnF,EAAE,CAACuE,EAAvB,CAA9B;AACH,GAhBL,CAkBI;;;AACAvE,EAAAA,EAAE,CAACuF,YAAH,CAAgBvF,EAAE,CAACwF,SAAnB,EAA8BjH,IAAI,GAAG,CAArC,EAAwCyB,EAAE,CAACyF,cAA3C,EAA2DP,UAAU,GAAG,CAAb,GAAiB,CAA5E,EAnBJ,CAqBI;;AACA,OAAK/G,QAAL,CAAcuH,SAAd;AACH,CAxBD;AA0BA;AACA;AACA;AACA;;;AACAxH,cAAc,CAACsB,SAAf,CAAyBoE,KAAzB,GAAiC,YACjC;AACI,MAAI5D,EAAE,GAAG,KAAK7B,QAAL,CAAc6B,EAAvB,CADJ,CAGI;AAGA;;AACAA,EAAAA,EAAE,CAACM,UAAH,CAAcN,EAAE,CAACU,YAAjB,EAA+B,KAAKP,YAApC;AACAH,EAAAA,EAAE,CAACM,UAAH,CAAcN,EAAE,CAACO,oBAAjB,EAAuC,KAAKF,WAA5C,EARJ,CAUI;;AACA,MAAIsF,MAAM,GAAI,KAAKrH,YAAnB;AACA0B,EAAAA,EAAE,CAAC4F,mBAAH,CAAuB,KAAKrG,MAAL,CAAYsG,UAAZ,CAAuBC,eAA9C,EAA+D,CAA/D,EAAkE9F,EAAE,CAAC+F,KAArE,EAA4E,KAA5E,EAAmFJ,MAAnF,EAA2F,CAA3F;AACA3F,EAAAA,EAAE,CAAC4F,mBAAH,CAAuB,KAAKrG,MAAL,CAAYsG,UAAZ,CAAuBG,aAA9C,EAA6D,CAA7D,EAAgEhG,EAAE,CAAC+F,KAAnE,EAA0E,KAA1E,EAAiFJ,MAAjF,EAAyF,IAAI,CAA7F,EAbJ,CAeI;;AACA3F,EAAAA,EAAE,CAAC4F,mBAAH,CAAuB,KAAKrG,MAAL,CAAYsG,UAAZ,CAAuBI,MAA9C,EAAsD,CAAtD,EAAyDjG,EAAE,CAACkG,aAA5D,EAA2E,IAA3E,EAAiFP,MAAjF,EAAyF,IAAI,CAA7F;AACH,CAlBD;AAoBA;AACA;AACA;AACA;;;AACAzH,cAAc,CAACsB,SAAf,CAAyB2G,OAAzB,GAAmC,YACnC;AACI,OAAKhI,QAAL,CAAc6B,EAAd,CAAiBoG,YAAjB,CAA8B,KAAKjG,YAAnC;AACA,OAAKhC,QAAL,CAAc6B,EAAd,CAAiBoG,YAAjB,CAA8B,KAAK/F,WAAnC;AAEA,OAAKd,MAAL,CAAY4G,OAAZ;AAEA,OAAKhI,QAAL,GAAgB,IAAhB;AAEA,OAAKQ,QAAL,GAAgB,IAAhB;AACA,OAAKE,SAAL,GAAiB,IAAjB;AACA,OAAKE,MAAL,GAAc,IAAd;AACA,OAAKE,OAAL,GAAe,IAAf;AAEA,OAAKkB,YAAL,GAAoB,IAApB;AACA,OAAKE,WAAL,GAAmB,IAAnB;AAEA,OAAKf,OAAL,GAAe,IAAf;AACA,OAAKC,MAAL,GAAc,IAAd;AACH,CAnBD","sourcesContent":["var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),\n    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),\n    CONST = require('../../const');\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's SpriteRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/SpriteRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n * @extends PIXI.ObjectRenderer\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\n */\nfunction SpriteRenderer(renderer)\n{\n    ObjectRenderer.call(this, renderer);\n\n    /**\n     * Number of values sent in the vertex buffer.\n     * positionX, positionY, colorR, colorG, colorB = 5\n     *\n     * @member {number}\n     */\n    this.vertSize = 5;\n\n    /**\n     * The size of the vertex information in bytes.\n     *\n     * @member {number}\n     */\n    this.vertByteSize = this.vertSize * 4;\n\n    /**\n     * The number of images in the SpriteBatch before it flushes.\n     *\n     * @member {number}\n     */\n    this.size = CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n\n    // the total number of bytes in our batch\n    var numVerts = (this.size * 4) * this.vertByteSize;\n\n    // the total number of indices in our batch, there are 6 points per quad.\n    var numIndices = this.size * 6;\n\n    /**\n     * Holds the vertex data that will be sent to the vertex shader.\n     *\n     * @member {ArrayBuffer}\n     */\n    this.vertices = new ArrayBuffer(numVerts);\n\n    /**\n     * View on the vertices as a Float32Array for positions\n     *\n     * @member {Float32Array}\n     */\n    this.positions = new Float32Array(this.vertices);\n\n    /**\n     * View on the vertices as a Uint32Array for colors\n     *\n     * @member {Uint32Array}\n     */\n    this.colors = new Uint32Array(this.vertices);\n\n    /**\n     * Holds the indices of the geometry (quads) to draw\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = new Uint16Array(numIndices);\n\n    // fill the indices with the quads to draw\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * The current size of the batch, each render() call adds to this number.\n     *\n     * @member {number}\n     */\n    this.currentBatchSize = 0;\n\n    /**\n     * The current sprites in the batch.\n     *\n     * @member {Array}\n     */\n    this.sprites = [];\n\n    /**\n     * The default shader that is used if a sprite doesn't have a more specific one.\n     *\n     * @member {Shader}\n     */\n    this.shader = null;\n\n}\n\nSpriteRenderer.prototype = Object.create(ObjectRenderer.prototype);\nSpriteRenderer.prototype.constructor = SpriteRenderer;\nmodule.exports = SpriteRenderer;\n\nWebGLRenderer.registerPlugin('sprite', SpriteRenderer);\n\n/**\n * Sets up the renderer context and necessary buffers.\n *\n * @private\n * @param gl {WebGLRenderingContext} the current WebGL drawing context\n */\nSpriteRenderer.prototype.onContextChange = function ()\n{\n    var gl = this.renderer.gl;\n\n    // setup default shader\n    this.shader = this.renderer.shaderManager.defaultShader;\n\n    // create a couple of buffers\n    this.vertexBuffer = gl.createBuffer();\n    this.indexBuffer = gl.createBuffer();\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, this.vertices, gl.DYNAMIC_DRAW);\n\n    this.currentBlendMode = 99999;\n};\n\n/**\n * Renders the sprite object.\n *\n * @param sprite {Sprite} the sprite to render when using this spritebatch\n */\nSpriteRenderer.prototype.render = function (sprite)\n{\n    var texture = sprite._texture;\n\n    //TODO set blend modes..\n    // check texture..\n    if (this.currentBatchSize >= this.size)\n    {\n        this.flush();\n    }\n\n    // get the uvs for the texture\n    var uvs = texture._uvs;\n\n    // if the uvs have not updated then no point rendering just yet!\n    if (!uvs)\n    {\n        return;\n    }\n\n    // TODO trim??\n    var aX = sprite.anchor.x;\n    var aY = sprite.anchor.y;\n\n    var w0, w1, h0, h1;\n\n    if (texture.trim)\n    {\n        // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n        var trim = texture.trim;\n\n        w1 = trim.x - aX * trim.width;\n        w0 = w1 + texture.crop.width;\n\n        h1 = trim.y - aY * trim.height;\n        h0 = h1 + texture.crop.height;\n\n    }\n    else\n    {\n        w0 = (texture._frame.width ) * (1-aX);\n        w1 = (texture._frame.width ) * -aX;\n\n        h0 = texture._frame.height * (1-aY);\n        h1 = texture._frame.height * -aY;\n    }\n\n    var index = this.currentBatchSize * this.vertByteSize;\n\n    var worldTransform = sprite.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var colors = this.colors;\n    var positions = this.positions;\n\n    if (this.renderer.roundPixels)\n    {\n        // xy\n        positions[index] = a * w1 + c * h1 + tx | 0;\n        positions[index+1] = d * h1 + b * w1 + ty | 0;\n\n        // xy\n        positions[index+5] = a * w0 + c * h1 + tx | 0;\n        positions[index+6] = d * h1 + b * w0 + ty | 0;\n\n         // xy\n        positions[index+10] = a * w0 + c * h0 + tx | 0;\n        positions[index+11] = d * h0 + b * w0 + ty | 0;\n\n        // xy\n        positions[index+15] = a * w1 + c * h0 + tx | 0;\n        positions[index+16] = d * h0 + b * w1 + ty | 0;\n    }\n    else\n    {\n        // xy\n        positions[index] = a * w1 + c * h1 + tx;\n        positions[index+1] = d * h1 + b * w1 + ty;\n\n        // xy\n        positions[index+5] = a * w0 + c * h1 + tx;\n        positions[index+6] = d * h1 + b * w0 + ty;\n\n         // xy\n        positions[index+10] = a * w0 + c * h0 + tx;\n        positions[index+11] = d * h0 + b * w0 + ty;\n\n        // xy\n        positions[index+15] = a * w1 + c * h0 + tx;\n        positions[index+16] = d * h0 + b * w1 + ty;\n    }\n\n    // uv\n    positions[index+2] = uvs.x0;\n    positions[index+3] = uvs.y0;\n\n    // uv\n    positions[index+7] = uvs.x1;\n    positions[index+8] = uvs.y1;\n\n     // uv\n    positions[index+12] = uvs.x2;\n    positions[index+13] = uvs.y2;\n\n    // uv\n    positions[index+17] = uvs.x3;\n    positions[index+18] = uvs.y3;\n\n    // color and alpha\n    var tint = sprite.tint;\n    colors[index+4] = colors[index+9] = colors[index+14] = colors[index+19] = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16) + (sprite.worldAlpha * 255 << 24);\n\n    // increment the batchsize\n    this.sprites[this.currentBatchSize++] = sprite;\n};\n\n/**\n * Renders the content and empties the current batch.\n *\n */\nSpriteRenderer.prototype.flush = function ()\n{\n    // If the batch is length 0 then return as there is nothing to draw\n    if (this.currentBatchSize === 0)\n    {\n        return;\n    }\n\n    var gl = this.renderer.gl;\n    var shader;\n\n    // upload the verts to the buffer\n    if (this.currentBatchSize > ( this.size * 0.5 ) )\n    {\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.vertices);\n    }\n    else\n    {\n        var view = this.positions.subarray(0, this.currentBatchSize * this.vertByteSize);\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, view);\n    }\n\n    var nextTexture, nextBlendMode, nextShader;\n    var batchSize = 0;\n    var start = 0;\n\n    var currentBaseTexture = null;\n    var currentBlendMode = this.renderer.blendModeManager.currentBlendMode;\n    var currentShader = null;\n\n    var blendSwap = false;\n    var shaderSwap = false;\n    var sprite;\n\n    for (var i = 0, j = this.currentBatchSize; i < j; i++)\n    {\n\n        sprite = this.sprites[i];\n\n        nextTexture = sprite._texture.baseTexture;\n        nextBlendMode = sprite.blendMode;\n        nextShader = sprite.shader || this.shader;\n\n        blendSwap = currentBlendMode !== nextBlendMode;\n        shaderSwap = currentShader !== nextShader; // should I use uidS???\n\n        if (currentBaseTexture !== nextTexture || blendSwap || shaderSwap)\n        {\n            this.renderBatch(currentBaseTexture, batchSize, start);\n\n            start = i;\n            batchSize = 0;\n            currentBaseTexture = nextTexture;\n\n            if (blendSwap)\n            {\n                currentBlendMode = nextBlendMode;\n                this.renderer.blendModeManager.setBlendMode( currentBlendMode );\n            }\n\n            if (shaderSwap)\n            {\n                currentShader = nextShader;\n\n\n\n                shader = currentShader.shaders ? currentShader.shaders[gl.id] : currentShader;\n\n                if (!shader)\n                {\n                    shader = currentShader.getShader(this.renderer);\n\n                }\n\n                // set shader function???\n                this.renderer.shaderManager.setShader(shader);\n\n                //TODO - i KNOW this can be optimised! Once v3 is stable il look at this next...\n                shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);\n                //Make this a little more dynamic / intelligent!\n                shader.syncUniforms();\n\n                //TODO investigate some kind of texture state managment??\n                // need to make sure this texture is the active one for all the batch swaps..\n                gl.activeTexture(gl.TEXTURE0);\n\n                // both thease only need to be set if they are changing..\n                // set the projection\n                //gl.uniformMatrix3fv(shader.uniforms.projectionMatrix._location, false, this.renderer.currentRenderTarget.projectionMatrix.toArray(true));\n\n\n            }\n        }\n\n        batchSize++;\n    }\n\n    this.renderBatch(currentBaseTexture, batchSize, start);\n\n    // then reset the batch!\n    this.currentBatchSize = 0;\n};\n\n/**\n * Draws the currently batches sprites.\n *\n * @private\n * @param texture {Texture}\n * @param size {number}\n * @param startIndex {number}\n */\nSpriteRenderer.prototype.renderBatch = function (texture, size, startIndex)\n{\n    if (size === 0)\n    {\n        return;\n    }\n\n    var gl = this.renderer.gl;\n\n    if (!texture._glTextures[gl.id])\n    {\n        this.renderer.updateTexture(texture);\n    }\n    else\n    {\n        // bind the current texture\n        gl.bindTexture(gl.TEXTURE_2D, texture._glTextures[gl.id]);\n    }\n\n    // now draw those suckas!\n    gl.drawElements(gl.TRIANGLES, size * 6, gl.UNSIGNED_SHORT, startIndex * 6 * 2);\n\n    // increment the draw count\n    this.renderer.drawCount++;\n};\n\n/**\n * Starts a new sprite batch.\n *\n */\nSpriteRenderer.prototype.start = function ()\n{\n    var gl = this.renderer.gl;\n\n    // bind the main texture\n\n\n    // bind the buffers\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    // this is the same for each shader?\n    var stride =  this.vertByteSize;\n    gl.vertexAttribPointer(this.shader.attributes.aVertexPosition, 2, gl.FLOAT, false, stride, 0);\n    gl.vertexAttribPointer(this.shader.attributes.aTextureCoord, 2, gl.FLOAT, false, stride, 2 * 4);\n\n    // color attributes will be interpreted as unsigned bytes and normalized\n    gl.vertexAttribPointer(this.shader.attributes.aColor, 4, gl.UNSIGNED_BYTE, true, stride, 4 * 4);\n};\n\n/**\n * Destroys the SpriteBatch.\n *\n */\nSpriteRenderer.prototype.destroy = function ()\n{\n    this.renderer.gl.deleteBuffer(this.vertexBuffer);\n    this.renderer.gl.deleteBuffer(this.indexBuffer);\n\n    this.shader.destroy();\n\n    this.renderer = null;\n\n    this.vertices = null;\n    this.positions = null;\n    this.colors = null;\n    this.indices = null;\n\n    this.vertexBuffer = null;\n    this.indexBuffer = null;\n\n    this.sprites = null;\n    this.shader = null;\n};\n"]},"metadata":{},"sourceType":"script"}