{"ast":null,"code":"var CONST = require('../const'),\n    EventEmitter = require('eventemitter3'),\n    // Internal event used by composed emitter\nTICK = 'tick';\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * This class is composed around an EventEmitter object to add listeners\n * meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary,\n * e.g. When the ticker is started and the emitter has listeners.\n *\n * @class\n * @memberof PIXI.ticker\n */\n\n\nfunction Ticker() {\n  var _this = this;\n  /**\n   * Internal tick method bound to ticker instance.\n   * This is because in early 2015, Function.bind\n   * is still 60% slower in high performance scenarios.\n   * Also separating frame requests from update method\n   * so listeners may be called at any time and with\n   * any animation API, just invoke ticker.update(time).\n   *\n   * @private\n   */\n\n\n  this._tick = function _tick(time) {\n    _this._requestId = null;\n\n    if (_this.started) {\n      // Invoke listeners now\n      _this.update(time); // Listener side effects may have modified ticker state.\n\n\n      if (_this.started && _this._requestId === null && _this._emitter.listeners(TICK, true)) {\n        _this._requestId = requestAnimationFrame(_this._tick);\n      }\n    }\n  };\n  /**\n   * Internal emitter used to fire 'tick' event\n   * @private\n   */\n\n\n  this._emitter = new EventEmitter();\n  /**\n   * Internal current frame request ID\n   * @private\n   */\n\n  this._requestId = null;\n  /**\n   * Internal value managed by minFPS property setter and getter.\n   * This is the maximum allowed milliseconds between updates.\n   * @private\n   */\n\n  this._maxElapsedMS = 100;\n  /**\n   * Whether or not this ticker should invoke the method\n   * {@link PIXI.ticker.Ticker#start} automatically\n   * when a listener is added.\n   *\n   * @member {boolean}\n   * @default false\n   */\n\n  this.autoStart = false;\n  /**\n   * Scalar time value from last frame to this frame.\n   * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}\n   * and is scaled with {@link PIXI.ticker.Ticker#speed}.\n   * **Note:** The cap may be exceeded by scaling.\n   *\n   * @member {number}\n   * @default 1\n   */\n\n  this.deltaTime = 1;\n  /**\n   * Time elapsed in milliseconds from last frame to this frame.\n   * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}\n   * is based, this value is neither capped nor scaled.\n   * If the platform supports DOMHighResTimeStamp,\n   * this value will have a precision of 1 µs.\n   *\n   * @member {DOMHighResTimeStamp|number}\n   * @default 1 / TARGET_FPMS\n   */\n\n  this.elapsedMS = 1 / CONST.TARGET_FPMS; // default to target frame time\n\n  /**\n   * The last time {@link PIXI.ticker.Ticker#update} was invoked.\n   * This value is also reset internally outside of invoking\n   * update, but only when a new animation frame is requested.\n   * If the platform supports DOMHighResTimeStamp,\n   * this value will have a precision of 1 µs.\n   *\n   * @member {DOMHighResTimeStamp|number}\n   * @default 0\n   */\n\n  this.lastTime = 0;\n  /**\n   * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.\n   * @example\n   *     // Scales ticker.deltaTime to what would be\n   *     // the equivalent of approximately 120 FPS\n   *     ticker.speed = 2;\n   *\n   * @member {number}\n   * @default 1\n   */\n\n  this.speed = 1;\n  /**\n   * Whether or not this ticker has been started.\n   * `true` if {@link PIXI.ticker.Ticker#start} has been called.\n   * `false` if {@link PIXI.ticker.Ticker#stop} has been called.\n   * While `false`, this value may change to `true` in the\n   * event of {@link PIXI.ticker.Ticker#autoStart} being `true`\n   * and a listener is added.\n   *\n   * @member {boolean}\n   * @default false\n   */\n\n  this.started = false;\n}\n\nObject.defineProperties(Ticker.prototype, {\n  /**\n   * The frames per second at which this ticker is running.\n   * The default is approximately 60 in most modern browsers.\n   * **Note:** This does not factor in the value of\n   * {@link PIXI.ticker.Ticker#speed}, which is specific\n   * to scaling {@link PIXI.ticker.Ticker#deltaTime}.\n   *\n   * @member\n   * @memberof PIXI.ticker.Ticker#\n   * @readonly\n   */\n  FPS: {\n    get: function () {\n      return 1000 / this.elapsedMS;\n    }\n  },\n\n  /**\n   * Manages the maximum amount of milliseconds allowed to\n   * elapse between invoking {@link PIXI.ticker.Ticker#update}.\n   * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},\n   * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.\n   * When setting this property it is clamped to a value between\n   * `0` and `PIXI.TARGET_FPMS * 1000`.\n   *\n   * @member\n   * @memberof PIXI.ticker.Ticker#\n   * @default 10\n   */\n  minFPS: {\n    get: function () {\n      return 1000 / this._maxElapsedMS;\n    },\n    set: function (fps) {\n      // Clamp: 0 to TARGET_FPMS\n      var minFPMS = Math.min(Math.max(0, fps) / 1000, CONST.TARGET_FPMS);\n      this._maxElapsedMS = 1 / minFPMS;\n    }\n  }\n});\n/**\n * Conditionally requests a new animation frame.\n * If a frame has not already been requested, and if the internal\n * emitter has listeners, a new frame is requested.\n *\n * @private\n */\n\nTicker.prototype._requestIfNeeded = function _requestIfNeeded() {\n  if (this._requestId === null && this._emitter.listeners(TICK, true)) {\n    // ensure callbacks get correct delta\n    this.lastTime = performance.now();\n    this._requestId = requestAnimationFrame(this._tick);\n  }\n};\n/**\n * Conditionally cancels a pending animation frame.\n *\n * @private\n */\n\n\nTicker.prototype._cancelIfNeeded = function _cancelIfNeeded() {\n  if (this._requestId !== null) {\n    cancelAnimationFrame(this._requestId);\n    this._requestId = null;\n  }\n};\n/**\n * Conditionally requests a new animation frame.\n * If the ticker has been started it checks if a frame has not already\n * been requested, and if the internal emitter has listeners. If these\n * conditions are met, a new frame is requested. If the ticker has not\n * been started, but autoStart is `true`, then the ticker starts now,\n * and continues with the previous conditions to request a new frame.\n *\n * @private\n */\n\n\nTicker.prototype._startIfPossible = function _startIfPossible() {\n  if (this.started) {\n    this._requestIfNeeded();\n  } else if (this.autoStart) {\n    this.start();\n  }\n};\n/**\n * Calls {@link module:eventemitter3.EventEmitter#on} internally for the\n * internal 'tick' event. It checks if the emitter has listeners,\n * and if so it requests a new animation frame at this point.\n *\n * @param fn {Function} The listener function to be added for updates\n * @param [context] {Function} The listener context\n * @returns {PIXI.ticker.Ticker} this\n */\n\n\nTicker.prototype.add = function add(fn, context) {\n  this._emitter.on(TICK, fn, context);\n\n  this._startIfPossible();\n\n  return this;\n};\n/**\n * Calls {@link module:eventemitter3.EventEmitter#once} internally for the\n * internal 'tick' event. It checks if the emitter has listeners,\n * and if so it requests a new animation frame at this point.\n *\n * @param fn {Function} The listener function to be added for one update\n * @param [context] {Function} The listener context\n * @returns {PIXI.ticker.Ticker} this\n */\n\n\nTicker.prototype.addOnce = function addOnce(fn, context) {\n  this._emitter.once(TICK, fn, context);\n\n  this._startIfPossible();\n\n  return this;\n};\n/**\n * Calls {@link module:eventemitter3.EventEmitter#off} internally for 'tick' event.\n * It checks if the emitter has listeners for 'tick' event.\n * If it does, then it cancels the animation frame.\n *\n * @param [fn] {Function} The listener function to be removed\n * @param [context] {Function} The listener context to be removed\n * @returns {PIXI.ticker.Ticker} this\n */\n\n\nTicker.prototype.remove = function remove(fn, context) {\n  this._emitter.off(TICK, fn, context);\n\n  if (!this._emitter.listeners(TICK, true)) {\n    this._cancelIfNeeded();\n  }\n\n  return this;\n};\n/**\n * Starts the ticker. If the ticker has listeners\n * a new animation frame is requested at this point.\n */\n\n\nTicker.prototype.start = function start() {\n  if (!this.started) {\n    this.started = true;\n\n    this._requestIfNeeded();\n  }\n};\n/**\n * Stops the ticker. If the ticker has requested\n * an animation frame it is canceled at this point.\n */\n\n\nTicker.prototype.stop = function stop() {\n  if (this.started) {\n    this.started = false;\n\n    this._cancelIfNeeded();\n  }\n};\n/**\n * Triggers an update. An update entails setting the\n * current {@link PIXI.ticker.Ticker#elapsedMS},\n * the current {@link PIXI.ticker.Ticker#deltaTime},\n * invoking all listeners with current deltaTime,\n * and then finally setting {@link PIXI.ticker.Ticker#lastTime}\n * with the value of currentTime that was provided.\n * This method will be called automatically by animation\n * frame callbacks if the ticker instance has been started\n * and listeners are added.\n *\n * @param [currentTime=performance.now()] {DOMHighResTimeStamp|number} the current time of execution\n */\n\n\nTicker.prototype.update = function update(currentTime) {\n  var elapsedMS; // Allow calling update directly with default currentTime.\n\n  currentTime = currentTime || performance.now(); // Save uncapped elapsedMS for measurement\n\n  elapsedMS = this.elapsedMS = currentTime - this.lastTime; // cap the milliseconds elapsed used for deltaTime\n\n  if (elapsedMS > this._maxElapsedMS) {\n    elapsedMS = this._maxElapsedMS;\n  }\n\n  this.deltaTime = elapsedMS * CONST.TARGET_FPMS * this.speed; // Invoke listeners added to internal emitter\n\n  this._emitter.emit(TICK, this.deltaTime);\n\n  this.lastTime = currentTime;\n};\n\nmodule.exports = Ticker;","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/ticker/Ticker.js"],"names":["CONST","require","EventEmitter","TICK","Ticker","_this","_tick","time","_requestId","started","update","_emitter","listeners","requestAnimationFrame","_maxElapsedMS","autoStart","deltaTime","elapsedMS","TARGET_FPMS","lastTime","speed","Object","defineProperties","prototype","FPS","get","minFPS","set","fps","minFPMS","Math","min","max","_requestIfNeeded","performance","now","_cancelIfNeeded","cancelAnimationFrame","_startIfPossible","start","add","fn","context","on","addOnce","once","remove","off","stop","currentTime","emit","module","exports"],"mappings":"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","sourcesContent":["var CONST = require('../const'),\n    EventEmitter = require('eventemitter3'),\n    // Internal event used by composed emitter\n    TICK = 'tick';\n\n/**\n * A Ticker class that runs an update loop that other objects listen to.\n * This class is composed around an EventEmitter object to add listeners\n * meant for execution on the next requested animation frame.\n * Animation frames are requested only when necessary,\n * e.g. When the ticker is started and the emitter has listeners.\n *\n * @class\n * @memberof PIXI.ticker\n */\nfunction Ticker()\n{\n    var _this = this;\n    /**\n     * Internal tick method bound to ticker instance.\n     * This is because in early 2015, Function.bind\n     * is still 60% slower in high performance scenarios.\n     * Also separating frame requests from update method\n     * so listeners may be called at any time and with\n     * any animation API, just invoke ticker.update(time).\n     *\n     * @private\n     */\n    this._tick = function _tick(time) {\n\n        _this._requestId = null;\n\n        if (_this.started)\n        {\n            // Invoke listeners now\n            _this.update(time);\n            // Listener side effects may have modified ticker state.\n            if (_this.started && _this._requestId === null && _this._emitter.listeners(TICK, true))\n            {\n                _this._requestId = requestAnimationFrame(_this._tick);\n            }\n        }\n    };\n    /**\n     * Internal emitter used to fire 'tick' event\n     * @private\n     */\n    this._emitter = new EventEmitter();\n    /**\n     * Internal current frame request ID\n     * @private\n     */\n    this._requestId = null;\n    /**\n     * Internal value managed by minFPS property setter and getter.\n     * This is the maximum allowed milliseconds between updates.\n     * @private\n     */\n    this._maxElapsedMS = 100;\n\n    /**\n     * Whether or not this ticker should invoke the method\n     * {@link PIXI.ticker.Ticker#start} automatically\n     * when a listener is added.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.autoStart = false;\n\n    /**\n     * Scalar time value from last frame to this frame.\n     * This value is capped by setting {@link PIXI.ticker.Ticker#minFPS}\n     * and is scaled with {@link PIXI.ticker.Ticker#speed}.\n     * **Note:** The cap may be exceeded by scaling.\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.deltaTime = 1;\n\n    /**\n     * Time elapsed in milliseconds from last frame to this frame.\n     * Opposed to what the scalar {@link PIXI.ticker.Ticker#deltaTime}\n     * is based, this value is neither capped nor scaled.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     *\n     * @member {DOMHighResTimeStamp|number}\n     * @default 1 / TARGET_FPMS\n     */\n    this.elapsedMS = 1 / CONST.TARGET_FPMS; // default to target frame time\n\n    /**\n     * The last time {@link PIXI.ticker.Ticker#update} was invoked.\n     * This value is also reset internally outside of invoking\n     * update, but only when a new animation frame is requested.\n     * If the platform supports DOMHighResTimeStamp,\n     * this value will have a precision of 1 µs.\n     *\n     * @member {DOMHighResTimeStamp|number}\n     * @default 0\n     */\n    this.lastTime = 0;\n\n    /**\n     * Factor of current {@link PIXI.ticker.Ticker#deltaTime}.\n     * @example\n     *     // Scales ticker.deltaTime to what would be\n     *     // the equivalent of approximately 120 FPS\n     *     ticker.speed = 2;\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.speed = 1;\n\n    /**\n     * Whether or not this ticker has been started.\n     * `true` if {@link PIXI.ticker.Ticker#start} has been called.\n     * `false` if {@link PIXI.ticker.Ticker#stop} has been called.\n     * While `false`, this value may change to `true` in the\n     * event of {@link PIXI.ticker.Ticker#autoStart} being `true`\n     * and a listener is added.\n     *\n     * @member {boolean}\n     * @default false\n     */\n    this.started = false;\n}\n\nObject.defineProperties(Ticker.prototype, {\n    /**\n     * The frames per second at which this ticker is running.\n     * The default is approximately 60 in most modern browsers.\n     * **Note:** This does not factor in the value of\n     * {@link PIXI.ticker.Ticker#speed}, which is specific\n     * to scaling {@link PIXI.ticker.Ticker#deltaTime}.\n     *\n     * @member\n     * @memberof PIXI.ticker.Ticker#\n     * @readonly\n     */\n    FPS: {\n        get: function()\n        {\n            return 1000 / this.elapsedMS;\n        }\n    },\n\n    /**\n     * Manages the maximum amount of milliseconds allowed to\n     * elapse between invoking {@link PIXI.ticker.Ticker#update}.\n     * This value is used to cap {@link PIXI.ticker.Ticker#deltaTime},\n     * but does not effect the measured value of {@link PIXI.ticker.Ticker#FPS}.\n     * When setting this property it is clamped to a value between\n     * `0` and `PIXI.TARGET_FPMS * 1000`.\n     *\n     * @member\n     * @memberof PIXI.ticker.Ticker#\n     * @default 10\n     */\n    minFPS: {\n        get: function()\n        {\n            return 1000 / this._maxElapsedMS;\n        },\n        set: function(fps)\n        {\n            // Clamp: 0 to TARGET_FPMS\n            var minFPMS = Math.min(Math.max(0, fps) / 1000, CONST.TARGET_FPMS);\n            this._maxElapsedMS = 1 / minFPMS;\n        }\n    }\n});\n\n/**\n * Conditionally requests a new animation frame.\n * If a frame has not already been requested, and if the internal\n * emitter has listeners, a new frame is requested.\n *\n * @private\n */\nTicker.prototype._requestIfNeeded = function _requestIfNeeded()\n{\n    if (this._requestId === null && this._emitter.listeners(TICK, true))\n    {\n        // ensure callbacks get correct delta\n        this.lastTime = performance.now();\n        this._requestId = requestAnimationFrame(this._tick);\n    }\n};\n\n/**\n * Conditionally cancels a pending animation frame.\n *\n * @private\n */\nTicker.prototype._cancelIfNeeded = function _cancelIfNeeded()\n{\n    if (this._requestId !== null)\n    {\n        cancelAnimationFrame(this._requestId);\n        this._requestId = null;\n    }\n};\n\n/**\n * Conditionally requests a new animation frame.\n * If the ticker has been started it checks if a frame has not already\n * been requested, and if the internal emitter has listeners. If these\n * conditions are met, a new frame is requested. If the ticker has not\n * been started, but autoStart is `true`, then the ticker starts now,\n * and continues with the previous conditions to request a new frame.\n *\n * @private\n */\nTicker.prototype._startIfPossible = function _startIfPossible()\n{\n    if (this.started)\n    {\n        this._requestIfNeeded();\n    }\n    else if (this.autoStart)\n    {\n        this.start();\n    }\n};\n\n/**\n * Calls {@link module:eventemitter3.EventEmitter#on} internally for the\n * internal 'tick' event. It checks if the emitter has listeners,\n * and if so it requests a new animation frame at this point.\n *\n * @param fn {Function} The listener function to be added for updates\n * @param [context] {Function} The listener context\n * @returns {PIXI.ticker.Ticker} this\n */\nTicker.prototype.add = function add(fn, context)\n{\n    this._emitter.on(TICK, fn, context);\n\n    this._startIfPossible();\n\n    return this;\n};\n\n/**\n * Calls {@link module:eventemitter3.EventEmitter#once} internally for the\n * internal 'tick' event. It checks if the emitter has listeners,\n * and if so it requests a new animation frame at this point.\n *\n * @param fn {Function} The listener function to be added for one update\n * @param [context] {Function} The listener context\n * @returns {PIXI.ticker.Ticker} this\n */\nTicker.prototype.addOnce = function addOnce(fn, context)\n{\n    this._emitter.once(TICK, fn, context);\n\n    this._startIfPossible();\n\n    return this;\n};\n\n/**\n * Calls {@link module:eventemitter3.EventEmitter#off} internally for 'tick' event.\n * It checks if the emitter has listeners for 'tick' event.\n * If it does, then it cancels the animation frame.\n *\n * @param [fn] {Function} The listener function to be removed\n * @param [context] {Function} The listener context to be removed\n * @returns {PIXI.ticker.Ticker} this\n */\nTicker.prototype.remove = function remove(fn, context)\n{\n    this._emitter.off(TICK, fn, context);\n\n    if (!this._emitter.listeners(TICK, true))\n    {\n        this._cancelIfNeeded();\n    }\n\n    return this;\n};\n\n/**\n * Starts the ticker. If the ticker has listeners\n * a new animation frame is requested at this point.\n */\nTicker.prototype.start = function start()\n{\n    if (!this.started)\n    {\n        this.started = true;\n        this._requestIfNeeded();\n    }\n};\n\n/**\n * Stops the ticker. If the ticker has requested\n * an animation frame it is canceled at this point.\n */\nTicker.prototype.stop = function stop()\n{\n    if (this.started)\n    {\n        this.started = false;\n        this._cancelIfNeeded();\n    }\n};\n\n/**\n * Triggers an update. An update entails setting the\n * current {@link PIXI.ticker.Ticker#elapsedMS},\n * the current {@link PIXI.ticker.Ticker#deltaTime},\n * invoking all listeners with current deltaTime,\n * and then finally setting {@link PIXI.ticker.Ticker#lastTime}\n * with the value of currentTime that was provided.\n * This method will be called automatically by animation\n * frame callbacks if the ticker instance has been started\n * and listeners are added.\n *\n * @param [currentTime=performance.now()] {DOMHighResTimeStamp|number} the current time of execution\n */\nTicker.prototype.update = function update(currentTime)\n{\n    var elapsedMS;\n\n    // Allow calling update directly with default currentTime.\n    currentTime = currentTime || performance.now();\n    // Save uncapped elapsedMS for measurement\n    elapsedMS = this.elapsedMS = currentTime - this.lastTime;\n\n    // cap the milliseconds elapsed used for deltaTime\n    if (elapsedMS > this._maxElapsedMS)\n    {\n        elapsedMS = this._maxElapsedMS;\n    }\n\n    this.deltaTime = elapsedMS * CONST.TARGET_FPMS * this.speed;\n\n    // Invoke listeners added to internal emitter\n    this._emitter.emit(TICK, this.deltaTime);\n\n    this.lastTime = currentTime;\n};\n\nmodule.exports = Ticker;\n"]},"metadata":{},"sourceType":"script"}