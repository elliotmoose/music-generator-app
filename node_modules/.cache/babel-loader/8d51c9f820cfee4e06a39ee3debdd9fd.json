{"ast":null,"code":"import _regeneratorRuntime from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\n\nexport var UserMedia = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(UserMedia, _ToneAudioNode);\n\n  var _super = _createSuper(UserMedia);\n\n  function UserMedia() {\n    var _this;\n\n    _classCallCheck(this, UserMedia);\n\n    _this = _super.call(this, optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n    _this.name = \"UserMedia\";\n    var options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_assertThisInitialized(_this), \"volume\");\n    _this.mute = options.mute;\n    return _this;\n  }\n\n  _createClass(UserMedia, [{\n    key: \"open\",\n\n    /**\n     * Open the media stream. If a string is passed in, it is assumed\n     * to be the label or id of the stream, if a number is passed in,\n     * it is the input number of the stream.\n     * @param  labelOrId The label or id of the audio input media device.\n     *                   With no argument, the default stream is opened.\n     * @return The promise is resolved when the stream is open.\n     */\n    value: function open(labelOrId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var devices, constraints, stream, mediaStreamNode;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                assert(UserMedia.supported, \"UserMedia is not supported\"); // close the previous stream\n\n                if (this.state === \"started\") {\n                  this.close();\n                }\n\n                _context.next = 4;\n                return UserMedia.enumerateDevices();\n\n              case 4:\n                devices = _context.sent;\n\n                if (isNumber(labelOrId)) {\n                  this._device = devices[labelOrId];\n                } else {\n                  this._device = devices.find(function (device) {\n                    return device.label === labelOrId || device.deviceId === labelOrId;\n                  }); // didn't find a matching device\n\n                  if (!this._device && devices.length > 0) {\n                    this._device = devices[0];\n                  }\n\n                  assert(isDefined(this._device), \"No matching device \".concat(labelOrId));\n                } // do getUserMedia\n\n\n                constraints = {\n                  audio: {\n                    echoCancellation: false,\n                    sampleRate: this.context.sampleRate,\n                    noiseSuppression: false,\n                    mozNoiseSuppression: false\n                  }\n                };\n\n                if (this._device) {\n                  // @ts-ignore\n                  constraints.audio.deviceId = this._device.deviceId;\n                }\n\n                _context.next = 10;\n                return navigator.mediaDevices.getUserMedia(constraints);\n\n              case 10:\n                stream = _context.sent;\n\n                // start a new source only if the previous one is closed\n                if (!this._stream) {\n                  this._stream = stream; // Wrap a MediaStreamSourceNode around the live input stream.\n\n                  mediaStreamNode = this.context.createMediaStreamSource(stream); // Connect the MediaStreamSourceNode to a gate gain node\n\n                  connect(mediaStreamNode, this.output);\n                  this._mediaStream = mediaStreamNode;\n                }\n\n                return _context.abrupt(\"return\", this);\n\n              case 13:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Close the media stream\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._stream && this._mediaStream) {\n        this._stream.getAudioTracks().forEach(function (track) {\n          track.stop();\n        });\n\n        this._stream = undefined; // remove the old media stream\n\n        this._mediaStream.disconnect();\n\n        this._mediaStream = undefined;\n      }\n\n      this._device = undefined;\n      return this;\n    }\n    /**\n     * Returns a promise which resolves with the list of audio input devices available.\n     * @return The promise that is resolved with the devices\n     * @example\n     * Tone.UserMedia.enumerateDevices().then((devices) => {\n     * \t// print the device labels\n     * \tconsole.log(devices.map(device => device.label));\n     * });\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(UserMedia.prototype), \"dispose\", this).call(this);\n\n      this.close();\n\n      this._volume.dispose();\n\n      this.volume.dispose();\n      return this;\n    }\n    /**\n     * If getUserMedia is supported by the browser.\n     */\n\n  }, {\n    key: \"state\",\n\n    /**\n     * Returns the playback state of the source, \"started\" when the microphone is open\n     * and \"stopped\" when the mic is closed.\n     */\n    get: function get() {\n      return this._stream && this._stream.active ? \"started\" : \"stopped\";\n    }\n    /**\n     * Returns an identifier for the represented device that is\n     * persisted across sessions. It is un-guessable by other applications and\n     * unique to the origin of the calling application. It is reset when the\n     * user clears cookies (for Private Browsing, a different identifier is\n     * used that is not persisted across sessions). Returns undefined when the\n     * device is not open.\n     */\n\n  }, {\n    key: \"deviceId\",\n    get: function get() {\n      if (this._device) {\n        return this._device.deviceId;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a group identifier. Two devices have the\n     * same group identifier if they belong to the same physical device.\n     * Returns null  when the device is not open.\n     */\n\n  }, {\n    key: \"groupId\",\n    get: function get() {\n      if (this._device) {\n        return this._device.groupId;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a label describing this device (for example \"Built-in Microphone\").\n     * Returns undefined when the device is not open or label is not available\n     * because of permissions.\n     */\n\n  }, {\n    key: \"label\",\n    get: function get() {\n      if (this._device) {\n        return this._device.label;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const mic = new Tone.UserMedia();\n     * mic.open().then(() => {\n     * \t// promise resolves when input is available\n     * });\n     * // mute the output\n     * mic.mute = true;\n     */\n\n  }, {\n    key: \"mute\",\n    get: function get() {\n      return this._volume.mute;\n    },\n    set: function set(mute) {\n      this._volume.mute = mute;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        mute: false,\n        volume: 0\n      });\n    }\n  }, {\n    key: \"enumerateDevices\",\n    value: function enumerateDevices() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var allDevices;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return navigator.mediaDevices.enumerateDevices();\n\n              case 2:\n                allDevices = _context2.sent;\n                return _context2.abrupt(\"return\", allDevices.filter(function (device) {\n                  return device.kind === \"audioinput\";\n                }));\n\n              case 4:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n    }\n  }, {\n    key: \"supported\",\n    get: function get() {\n      return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);\n    }\n  }]);\n\n  return UserMedia;\n}(ToneAudioNode);","map":{"version":3,"sources":["../../../Tone/source/UserMedia.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\nexport class UserMedia extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n        this.name = \"UserMedia\";\n        const options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n        this._volume = this.output = new Volume({\n            context: this.context,\n            volume: options.volume,\n        });\n        this.volume = this._volume.volume;\n        readOnly(this, \"volume\");\n        this.mute = options.mute;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            volume: 0\n        });\n    }\n    /**\n     * Open the media stream. If a string is passed in, it is assumed\n     * to be the label or id of the stream, if a number is passed in,\n     * it is the input number of the stream.\n     * @param  labelOrId The label or id of the audio input media device.\n     *                   With no argument, the default stream is opened.\n     * @return The promise is resolved when the stream is open.\n     */\n    open(labelOrId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            assert(UserMedia.supported, \"UserMedia is not supported\");\n            // close the previous stream\n            if (this.state === \"started\") {\n                this.close();\n            }\n            const devices = yield UserMedia.enumerateDevices();\n            if (isNumber(labelOrId)) {\n                this._device = devices[labelOrId];\n            }\n            else {\n                this._device = devices.find((device) => {\n                    return device.label === labelOrId || device.deviceId === labelOrId;\n                });\n                // didn't find a matching device\n                if (!this._device && devices.length > 0) {\n                    this._device = devices[0];\n                }\n                assert(isDefined(this._device), `No matching device ${labelOrId}`);\n            }\n            // do getUserMedia\n            const constraints = {\n                audio: {\n                    echoCancellation: false,\n                    sampleRate: this.context.sampleRate,\n                    noiseSuppression: false,\n                    mozNoiseSuppression: false,\n                }\n            };\n            if (this._device) {\n                // @ts-ignore\n                constraints.audio.deviceId = this._device.deviceId;\n            }\n            const stream = yield navigator.mediaDevices.getUserMedia(constraints);\n            // start a new source only if the previous one is closed\n            if (!this._stream) {\n                this._stream = stream;\n                // Wrap a MediaStreamSourceNode around the live input stream.\n                const mediaStreamNode = this.context.createMediaStreamSource(stream);\n                // Connect the MediaStreamSourceNode to a gate gain node\n                connect(mediaStreamNode, this.output);\n                this._mediaStream = mediaStreamNode;\n            }\n            return this;\n        });\n    }\n    /**\n     * Close the media stream\n     */\n    close() {\n        if (this._stream && this._mediaStream) {\n            this._stream.getAudioTracks().forEach((track) => {\n                track.stop();\n            });\n            this._stream = undefined;\n            // remove the old media stream\n            this._mediaStream.disconnect();\n            this._mediaStream = undefined;\n        }\n        this._device = undefined;\n        return this;\n    }\n    /**\n     * Returns a promise which resolves with the list of audio input devices available.\n     * @return The promise that is resolved with the devices\n     * @example\n     * Tone.UserMedia.enumerateDevices().then((devices) => {\n     * \t// print the device labels\n     * \tconsole.log(devices.map(device => device.label));\n     * });\n     */\n    static enumerateDevices() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const allDevices = yield navigator.mediaDevices.enumerateDevices();\n            return allDevices.filter(device => {\n                return device.kind === \"audioinput\";\n            });\n        });\n    }\n    /**\n     * Returns the playback state of the source, \"started\" when the microphone is open\n     * and \"stopped\" when the mic is closed.\n     */\n    get state() {\n        return this._stream && this._stream.active ? \"started\" : \"stopped\";\n    }\n    /**\n     * Returns an identifier for the represented device that is\n     * persisted across sessions. It is un-guessable by other applications and\n     * unique to the origin of the calling application. It is reset when the\n     * user clears cookies (for Private Browsing, a different identifier is\n     * used that is not persisted across sessions). Returns undefined when the\n     * device is not open.\n     */\n    get deviceId() {\n        if (this._device) {\n            return this._device.deviceId;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Returns a group identifier. Two devices have the\n     * same group identifier if they belong to the same physical device.\n     * Returns null  when the device is not open.\n     */\n    get groupId() {\n        if (this._device) {\n            return this._device.groupId;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Returns a label describing this device (for example \"Built-in Microphone\").\n     * Returns undefined when the device is not open or label is not available\n     * because of permissions.\n     */\n    get label() {\n        if (this._device) {\n            return this._device.label;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const mic = new Tone.UserMedia();\n     * mic.open().then(() => {\n     * \t// promise resolves when input is available\n     * });\n     * // mute the output\n     * mic.mute = true;\n     */\n    get mute() {\n        return this._volume.mute;\n    }\n    set mute(mute) {\n        this._volume.mute = mute;\n    }\n    dispose() {\n        super.dispose();\n        this.close();\n        this._volume.dispose();\n        this.volume.dispose();\n        return this;\n    }\n    /**\n     * If getUserMedia is supported by the browser.\n     */\n    static get supported() {\n        return isDefined(navigator.mediaDevices) &&\n            isDefined(navigator.mediaDevices.getUserMedia);\n    }\n}\n//# sourceMappingURL=UserMedia.js.map"]},"metadata":{},"sourceType":"module"}