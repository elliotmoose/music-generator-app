{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass } from \"./TimeBase\";\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\n\nexport var TimeClass = /*#__PURE__*/function (_TimeBaseClass) {\n  _inherits(TimeClass, _TimeBaseClass);\n\n  var _super = _createSuper(TimeClass);\n\n  function TimeClass() {\n    var _this;\n\n    _classCallCheck(this, TimeClass);\n\n    _this = _super.apply(this, arguments);\n    _this.name = \"TimeClass\";\n    return _this;\n  }\n\n  _createClass(TimeClass, [{\n    key: \"_getExpressions\",\n    value: function _getExpressions() {\n      var _this2 = this;\n\n      return Object.assign(_get(_getPrototypeOf(TimeClass.prototype), \"_getExpressions\", this).call(this), {\n        now: {\n          method: function method(capture) {\n            return _this2._now() + new _this2.constructor(_this2.context, capture).valueOf();\n          },\n          regexp: /^\\+(.+)/\n        },\n        quantize: {\n          method: function method(capture) {\n            var quantTo = new TimeClass(_this2.context, capture).valueOf();\n            return _this2._secondsToUnits(_this2.context.transport.nextSubdivision(quantTo));\n          },\n          regexp: /^@(.+)/\n        }\n      });\n    }\n    /**\n     * Quantize the time by the given subdivision. Optionally add a\n     * percentage which will move the time value towards the ideal\n     * quantized value by that percentage.\n     * @param  subdiv    The subdivision to quantize to\n     * @param  percent  Move the time value towards the quantized value by a percentage.\n     * @example\n     * Tone.Time(21).quantize(2); // returns 22\n     * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n     */\n\n  }, {\n    key: \"quantize\",\n    value: function quantize(subdiv) {\n      var percent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var subdivision = new this.constructor(this.context, subdiv).valueOf();\n      var value = this.valueOf();\n      var multiple = Math.round(value / subdivision);\n      var ideal = multiple * subdivision;\n      var diff = ideal - value;\n      return value + diff * percent;\n    } //-------------------------------------\n    // CONVERSIONS\n    //-------------------------------------\n\n    /**\n     * Convert a Time to Notation. The notation values are will be the\n     * closest representation between 1m to 128th note.\n     * @return {Notation}\n     * @example\n     * // if the Transport is at 120bpm:\n     * Tone.Time(2).toNotation(); // returns \"1m\"\n     */\n\n  }, {\n    key: \"toNotation\",\n    value: function toNotation() {\n      var _this3 = this;\n\n      var time = this.toSeconds();\n      var testNotations = [\"1m\"];\n\n      for (var power = 1; power < 9; power++) {\n        var subdiv = Math.pow(2, power);\n        testNotations.push(subdiv + \"n.\");\n        testNotations.push(subdiv + \"n\");\n        testNotations.push(subdiv + \"t\");\n      }\n\n      testNotations.push(\"0\"); // find the closets notation representation\n\n      var closest = testNotations[0];\n      var closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n      testNotations.forEach(function (notation) {\n        var notationSeconds = new TimeClass(_this3.context, notation).toSeconds();\n\n        if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n          closest = notation;\n          closestSeconds = notationSeconds;\n        }\n      });\n      return closest;\n    }\n    /**\n     * Return the time encoded as Bars:Beats:Sixteenths.\n     */\n\n  }, {\n    key: \"toBarsBeatsSixteenths\",\n    value: function toBarsBeatsSixteenths() {\n      var quarterTime = this._beatsToUnits(1);\n\n      var quarters = this.valueOf() / quarterTime;\n      quarters = parseFloat(quarters.toFixed(4));\n      var measures = Math.floor(quarters / this._getTimeSignature());\n      var sixteenths = quarters % 1 * 4;\n      quarters = Math.floor(quarters) % this._getTimeSignature();\n      var sixteenthString = sixteenths.toString();\n\n      if (sixteenthString.length > 3) {\n        // the additional parseFloat removes insignificant trailing zeroes\n        sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n      }\n\n      var progress = [measures, quarters, sixteenths];\n      return progress.join(\":\");\n    }\n    /**\n     * Return the time in ticks.\n     */\n\n  }, {\n    key: \"toTicks\",\n    value: function toTicks() {\n      var quarterTime = this._beatsToUnits(1);\n\n      var quarters = this.valueOf() / quarterTime;\n      return Math.round(quarters * this._getPPQ());\n    }\n    /**\n     * Return the time in seconds.\n     */\n\n  }, {\n    key: \"toSeconds\",\n    value: function toSeconds() {\n      return this.valueOf();\n    }\n    /**\n     * Return the value as a midi note.\n     */\n\n  }, {\n    key: \"toMidi\",\n    value: function toMidi() {\n      return ftom(this.toFrequency());\n    }\n  }, {\n    key: \"_now\",\n    value: function _now() {\n      return this.context.now();\n    }\n  }]);\n\n  return TimeClass;\n}(TimeBaseClass);\n/**\n * Create a TimeClass from a time string or number. The time is computed against the\n * global Tone.Context. To use a specific context, use [[TimeClass]]\n * @param value A value which represents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n * @example\n * const time = Tone.Time(\"4n\").toSeconds();\n * console.log(time);\n * @example\n * const note = Tone.Time(1).toNotation();\n * console.log(note);\n * @example\n * const freq = Tone.Time(0.5).toFrequency();\n * console.log(freq);\n */\n\nexport function Time(value, units) {\n  return new TimeClass(getContext(), value, units);\n}","map":{"version":3,"sources":["../../../../Tone/core/type/Time.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass } from \"./TimeBase\";\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\nexport class TimeClass extends TimeBaseClass {\n    constructor() {\n        super(...arguments);\n        this.name = \"TimeClass\";\n    }\n    _getExpressions() {\n        return Object.assign(super._getExpressions(), {\n            now: {\n                method: (capture) => {\n                    return this._now() + new this.constructor(this.context, capture).valueOf();\n                },\n                regexp: /^\\+(.+)/,\n            },\n            quantize: {\n                method: (capture) => {\n                    const quantTo = new TimeClass(this.context, capture).valueOf();\n                    return this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n                },\n                regexp: /^@(.+)/,\n            },\n        });\n    }\n    /**\n     * Quantize the time by the given subdivision. Optionally add a\n     * percentage which will move the time value towards the ideal\n     * quantized value by that percentage.\n     * @param  subdiv    The subdivision to quantize to\n     * @param  percent  Move the time value towards the quantized value by a percentage.\n     * @example\n     * Tone.Time(21).quantize(2); // returns 22\n     * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n     */\n    quantize(subdiv, percent = 1) {\n        const subdivision = new this.constructor(this.context, subdiv).valueOf();\n        const value = this.valueOf();\n        const multiple = Math.round(value / subdivision);\n        const ideal = multiple * subdivision;\n        const diff = ideal - value;\n        return value + diff * percent;\n    }\n    //-------------------------------------\n    // CONVERSIONS\n    //-------------------------------------\n    /**\n     * Convert a Time to Notation. The notation values are will be the\n     * closest representation between 1m to 128th note.\n     * @return {Notation}\n     * @example\n     * // if the Transport is at 120bpm:\n     * Tone.Time(2).toNotation(); // returns \"1m\"\n     */\n    toNotation() {\n        const time = this.toSeconds();\n        const testNotations = [\"1m\"];\n        for (let power = 1; power < 9; power++) {\n            const subdiv = Math.pow(2, power);\n            testNotations.push(subdiv + \"n.\");\n            testNotations.push(subdiv + \"n\");\n            testNotations.push(subdiv + \"t\");\n        }\n        testNotations.push(\"0\");\n        // find the closets notation representation\n        let closest = testNotations[0];\n        let closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n        testNotations.forEach(notation => {\n            const notationSeconds = new TimeClass(this.context, notation).toSeconds();\n            if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n                closest = notation;\n                closestSeconds = notationSeconds;\n            }\n        });\n        return closest;\n    }\n    /**\n     * Return the time encoded as Bars:Beats:Sixteenths.\n     */\n    toBarsBeatsSixteenths() {\n        const quarterTime = this._beatsToUnits(1);\n        let quarters = this.valueOf() / quarterTime;\n        quarters = parseFloat(quarters.toFixed(4));\n        const measures = Math.floor(quarters / this._getTimeSignature());\n        let sixteenths = (quarters % 1) * 4;\n        quarters = Math.floor(quarters) % this._getTimeSignature();\n        const sixteenthString = sixteenths.toString();\n        if (sixteenthString.length > 3) {\n            // the additional parseFloat removes insignificant trailing zeroes\n            sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n        }\n        const progress = [measures, quarters, sixteenths];\n        return progress.join(\":\");\n    }\n    /**\n     * Return the time in ticks.\n     */\n    toTicks() {\n        const quarterTime = this._beatsToUnits(1);\n        const quarters = this.valueOf() / quarterTime;\n        return Math.round(quarters * this._getPPQ());\n    }\n    /**\n     * Return the time in seconds.\n     */\n    toSeconds() {\n        return this.valueOf();\n    }\n    /**\n     * Return the value as a midi note.\n     */\n    toMidi() {\n        return ftom(this.toFrequency());\n    }\n    _now() {\n        return this.context.now();\n    }\n}\n/**\n * Create a TimeClass from a time string or number. The time is computed against the\n * global Tone.Context. To use a specific context, use [[TimeClass]]\n * @param value A value which represents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n * @example\n * const time = Tone.Time(\"4n\").toSeconds();\n * console.log(time);\n * @example\n * const note = Tone.Time(1).toNotation();\n * console.log(note);\n * @example\n * const freq = Tone.Time(0.5).toFrequency();\n * console.log(freq);\n */\nexport function Time(value, units) {\n    return new TimeClass(getContext(), value, units);\n}\n//# sourceMappingURL=Time.js.map"]},"metadata":{},"sourceType":"module"}