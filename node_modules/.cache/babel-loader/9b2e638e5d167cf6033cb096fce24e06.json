{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase } from \"./MeterBase\";\nimport { assert } from \"../../core/util/Debug\";\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\n\nexport var FFT = /*#__PURE__*/function (_MeterBase) {\n  _inherits(FFT, _MeterBase);\n\n  var _super = _createSuper(FFT);\n\n  function FFT() {\n    var _this;\n\n    _classCallCheck(this, FFT);\n\n    _this = _super.call(this, optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]));\n    _this.name = \"FFT\";\n    var options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n    _this.normalRange = options.normalRange;\n    _this._analyser.type = \"fft\";\n    _this.size = options.size;\n    return _this;\n  }\n\n  _createClass(FFT, [{\n    key: \"getValue\",\n\n    /**\n     * Gets the current frequency data from the connected audio source.\n     * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n     */\n    value: function getValue() {\n      var _this2 = this;\n\n      var values = this._analyser.getValue();\n\n      return values.map(function (v) {\n        return _this2.normalRange ? dbToGain(v) : v;\n      });\n    }\n    /**\n     * The size of analysis. This must be a power of two in the range 16 to 16384.\n     * Determines the size of the array returned by [[getValue]] (i.e. the number of\n     * frequency bins). Large FFT sizes may be costly to compute.\n     */\n\n  }, {\n    key: \"getFrequencyOfIndex\",\n\n    /**\n     * Returns the frequency value in hertz of each of the indices of the FFT's [[getValue]] response.\n     * @example\n     * const fft = new Tone.FFT(32);\n     * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));\n     */\n    value: function getFrequencyOfIndex(index) {\n      assert(0 <= index && index < this.size, \"index must be greater than or equal to 0 and less than \".concat(this.size));\n      return index * this.context.sampleRate / (this.size * 2);\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._analyser.size;\n    },\n    set: function set(size) {\n      this._analyser.size = size;\n    }\n    /**\n     * 0 represents no time averaging with the last analysis frame.\n     */\n\n  }, {\n    key: \"smoothing\",\n    get: function get() {\n      return this._analyser.smoothing;\n    },\n    set: function set(val) {\n      this._analyser.smoothing = val;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        normalRange: false,\n        size: 1024,\n        smoothing: 0.8\n      });\n    }\n  }]);\n\n  return FFT;\n}(MeterBase);","map":{"version":3,"sources":["../../../../Tone/component/analysis/FFT.ts"],"names":[],"mappings":";;;;AAAA,SAAS,aAAT,QAA8B,kCAA9B;AACA,SAAS,QAAT,QAAyB,6BAAzB;AAEA,SAAS,oBAAT,QAAqC,0BAArC;AACA,SAAS,SAAT,QAA4C,aAA5C;AACA,SAAS,MAAT,QAAuB,uBAAvB;AAQA;;;AAGG;;AACH,WAAa,GAAb;AAAA;;AAAA;;AAgBC,iBAAA;AAAA;;AAAA;;AACC,8BAAM,oBAAoB,CAAC,GAAG,CAAC,WAAJ,EAAD,EAAoB,SAApB,EAA+B,CAAC,MAAD,CAA/B,CAA1B;AAfQ,UAAA,IAAA,GAAe,KAAf;AAgBR,QAAM,OAAO,GAAG,oBAAoB,CAAC,GAAG,CAAC,WAAJ,EAAD,EAAoB,SAApB,EAA+B,CAAC,MAAD,CAA/B,CAApC;AAEA,UAAK,WAAL,GAAmB,OAAO,CAAC,WAA3B;AACA,UAAK,SAAL,CAAe,IAAf,GAAsB,KAAtB;AACA,UAAK,IAAL,GAAY,OAAO,CAAC,IAApB;AAND;AAOC;;AAvBF;AAAA;;AAiCC;;;AAGG;AApCJ,+BAqCS;AAAA;;AACP,UAAM,MAAM,GAAG,KAAK,SAAL,CAAe,QAAf,EAAf;;AACA,aAAO,MAAM,CAAC,GAAP,CAAW,UAAA,CAAC;AAAA,eAAI,MAAI,CAAC,WAAL,GAAmB,QAAQ,CAAC,CAAD,CAA3B,GAAiC,CAArC;AAAA,OAAZ,CAAP;AACA;AAED;;;;AAIG;;AA9CJ;AAAA;;AAgEC;;;;;AAKG;AArEJ,wCAsEqB,KAtErB,EAsEkC;AAChC,MAAA,MAAM,CAAC,KAAK,KAAL,IAAc,KAAK,GAAG,KAAK,IAA5B,mEAA4F,KAAK,IAAjG,EAAN;AACA,aAAO,KAAK,GAAG,KAAK,OAAL,CAAa,UAArB,IAAmC,KAAK,IAAL,GAAY,CAA/C,CAAP;AACA;AAzEF;AAAA;AAAA,wBA+CS;AACP,aAAO,KAAK,SAAL,CAAe,IAAtB;AACA,KAjDF;AAAA,sBAkDU,IAlDV,EAkDc;AACZ,WAAK,SAAL,CAAe,IAAf,GAAsB,IAAtB;AACA;AAED;;AAEG;;AAxDJ;AAAA;AAAA,wBAyDc;AACZ,aAAO,KAAK,SAAL,CAAe,SAAtB;AACA,KA3DF;AAAA,sBA4De,GA5Df,EA4DkB;AAChB,WAAK,SAAL,CAAe,SAAf,GAA2B,GAA3B;AACA;AA9DF;AAAA;AAAA,kCAyBmB;AACjB,aAAO,MAAM,CAAC,MAAP,CAAc,aAAa,CAAC,WAAd,EAAd,EAA2C;AACjD,QAAA,WAAW,EAAE,KADoC;AAEjD,QAAA,IAAI,EAAE,IAF2C;AAGjD,QAAA,SAAS,EAAE;AAHsC,OAA3C,CAAP;AAKA;AA/BF;;AAAA;AAAA,EAAyB,SAAzB","sourceRoot":"","sourcesContent":["import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase } from \"./MeterBase\";\nimport { assert } from \"../../core/util/Debug\";\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\nexport class FFT extends MeterBase {\n    constructor() {\n        super(optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]));\n        this.name = \"FFT\";\n        const options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n        this.normalRange = options.normalRange;\n        this._analyser.type = \"fft\";\n        this.size = options.size;\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            normalRange: false,\n            size: 1024,\n            smoothing: 0.8,\n        });\n    }\n    /**\n     * Gets the current frequency data from the connected audio source.\n     * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n     */\n    getValue() {\n        const values = this._analyser.getValue();\n        return values.map(v => this.normalRange ? dbToGain(v) : v);\n    }\n    /**\n     * The size of analysis. This must be a power of two in the range 16 to 16384.\n     * Determines the size of the array returned by [[getValue]] (i.e. the number of\n     * frequency bins). Large FFT sizes may be costly to compute.\n     */\n    get size() {\n        return this._analyser.size;\n    }\n    set size(size) {\n        this._analyser.size = size;\n    }\n    /**\n     * 0 represents no time averaging with the last analysis frame.\n     */\n    get smoothing() {\n        return this._analyser.smoothing;\n    }\n    set smoothing(val) {\n        this._analyser.smoothing = val;\n    }\n    /**\n     * Returns the frequency value in hertz of each of the indices of the FFT's [[getValue]] response.\n     * @example\n     * const fft = new Tone.FFT(32);\n     * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));\n     */\n    getFrequencyOfIndex(index) {\n        assert(0 <= index && index < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);\n        return index * this.context.sampleRate / (this.size * 2);\n    }\n}\n//# sourceMappingURL=FFT.js.map"]},"metadata":{},"sourceType":"module"}