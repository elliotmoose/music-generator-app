{"ast":null,"code":"'use strict';\n\nvar parseUri = require('parse-uri');\n\nvar async = require('./async');\n\nvar Resource = require('./Resource');\n\nvar EventEmitter = require('eventemitter3'); // some constants\n\n\nvar DEFAULT_CONCURRENCY = 10;\nvar MAX_PROGRESS = 100;\n/**\n * Manages the state and loading of multiple resources to load.\n *\n * @class\n * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.\n * @param {number} [concurrency=10] - The number of resources to load concurrently.\n */\n\nfunction Loader(baseUrl, concurrency) {\n  EventEmitter.call(this);\n  concurrency = concurrency || DEFAULT_CONCURRENCY;\n  /**\n   * The base url for all resources loaded by this loader.\n   *\n   * @member {string}\n   */\n\n  this.baseUrl = baseUrl || '';\n  /**\n   * The progress percent of the loader going through the queue.\n   *\n   * @member {number}\n   */\n\n  this.progress = 0;\n  /**\n   * Loading state of the loader, true if it is currently loading resources.\n   *\n   * @member {boolean}\n   */\n\n  this.loading = false;\n  /**\n   * The percentage of total progress that a single resource represents.\n   *\n   * @member {number}\n   */\n\n  this._progressChunk = 0;\n  /**\n   * The middleware to run before loading each resource.\n   *\n   * @member {function[]}\n   */\n\n  this._beforeMiddleware = [];\n  /**\n   * The middleware to run after loading each resource.\n   *\n   * @member {function[]}\n   */\n\n  this._afterMiddleware = [];\n  /**\n   * The `_loadResource` function bound with this object context.\n   *\n   * @private\n   * @member {function}\n   */\n\n  this._boundLoadResource = this._loadResource.bind(this);\n  /**\n   * The resource buffer that fills until `load` is called to start loading resources.\n   *\n   * @private\n   * @member {Resource[]}\n   */\n\n  this._buffer = [];\n  /**\n   * Used to track load completion.\n   *\n   * @private\n   * @member {number}\n   */\n\n  this._numToLoad = 0;\n  /**\n   * The resources waiting to be loaded.\n   *\n   * @private\n   * @member {Resource[]}\n   */\n\n  this._queue = async.queue(this._boundLoadResource, concurrency);\n  /**\n   * All the resources for this loader keyed by name.\n   *\n   * @member {object<string, Resource>}\n   */\n\n  this.resources = {};\n  /**\n   * Emitted once per loaded or errored resource.\n   *\n   * @event progress\n   * @memberof Loader#\n   */\n\n  /**\n   * Emitted once per errored resource.\n   *\n   * @event error\n   * @memberof Loader#\n   */\n\n  /**\n   * Emitted once per loaded resource.\n   *\n   * @event load\n   * @memberof Loader#\n   */\n\n  /**\n   * Emitted when the loader begins to process the queue.\n   *\n   * @event start\n   * @memberof Loader#\n   */\n\n  /**\n   * Emitted when the queued resources all load.\n   *\n   * @event complete\n   * @memberof Loader#\n   */\n}\n\nLoader.prototype = Object.create(EventEmitter.prototype);\nLoader.prototype.constructor = Loader;\nmodule.exports = Loader;\n/**\n * Adds a resource (or multiple resources) to the loader queue.\n *\n * This function can take a wide variety of different parameters. The only thing that is always\n * required the url to load. All the following will work:\n *\n * ```js\n * loader\n *     // normal param syntax\n *     .add('key', 'http://...', function () {})\n *     .add('http://...', function () {})\n *     .add('http://...')\n *\n *     // object syntax\n *     .add({\n *         name: 'key2',\n *         url: 'http://...'\n *     }, function () {})\n *     .add({\n *         url: 'http://...'\n *     }, function () {})\n *     .add({\n *         name: 'key3',\n *         url: 'http://...'\n *         onComplete: function () {}\n *     })\n *     .add({\n *         url: 'https://...',\n *         onComplete: function () {},\n *         crossOrigin: true\n *     })\n *\n *     // you can also pass an array of objects or urls or both\n *     .add([\n *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n *         { url: 'http://...', onComplete: function () {} },\n *         'http://...'\n *     ])\n *\n *     // and you can use both params and options\n *     .add('key', 'http://...', { crossOrigin: true }, function () {})\n *     .add('http://...', { crossOrigin: true }, function () {});\n * ```\n *\n * @alias enqueue\n * @param {string} [name] - The name of the resource to load, if not passed the url is used.\n * @param {string} [url] - The url for this resource, relative to the baseUrl of this loader.\n * @param {object} [options] - The options for the load.\n * @param {boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.\n * @param {Resource.XHR_LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?\n * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should the data being\n *      loaded be interpreted when using XHR?\n * @param {function} [cb] - Function to call when this specific resource completes loading.\n * @return {Loader} Returns itself.\n */\n\nLoader.prototype.add = Loader.prototype.enqueue = function (name, url, options, cb) {\n  // special case of an array of objects or urls\n  if (Array.isArray(name)) {\n    for (var i = 0; i < name.length; ++i) {\n      this.add(name[i]);\n    }\n\n    return this;\n  } // if an object is passed instead of params\n\n\n  if (typeof name === 'object') {\n    cb = url || name.callback || name.onComplete;\n    options = name;\n    url = name.url;\n    name = name.name || name.key || name.url;\n  } // case where no name is passed shift all args over by one.\n\n\n  if (typeof url !== 'string') {\n    cb = options;\n    options = url;\n    url = name;\n  } // now that we shifted make sure we have a proper url.\n\n\n  if (typeof url !== 'string') {\n    throw new Error('No url passed to add resource to loader.');\n  } // options are optional so people might pass a function and no options\n\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = null;\n  } // check if resource already exists.\n\n\n  if (this.resources[name]) {\n    throw new Error('Resource with name \"' + name + '\" already exists.');\n  } // add base url if this isn't an absolute url\n\n\n  url = this._prepareUrl(url); // create the store the resource\n\n  this.resources[name] = new Resource(name, url, options);\n\n  if (typeof cb === 'function') {\n    this.resources[name].once('afterMiddleware', cb);\n  }\n\n  this._numToLoad++; // if already loading add it to the worker queue\n\n  if (this._queue.started) {\n    this._queue.push(this.resources[name]);\n\n    this._progressChunk = (MAX_PROGRESS - this.progress) / (this._queue.length() + this._queue.running());\n  } // otherwise buffer it to be added to the queue later\n  else {\n      this._buffer.push(this.resources[name]);\n\n      this._progressChunk = MAX_PROGRESS / this._buffer.length;\n    }\n\n  return this;\n};\n/**\n * Sets up a middleware function that will run *before* the\n * resource is loaded.\n *\n * @alias pre\n * @method before\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\n\n\nLoader.prototype.before = Loader.prototype.pre = function (fn) {\n  this._beforeMiddleware.push(fn);\n\n  return this;\n};\n/**\n * Sets up a middleware function that will run *after* the\n * resource is loaded.\n *\n * @alias use\n * @method after\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\n\n\nLoader.prototype.after = Loader.prototype.use = function (fn) {\n  this._afterMiddleware.push(fn);\n\n  return this;\n};\n/**\n * Resets the queue of the loader to prepare for a new load.\n *\n * @return {Loader} Returns itself.\n */\n\n\nLoader.prototype.reset = function () {\n  // this.baseUrl = baseUrl || '';\n  this.progress = 0;\n  this.loading = false;\n  this._progressChunk = 0; // this._beforeMiddleware.length = 0;\n  // this._afterMiddleware.length = 0;\n\n  this._buffer.length = 0;\n  this._numToLoad = 0;\n\n  this._queue.kill();\n\n  this._queue.started = false; // abort all resource loads\n\n  for (var k in this.resources) {\n    var res = this.resources[k];\n    res.off('complete', this._onLoad, this);\n\n    if (res.isLoading) {\n      res.abort();\n    }\n  }\n\n  this.resources = {};\n  return this;\n};\n/**\n * Starts loading the queued resources.\n *\n * @fires start\n * @param {function} [cb] - Optional callback that will be bound to the `complete` event.\n * @return {Loader} Returns itself.\n */\n\n\nLoader.prototype.load = function (cb) {\n  // register complete callback if they pass one\n  if (typeof cb === 'function') {\n    this.once('complete', cb);\n  } // if the queue has already started we are done here\n\n\n  if (this._queue.started) {\n    return this;\n  } // notify of start\n\n\n  this.emit('start', this); // update loading state\n\n  this.loading = true; // start the internal queue\n\n  for (var i = 0; i < this._buffer.length; ++i) {\n    this._queue.push(this._buffer[i]);\n  } // empty the buffer\n\n\n  this._buffer.length = 0;\n  return this;\n};\n/**\n * Prepares a url for usage based on the configuration of this object\n *\n * @private\n * @param {string} url - The url to prepare.\n * @return {string} The prepared url.\n */\n\n\nLoader.prototype._prepareUrl = function (url) {\n  var parsedUrl = parseUri(url, {\n    strictMode: true\n  }); // absolute url, just use it as is.\n\n  if (parsedUrl.protocol || !parsedUrl.path || parsedUrl.path.indexOf('//') === 0) {\n    return url;\n  } // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n\n\n  if (this.baseUrl.length && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1 && url.charAt(0) !== '/') {\n    return this.baseUrl + '/' + url;\n  }\n\n  return this.baseUrl + url;\n};\n/**\n * Loads a single resource.\n *\n * @private\n * @param {Resource} resource - The resource to load.\n * @param {function} dequeue - The function to call when we need to dequeue this item.\n */\n\n\nLoader.prototype._loadResource = function (resource, dequeue) {\n  var self = this;\n  resource._dequeue = dequeue; // run before middleware\n\n  async.eachSeries(this._beforeMiddleware, function (fn, next) {\n    fn.call(self, resource, function () {\n      // if the before middleware marks the resource as complete,\n      // break and don't process any more before middleware\n      next(resource.isComplete ? {} : null);\n    });\n  }, function () {\n    // resource.on('progress', self.emit.bind(self, 'progress'));\n    if (resource.isComplete) {\n      self._onLoad(resource);\n    } else {\n      resource.once('complete', self._onLoad, self);\n      resource.load();\n    }\n  });\n};\n/**\n * Called once each resource has loaded.\n *\n * @fires complete\n * @private\n */\n\n\nLoader.prototype._onComplete = function () {\n  this.loading = false;\n  this.emit('complete', this, this.resources);\n};\n/**\n * Called each time a resources is loaded.\n *\n * @fires progress\n * @fires error\n * @fires load\n * @private\n * @param {Resource} resource - The resource that was loaded\n */\n\n\nLoader.prototype._onLoad = function (resource) {\n  var self = this; // run middleware, this *must* happen before dequeue so sub-assets get added properly\n\n  async.eachSeries(this._afterMiddleware, function (fn, next) {\n    fn.call(self, resource, next);\n  }, function () {\n    resource.emit('afterMiddleware', resource);\n    self._numToLoad--;\n    self.progress += self._progressChunk;\n    self.emit('progress', self, resource);\n\n    if (resource.error) {\n      self.emit('error', resource.error, self, resource);\n    } else {\n      self.emit('load', self, resource);\n    } // do completion check\n\n\n    if (self._numToLoad === 0) {\n      self.progress = 100;\n\n      self._onComplete();\n    }\n  }); // remove this resource from the async queue\n\n  resource._dequeue();\n};\n\nLoader.LOAD_TYPE = Resource.LOAD_TYPE;\nLoader.XHR_RESPONSE_TYPE = Resource.XHR_RESPONSE_TYPE;","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/resource-loader/src/Loader.js"],"names":["parseUri","require","async","Resource","EventEmitter","DEFAULT_CONCURRENCY","MAX_PROGRESS","Loader","baseUrl","concurrency","call","progress","loading","_progressChunk","_beforeMiddleware","_afterMiddleware","_boundLoadResource","_loadResource","bind","_buffer","_numToLoad","_queue","queue","resources","prototype","Object","create","constructor","module","exports","add","enqueue","name","url","options","cb","Array","isArray","i","length","callback","onComplete","key","Error","_prepareUrl","once","started","push","running","before","pre","fn","after","use","reset","kill","k","res","off","_onLoad","isLoading","abort","load","emit","parsedUrl","strictMode","protocol","path","indexOf","lastIndexOf","charAt","resource","dequeue","self","_dequeue","eachSeries","next","isComplete","_onComplete","error","LOAD_TYPE","XHR_RESPONSE_TYPE"],"mappings":"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","sourcesContent":["'use strict';\n\nvar parseUri        = require('parse-uri');\nvar async           = require('./async');\nvar Resource        = require('./Resource');\nvar EventEmitter    = require('eventemitter3');\n\n// some constants\nvar DEFAULT_CONCURRENCY = 10;\nvar MAX_PROGRESS = 100;\n\n/**\n * Manages the state and loading of multiple resources to load.\n *\n * @class\n * @param {string} [baseUrl=''] - The base url for all resources loaded by this loader.\n * @param {number} [concurrency=10] - The number of resources to load concurrently.\n */\nfunction Loader(baseUrl, concurrency) {\n    EventEmitter.call(this);\n\n    concurrency = concurrency || DEFAULT_CONCURRENCY;\n\n    /**\n     * The base url for all resources loaded by this loader.\n     *\n     * @member {string}\n     */\n    this.baseUrl = baseUrl || '';\n\n    /**\n     * The progress percent of the loader going through the queue.\n     *\n     * @member {number}\n     */\n    this.progress = 0;\n\n    /**\n     * Loading state of the loader, true if it is currently loading resources.\n     *\n     * @member {boolean}\n     */\n    this.loading = false;\n\n    /**\n     * The percentage of total progress that a single resource represents.\n     *\n     * @member {number}\n     */\n    this._progressChunk = 0;\n\n    /**\n     * The middleware to run before loading each resource.\n     *\n     * @member {function[]}\n     */\n    this._beforeMiddleware = [];\n\n    /**\n     * The middleware to run after loading each resource.\n     *\n     * @member {function[]}\n     */\n    this._afterMiddleware = [];\n\n    /**\n     * The `_loadResource` function bound with this object context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundLoadResource = this._loadResource.bind(this);\n\n    /**\n     * The resource buffer that fills until `load` is called to start loading resources.\n     *\n     * @private\n     * @member {Resource[]}\n     */\n    this._buffer = [];\n\n    /**\n     * Used to track load completion.\n     *\n     * @private\n     * @member {number}\n     */\n    this._numToLoad = 0;\n\n    /**\n     * The resources waiting to be loaded.\n     *\n     * @private\n     * @member {Resource[]}\n     */\n    this._queue = async.queue(this._boundLoadResource, concurrency);\n\n    /**\n     * All the resources for this loader keyed by name.\n     *\n     * @member {object<string, Resource>}\n     */\n    this.resources = {};\n\n    /**\n     * Emitted once per loaded or errored resource.\n     *\n     * @event progress\n     * @memberof Loader#\n     */\n\n    /**\n     * Emitted once per errored resource.\n     *\n     * @event error\n     * @memberof Loader#\n     */\n\n    /**\n     * Emitted once per loaded resource.\n     *\n     * @event load\n     * @memberof Loader#\n     */\n\n    /**\n     * Emitted when the loader begins to process the queue.\n     *\n     * @event start\n     * @memberof Loader#\n     */\n\n    /**\n     * Emitted when the queued resources all load.\n     *\n     * @event complete\n     * @memberof Loader#\n     */\n}\n\nLoader.prototype = Object.create(EventEmitter.prototype);\nLoader.prototype.constructor = Loader;\nmodule.exports = Loader;\n\n/**\n * Adds a resource (or multiple resources) to the loader queue.\n *\n * This function can take a wide variety of different parameters. The only thing that is always\n * required the url to load. All the following will work:\n *\n * ```js\n * loader\n *     // normal param syntax\n *     .add('key', 'http://...', function () {})\n *     .add('http://...', function () {})\n *     .add('http://...')\n *\n *     // object syntax\n *     .add({\n *         name: 'key2',\n *         url: 'http://...'\n *     }, function () {})\n *     .add({\n *         url: 'http://...'\n *     }, function () {})\n *     .add({\n *         name: 'key3',\n *         url: 'http://...'\n *         onComplete: function () {}\n *     })\n *     .add({\n *         url: 'https://...',\n *         onComplete: function () {},\n *         crossOrigin: true\n *     })\n *\n *     // you can also pass an array of objects or urls or both\n *     .add([\n *         { name: 'key4', url: 'http://...', onComplete: function () {} },\n *         { url: 'http://...', onComplete: function () {} },\n *         'http://...'\n *     ])\n *\n *     // and you can use both params and options\n *     .add('key', 'http://...', { crossOrigin: true }, function () {})\n *     .add('http://...', { crossOrigin: true }, function () {});\n * ```\n *\n * @alias enqueue\n * @param {string} [name] - The name of the resource to load, if not passed the url is used.\n * @param {string} [url] - The url for this resource, relative to the baseUrl of this loader.\n * @param {object} [options] - The options for the load.\n * @param {boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.\n * @param {Resource.XHR_LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?\n * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should the data being\n *      loaded be interpreted when using XHR?\n * @param {function} [cb] - Function to call when this specific resource completes loading.\n * @return {Loader} Returns itself.\n */\nLoader.prototype.add = Loader.prototype.enqueue = function (name, url, options, cb) {\n    // special case of an array of objects or urls\n    if (Array.isArray(name)) {\n        for (var i = 0; i < name.length; ++i) {\n            this.add(name[i]);\n        }\n\n        return this;\n    }\n\n    // if an object is passed instead of params\n    if (typeof name === 'object') {\n        cb = url || name.callback || name.onComplete;\n        options = name;\n        url = name.url;\n        name = name.name || name.key || name.url;\n    }\n\n    // case where no name is passed shift all args over by one.\n    if (typeof url !== 'string') {\n        cb = options;\n        options = url;\n        url = name;\n    }\n\n    // now that we shifted make sure we have a proper url.\n    if (typeof url !== 'string') {\n        throw new Error('No url passed to add resource to loader.');\n    }\n\n    // options are optional so people might pass a function and no options\n    if (typeof options === 'function') {\n        cb = options;\n        options = null;\n    }\n\n    // check if resource already exists.\n    if (this.resources[name]) {\n        throw new Error('Resource with name \"' + name + '\" already exists.');\n    }\n\n    // add base url if this isn't an absolute url\n    url = this._prepareUrl(url);\n\n    // create the store the resource\n    this.resources[name] = new Resource(name, url, options);\n\n    if (typeof cb === 'function') {\n        this.resources[name].once('afterMiddleware', cb);\n    }\n\n    this._numToLoad++;\n\n    // if already loading add it to the worker queue\n    if (this._queue.started) {\n        this._queue.push(this.resources[name]);\n        this._progressChunk = (MAX_PROGRESS - this.progress) / (this._queue.length() + this._queue.running());\n    }\n    // otherwise buffer it to be added to the queue later\n    else {\n        this._buffer.push(this.resources[name]);\n        this._progressChunk = MAX_PROGRESS / this._buffer.length;\n    }\n\n    return this;\n};\n\n/**\n * Sets up a middleware function that will run *before* the\n * resource is loaded.\n *\n * @alias pre\n * @method before\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\nLoader.prototype.before = Loader.prototype.pre = function (fn) {\n    this._beforeMiddleware.push(fn);\n\n    return this;\n};\n\n/**\n * Sets up a middleware function that will run *after* the\n * resource is loaded.\n *\n * @alias use\n * @method after\n * @param {function} fn - The middleware function to register.\n * @return {Loader} Returns itself.\n */\nLoader.prototype.after = Loader.prototype.use = function (fn) {\n    this._afterMiddleware.push(fn);\n\n    return this;\n};\n\n/**\n * Resets the queue of the loader to prepare for a new load.\n *\n * @return {Loader} Returns itself.\n */\nLoader.prototype.reset = function () {\n    // this.baseUrl = baseUrl || '';\n\n    this.progress = 0;\n\n    this.loading = false;\n\n    this._progressChunk = 0;\n\n    // this._beforeMiddleware.length = 0;\n    // this._afterMiddleware.length = 0;\n\n    this._buffer.length = 0;\n\n    this._numToLoad = 0;\n\n    this._queue.kill();\n    this._queue.started = false;\n\n    // abort all resource loads\n    for (var k in this.resources) {\n        var res = this.resources[k];\n\n        res.off('complete', this._onLoad, this);\n\n        if (res.isLoading) {\n            res.abort();\n        }\n    }\n\n    this.resources = {};\n\n    return this;\n};\n\n/**\n * Starts loading the queued resources.\n *\n * @fires start\n * @param {function} [cb] - Optional callback that will be bound to the `complete` event.\n * @return {Loader} Returns itself.\n */\nLoader.prototype.load = function (cb) {\n    // register complete callback if they pass one\n    if (typeof cb === 'function') {\n        this.once('complete', cb);\n    }\n\n    // if the queue has already started we are done here\n    if (this._queue.started) {\n        return this;\n    }\n\n    // notify of start\n    this.emit('start', this);\n\n    // update loading state\n    this.loading = true;\n\n    // start the internal queue\n    for (var i = 0; i < this._buffer.length; ++i) {\n        this._queue.push(this._buffer[i]);\n    }\n\n    // empty the buffer\n    this._buffer.length = 0;\n\n    return this;\n};\n\n/**\n * Prepares a url for usage based on the configuration of this object\n *\n * @private\n * @param {string} url - The url to prepare.\n * @return {string} The prepared url.\n */\nLoader.prototype._prepareUrl = function (url) {\n    var parsedUrl = parseUri(url, { strictMode: true });\n\n    // absolute url, just use it as is.\n    if (parsedUrl.protocol || !parsedUrl.path || parsedUrl.path.indexOf('//') === 0) {\n        return url;\n    }\n\n    // if baseUrl doesn't end in slash and url doesn't start with slash, then add a slash inbetween\n    if (this.baseUrl.length\n        && this.baseUrl.lastIndexOf('/') !== this.baseUrl.length - 1\n        && url.charAt(0) !== '/'\n    ) {\n        return this.baseUrl + '/' + url;\n    }\n\n    return this.baseUrl + url;\n};\n\n/**\n * Loads a single resource.\n *\n * @private\n * @param {Resource} resource - The resource to load.\n * @param {function} dequeue - The function to call when we need to dequeue this item.\n */\nLoader.prototype._loadResource = function (resource, dequeue) {\n    var self = this;\n\n    resource._dequeue = dequeue;\n\n    // run before middleware\n    async.eachSeries(\n        this._beforeMiddleware,\n        function (fn, next) {\n            fn.call(self, resource, function () {\n                // if the before middleware marks the resource as complete,\n                // break and don't process any more before middleware\n                next(resource.isComplete ? {} : null);\n            });\n        },\n        function () {\n            // resource.on('progress', self.emit.bind(self, 'progress'));\n\n            if (resource.isComplete) {\n                self._onLoad(resource);\n            }\n            else {\n                resource.once('complete', self._onLoad, self);\n                resource.load();\n            }\n        }\n    );\n};\n\n/**\n * Called once each resource has loaded.\n *\n * @fires complete\n * @private\n */\nLoader.prototype._onComplete = function () {\n    this.loading = false;\n\n    this.emit('complete', this, this.resources);\n};\n\n/**\n * Called each time a resources is loaded.\n *\n * @fires progress\n * @fires error\n * @fires load\n * @private\n * @param {Resource} resource - The resource that was loaded\n */\nLoader.prototype._onLoad = function (resource) {\n    var self = this;\n\n    // run middleware, this *must* happen before dequeue so sub-assets get added properly\n    async.eachSeries(\n        this._afterMiddleware,\n        function (fn, next) {\n            fn.call(self, resource, next);\n        },\n        function () {\n            resource.emit('afterMiddleware', resource);\n\n            self._numToLoad--;\n\n            self.progress += self._progressChunk;\n            self.emit('progress', self, resource);\n\n            if (resource.error) {\n                self.emit('error', resource.error, self, resource);\n            }\n            else {\n                self.emit('load', self, resource);\n            }\n\n            // do completion check\n            if (self._numToLoad === 0) {\n                self.progress = 100;\n                self._onComplete();\n            }\n        }\n    );\n\n    // remove this resource from the async queue\n    resource._dequeue();\n};\n\nLoader.LOAD_TYPE = Resource.LOAD_TYPE;\nLoader.XHR_RESPONSE_TYPE = Resource.XHR_RESPONSE_TYPE;\n"]},"metadata":{},"sourceType":"script"}