{"ast":null,"code":"var CanvasGraphics = require('./CanvasGraphics');\n/**\n * A set of functions used to handle masking.\n *\n * @class\n * @memberof PIXI\n */\n\n\nfunction CanvasMaskManager() {}\n\nCanvasMaskManager.prototype.constructor = CanvasMaskManager;\nmodule.exports = CanvasMaskManager;\n/**\n * This method adds it to the current stack of masks.\n *\n * @param maskData {object} the maskData that will be pushed\n * @param renderer {WebGLRenderer|CanvasRenderer} The renderer context to use.\n */\n\nCanvasMaskManager.prototype.pushMask = function (maskData, renderer) {\n  renderer.context.save();\n  var cacheAlpha = maskData.alpha;\n  var transform = maskData.worldTransform;\n  var resolution = renderer.resolution;\n  renderer.context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution); //TODO suport sprite alpha masks??\n  //lots of effort required. If demand is great enough..\n\n  if (!maskData.texture) {\n    CanvasGraphics.renderGraphicsMask(maskData, renderer.context);\n    renderer.context.clip();\n  }\n\n  maskData.worldAlpha = cacheAlpha;\n};\n/**\n * Restores the current drawing context to the state it was before the mask was applied.\n *\n * @param renderer {WebGLRenderer|CanvasRenderer} The renderer context to use.\n */\n\n\nCanvasMaskManager.prototype.popMask = function (renderer) {\n  renderer.context.restore();\n};\n\nCanvasMaskManager.prototype.destroy = function () {};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasMaskManager.js"],"names":["CanvasGraphics","require","CanvasMaskManager","prototype","constructor","module","exports","pushMask","maskData","renderer","context","save","cacheAlpha","alpha","transform","worldTransform","resolution","setTransform","a","b","c","d","tx","ty","texture","renderGraphicsMask","clip","worldAlpha","popMask","restore","destroy"],"mappings":"AAAA,IAAIA,cAAc,GAAGC,OAAO,CAAC,kBAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,iBAAT,GACA,CAAE;;AAEFA,iBAAiB,CAACC,SAAlB,CAA4BC,WAA5B,GAA0CF,iBAA1C;AACAG,MAAM,CAACC,OAAP,GAAiBJ,iBAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACAA,iBAAiB,CAACC,SAAlB,CAA4BI,QAA5B,GAAuC,UAAUC,QAAV,EAAoBC,QAApB,EACvC;AAEIA,EAAAA,QAAQ,CAACC,OAAT,CAAiBC,IAAjB;AAEA,MAAIC,UAAU,GAAGJ,QAAQ,CAACK,KAA1B;AACA,MAAIC,SAAS,GAAGN,QAAQ,CAACO,cAAzB;AACA,MAAIC,UAAU,GAAGP,QAAQ,CAACO,UAA1B;AAEAP,EAAAA,QAAQ,CAACC,OAAT,CAAiBO,YAAjB,CACIH,SAAS,CAACI,CAAV,GAAcF,UADlB,EAEIF,SAAS,CAACK,CAAV,GAAcH,UAFlB,EAGIF,SAAS,CAACM,CAAV,GAAcJ,UAHlB,EAIIF,SAAS,CAACO,CAAV,GAAcL,UAJlB,EAKIF,SAAS,CAACQ,EAAV,GAAeN,UALnB,EAMIF,SAAS,CAACS,EAAV,GAAeP,UANnB,EARJ,CAiBI;AACA;;AACA,MAAG,CAACR,QAAQ,CAACgB,OAAb,EACA;AACIxB,IAAAA,cAAc,CAACyB,kBAAf,CAAkCjB,QAAlC,EAA4CC,QAAQ,CAACC,OAArD;AACAD,IAAAA,QAAQ,CAACC,OAAT,CAAiBgB,IAAjB;AACH;;AAEDlB,EAAAA,QAAQ,CAACmB,UAAT,GAAsBf,UAAtB;AACH,CA3BD;AA6BA;AACA;AACA;AACA;AACA;;;AACAV,iBAAiB,CAACC,SAAlB,CAA4ByB,OAA5B,GAAsC,UAAUnB,QAAV,EACtC;AACIA,EAAAA,QAAQ,CAACC,OAAT,CAAiBmB,OAAjB;AACH,CAHD;;AAKA3B,iBAAiB,CAACC,SAAlB,CAA4B2B,OAA5B,GAAsC,YAAY,CAAE,CAApD","sourcesContent":["var CanvasGraphics = require('./CanvasGraphics');\n\n/**\n * A set of functions used to handle masking.\n *\n * @class\n * @memberof PIXI\n */\nfunction CanvasMaskManager()\n{}\n\nCanvasMaskManager.prototype.constructor = CanvasMaskManager;\nmodule.exports = CanvasMaskManager;\n\n/**\n * This method adds it to the current stack of masks.\n *\n * @param maskData {object} the maskData that will be pushed\n * @param renderer {WebGLRenderer|CanvasRenderer} The renderer context to use.\n */\nCanvasMaskManager.prototype.pushMask = function (maskData, renderer)\n{\n\n    renderer.context.save();\n\n    var cacheAlpha = maskData.alpha;\n    var transform = maskData.worldTransform;\n    var resolution = renderer.resolution;\n\n    renderer.context.setTransform(\n        transform.a * resolution,\n        transform.b * resolution,\n        transform.c * resolution,\n        transform.d * resolution,\n        transform.tx * resolution,\n        transform.ty * resolution\n    );\n\n    //TODO suport sprite alpha masks??\n    //lots of effort required. If demand is great enough..\n    if(!maskData.texture)\n    {\n        CanvasGraphics.renderGraphicsMask(maskData, renderer.context);\n        renderer.context.clip();\n    }\n\n    maskData.worldAlpha = cacheAlpha;\n};\n\n/**\n * Restores the current drawing context to the state it was before the mask was applied.\n *\n * @param renderer {WebGLRenderer|CanvasRenderer} The renderer context to use.\n */\nCanvasMaskManager.prototype.popMask = function (renderer)\n{\n    renderer.context.restore();\n};\n\nCanvasMaskManager.prototype.destroy = function () {};\n"]},"metadata":{},"sourceType":"script"}