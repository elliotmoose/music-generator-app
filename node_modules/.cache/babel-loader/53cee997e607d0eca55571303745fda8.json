{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Signal } from \"./Signal\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n/**\n * Adds the ability to synchronize the signal to the [[Transport]]\n */\n\nexport var SyncedSignal = /*#__PURE__*/function (_Signal) {\n  _inherits(SyncedSignal, _Signal);\n\n  var _super = _createSuper(SyncedSignal);\n\n  function SyncedSignal() {\n    var _this;\n\n    _classCallCheck(this, SyncedSignal);\n\n    _this = _super.call(this, optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n    _this.name = \"SyncedSignal\";\n    /**\n     * Don't override when something is connected to the input\n     */\n\n    _this.override = false;\n    var options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]);\n    _this._lastVal = options.value;\n    _this._synced = _this.context.transport.scheduleRepeat(_this._onTick.bind(_assertThisInitialized(_this)), \"1i\");\n    _this._syncedCallback = _this._anchorValue.bind(_assertThisInitialized(_this));\n\n    _this.context.transport.on(\"start\", _this._syncedCallback);\n\n    _this.context.transport.on(\"pause\", _this._syncedCallback);\n\n    _this.context.transport.on(\"stop\", _this._syncedCallback); // disconnect the constant source from the output and replace it with another one\n\n\n    _this._constantSource.disconnect();\n\n    _this._constantSource.stop(0); // create a new one\n\n\n    _this._constantSource = _this.output = new ToneConstantSource({\n      context: _this.context,\n      offset: options.value,\n      units: options.units\n    }).start(0);\n\n    _this.setValueAtTime(options.value, 0);\n\n    return _this;\n  }\n  /**\n   * Callback which is invoked every tick.\n   */\n\n\n  _createClass(SyncedSignal, [{\n    key: \"_onTick\",\n    value: function _onTick(time) {\n      var val = _get(_getPrototypeOf(SyncedSignal.prototype), \"getValueAtTime\", this).call(this, this.context.transport.seconds); // approximate ramp curves with linear ramps\n\n\n      if (this._lastVal !== val) {\n        this._lastVal = val;\n\n        this._constantSource.offset.setValueAtTime(val, time);\n      }\n    }\n    /**\n     * Anchor the value at the start and stop of the Transport\n     */\n\n  }, {\n    key: \"_anchorValue\",\n    value: function _anchorValue(time) {\n      var val = _get(_getPrototypeOf(SyncedSignal.prototype), \"getValueAtTime\", this).call(this, this.context.transport.seconds);\n\n      this._lastVal = val;\n\n      this._constantSource.offset.cancelAndHoldAtTime(time);\n\n      this._constantSource.offset.setValueAtTime(val, time);\n    }\n  }, {\n    key: \"getValueAtTime\",\n    value: function getValueAtTime(time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n      return _get(_getPrototypeOf(SyncedSignal.prototype), \"getValueAtTime\", this).call(this, computedTime);\n    }\n  }, {\n    key: \"setValueAtTime\",\n    value: function setValueAtTime(value, time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"setValueAtTime\", this).call(this, value, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"linearRampToValueAtTime\",\n    value: function linearRampToValueAtTime(value, time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"linearRampToValueAtTime\", this).call(this, value, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"exponentialRampToValueAtTime\",\n    value: function exponentialRampToValueAtTime(value, time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"exponentialRampToValueAtTime\", this).call(this, value, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"setTargetAtTime\",\n    value: function setTargetAtTime(value, startTime, timeConstant) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"setTargetAtTime\", this).call(this, value, computedTime, timeConstant);\n\n      return this;\n    }\n  }, {\n    key: \"cancelScheduledValues\",\n    value: function cancelScheduledValues(startTime) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"cancelScheduledValues\", this).call(this, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"setValueCurveAtTime\",\n    value: function setValueCurveAtTime(values, startTime, duration, scaling) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n      duration = this.toSeconds(duration);\n\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"setValueCurveAtTime\", this).call(this, values, computedTime, duration, scaling);\n\n      return this;\n    }\n  }, {\n    key: \"cancelAndHoldAtTime\",\n    value: function cancelAndHoldAtTime(time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"cancelAndHoldAtTime\", this).call(this, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"setRampPoint\",\n    value: function setRampPoint(time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"setRampPoint\", this).call(this, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"exponentialRampTo\",\n    value: function exponentialRampTo(value, rampTime, startTime) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"exponentialRampTo\", this).call(this, value, rampTime, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"linearRampTo\",\n    value: function linearRampTo(value, rampTime, startTime) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"linearRampTo\", this).call(this, value, rampTime, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"targetRampTo\",\n    value: function targetRampTo(value, rampTime, startTime) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"targetRampTo\", this).call(this, value, rampTime, computedTime);\n\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"dispose\", this).call(this);\n\n      this.context.transport.clear(this._synced);\n      this.context.transport.off(\"start\", this._syncedCallback);\n      this.context.transport.off(\"pause\", this._syncedCallback);\n      this.context.transport.off(\"stop\", this._syncedCallback);\n\n      this._constantSource.dispose();\n\n      return this;\n    }\n  }]);\n\n  return SyncedSignal;\n}(Signal);","map":{"version":3,"sources":["../../../Tone/signal/SyncedSignal.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Signal } from \"./Signal\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n/**\n * Adds the ability to synchronize the signal to the [[Transport]]\n */\nexport class SyncedSignal extends Signal {\n    constructor() {\n        super(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n        this.name = \"SyncedSignal\";\n        /**\n         * Don't override when something is connected to the input\n         */\n        this.override = false;\n        const options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]);\n        this._lastVal = options.value;\n        this._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), \"1i\");\n        this._syncedCallback = this._anchorValue.bind(this);\n        this.context.transport.on(\"start\", this._syncedCallback);\n        this.context.transport.on(\"pause\", this._syncedCallback);\n        this.context.transport.on(\"stop\", this._syncedCallback);\n        // disconnect the constant source from the output and replace it with another one\n        this._constantSource.disconnect();\n        this._constantSource.stop(0);\n        // create a new one\n        this._constantSource = this.output = new ToneConstantSource({\n            context: this.context,\n            offset: options.value,\n            units: options.units,\n        }).start(0);\n        this.setValueAtTime(options.value, 0);\n    }\n    /**\n     * Callback which is invoked every tick.\n     */\n    _onTick(time) {\n        const val = super.getValueAtTime(this.context.transport.seconds);\n        // approximate ramp curves with linear ramps\n        if (this._lastVal !== val) {\n            this._lastVal = val;\n            this._constantSource.offset.setValueAtTime(val, time);\n        }\n    }\n    /**\n     * Anchor the value at the start and stop of the Transport\n     */\n    _anchorValue(time) {\n        const val = super.getValueAtTime(this.context.transport.seconds);\n        this._lastVal = val;\n        this._constantSource.offset.cancelAndHoldAtTime(time);\n        this._constantSource.offset.setValueAtTime(val, time);\n    }\n    getValueAtTime(time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        return super.getValueAtTime(computedTime);\n    }\n    setValueAtTime(value, time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        super.setValueAtTime(value, computedTime);\n        return this;\n    }\n    linearRampToValueAtTime(value, time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        super.linearRampToValueAtTime(value, computedTime);\n        return this;\n    }\n    exponentialRampToValueAtTime(value, time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        super.exponentialRampToValueAtTime(value, computedTime);\n        return this;\n    }\n    setTargetAtTime(value, startTime, timeConstant) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        super.setTargetAtTime(value, computedTime, timeConstant);\n        return this;\n    }\n    cancelScheduledValues(startTime) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        super.cancelScheduledValues(computedTime);\n        return this;\n    }\n    setValueCurveAtTime(values, startTime, duration, scaling) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        duration = this.toSeconds(duration);\n        super.setValueCurveAtTime(values, computedTime, duration, scaling);\n        return this;\n    }\n    cancelAndHoldAtTime(time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        super.cancelAndHoldAtTime(computedTime);\n        return this;\n    }\n    setRampPoint(time) {\n        const computedTime = new TransportTimeClass(this.context, time).toSeconds();\n        super.setRampPoint(computedTime);\n        return this;\n    }\n    exponentialRampTo(value, rampTime, startTime) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        super.exponentialRampTo(value, rampTime, computedTime);\n        return this;\n    }\n    linearRampTo(value, rampTime, startTime) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        super.linearRampTo(value, rampTime, computedTime);\n        return this;\n    }\n    targetRampTo(value, rampTime, startTime) {\n        const computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n        super.targetRampTo(value, rampTime, computedTime);\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this.context.transport.clear(this._synced);\n        this.context.transport.off(\"start\", this._syncedCallback);\n        this.context.transport.off(\"pause\", this._syncedCallback);\n        this.context.transport.off(\"stop\", this._syncedCallback);\n        this._constantSource.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=SyncedSignal.js.map"]},"metadata":{},"sourceType":"module"}