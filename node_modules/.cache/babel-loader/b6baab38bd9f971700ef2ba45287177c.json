{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\n\nexport var Emitter = /*#__PURE__*/function (_Tone) {\n  _inherits(Emitter, _Tone);\n\n  var _super = _createSuper(Emitter);\n\n  function Emitter() {\n    var _this;\n\n    _classCallCheck(this, Emitter);\n\n    _this = _super.apply(this, arguments);\n    _this.name = \"Emitter\";\n    return _this;\n  }\n  /**\n   * Bind a callback to a specific event.\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n\n\n  _createClass(Emitter, [{\n    key: \"on\",\n    value: function on(event, callback) {\n      var _this2 = this;\n\n      // split the event\n      var events = event.split(/\\W+/);\n      events.forEach(function (eventName) {\n        if (isUndef(_this2._events)) {\n          _this2._events = {};\n        }\n\n        if (!_this2._events.hasOwnProperty(eventName)) {\n          _this2._events[eventName] = [];\n        }\n\n        _this2._events[eventName].push(callback);\n      });\n      return this;\n    }\n    /**\n     * Bind a callback which is only invoked once\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n\n  }, {\n    key: \"once\",\n    value: function once(event, callback) {\n      var _this3 = this;\n\n      var boundCallback = function boundCallback() {\n        // invoke the callback\n        callback.apply(void 0, arguments); // remove the event\n\n        _this3.off(event, boundCallback);\n      };\n\n      this.on(event, boundCallback);\n      return this;\n    }\n    /**\n     * Remove the event listener.\n     * @param  event     The event to stop listening to.\n     * @param  callback  The callback which was bound to the event with Emitter.on.\n     *                   If no callback is given, all callbacks events are removed.\n     */\n\n  }, {\n    key: \"off\",\n    value: function off(event, callback) {\n      var _this4 = this;\n\n      var events = event.split(/\\W+/);\n      events.forEach(function (eventName) {\n        if (isUndef(_this4._events)) {\n          _this4._events = {};\n        }\n\n        if (_this4._events.hasOwnProperty(event)) {\n          if (isUndef(callback)) {\n            _this4._events[event] = [];\n          } else {\n            var eventList = _this4._events[event];\n\n            for (var i = eventList.length - 1; i >= 0; i--) {\n              if (eventList[i] === callback) {\n                eventList.splice(i, 1);\n              }\n            }\n          }\n        }\n      });\n      return this;\n    }\n    /**\n     * Invoke all of the callbacks bound to the event\n     * with any arguments passed in.\n     * @param  event  The name of the event.\n     * @param args The arguments to pass to the functions listening.\n     */\n\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      if (this._events) {\n        if (this._events.hasOwnProperty(event)) {\n          var eventList = this._events[event].slice(0);\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          for (var i = 0, len = eventList.length; i < len; i++) {\n            eventList[i].apply(this, args);\n          }\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Add Emitter functions (on/off/emit) to the object\n     */\n\n  }, {\n    key: \"dispose\",\n\n    /**\n     * Clean up\n     */\n    value: function dispose() {\n      _get(_getPrototypeOf(Emitter.prototype), \"dispose\", this).call(this);\n\n      this._events = undefined;\n      return this;\n    }\n  }], [{\n    key: \"mixin\",\n    value: function mixin(constr) {\n      // instance._events = {};\n      [\"on\", \"once\", \"off\", \"emit\"].forEach(function (name) {\n        var property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n        Object.defineProperty(constr.prototype, name, property);\n      });\n    }\n  }]);\n\n  return Emitter;\n}(Tone);","map":{"version":3,"sources":["../../../../Tone/core/util/Emitter.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport class Emitter extends Tone {\n    constructor() {\n        super(...arguments);\n        this.name = \"Emitter\";\n    }\n    /**\n     * Bind a callback to a specific event.\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n    on(event, callback) {\n        // split the event\n        const events = event.split(/\\W+/);\n        events.forEach(eventName => {\n            if (isUndef(this._events)) {\n                this._events = {};\n            }\n            if (!this._events.hasOwnProperty(eventName)) {\n                this._events[eventName] = [];\n            }\n            this._events[eventName].push(callback);\n        });\n        return this;\n    }\n    /**\n     * Bind a callback which is only invoked once\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n    once(event, callback) {\n        const boundCallback = (...args) => {\n            // invoke the callback\n            callback(...args);\n            // remove the event\n            this.off(event, boundCallback);\n        };\n        this.on(event, boundCallback);\n        return this;\n    }\n    /**\n     * Remove the event listener.\n     * @param  event     The event to stop listening to.\n     * @param  callback  The callback which was bound to the event with Emitter.on.\n     *                   If no callback is given, all callbacks events are removed.\n     */\n    off(event, callback) {\n        const events = event.split(/\\W+/);\n        events.forEach(eventName => {\n            if (isUndef(this._events)) {\n                this._events = {};\n            }\n            if (this._events.hasOwnProperty(event)) {\n                if (isUndef(callback)) {\n                    this._events[event] = [];\n                }\n                else {\n                    const eventList = this._events[event];\n                    for (let i = eventList.length - 1; i >= 0; i--) {\n                        if (eventList[i] === callback) {\n                            eventList.splice(i, 1);\n                        }\n                    }\n                }\n            }\n        });\n        return this;\n    }\n    /**\n     * Invoke all of the callbacks bound to the event\n     * with any arguments passed in.\n     * @param  event  The name of the event.\n     * @param args The arguments to pass to the functions listening.\n     */\n    emit(event, ...args) {\n        if (this._events) {\n            if (this._events.hasOwnProperty(event)) {\n                const eventList = this._events[event].slice(0);\n                for (let i = 0, len = eventList.length; i < len; i++) {\n                    eventList[i].apply(this, args);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Add Emitter functions (on/off/emit) to the object\n     */\n    static mixin(constr) {\n        // instance._events = {};\n        [\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n            const property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n            Object.defineProperty(constr.prototype, name, property);\n        });\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this._events = undefined;\n        return this;\n    }\n}\n//# sourceMappingURL=Emitter.js.map"]},"metadata":{},"sourceType":"module"}