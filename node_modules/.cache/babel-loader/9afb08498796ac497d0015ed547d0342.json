{"ast":null,"code":"var utils = require('../utils'),\n    CONST = require('../const'),\n    EventEmitter = require('eventemitter3');\n/**\n * A texture stores the information that represents an image. All textures have a base texture.\n *\n * @class\n * @memberof PIXI\n * @param source {Image|Canvas} the source object of the texture.\n * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values\n * @param resolution {number} the resolution of the texture for devices with different pixel ratios\n */\n\n\nfunction BaseTexture(source, scaleMode, resolution) {\n  EventEmitter.call(this);\n  this.uid = utils.uid();\n  /**\n   * The Resolution of the texture.\n   *\n   * @member {number}\n   */\n\n  this.resolution = resolution || 1;\n  /**\n   * The width of the base texture set when the image has loaded\n   *\n   * @member {number}\n   * @readOnly\n   */\n\n  this.width = 100;\n  /**\n   * The height of the base texture set when the image has loaded\n   *\n   * @member {number}\n   * @readOnly\n   */\n\n  this.height = 100; // TODO docs\n  // used to store the actual dimensions of the source\n\n  /**\n   * Used to store the actual width of the source of this texture\n   *\n   * @member {number}\n   * @readOnly\n   */\n\n  this.realWidth = 100;\n  /**\n   * Used to store the actual height of the source of this texture\n   *\n   * @member {number}\n   * @readOnly\n   */\n\n  this.realHeight = 100;\n  /**\n   * The scale mode to apply when scaling this texture\n   *\n   * @member {{number}}\n   * @default scaleModes.LINEAR\n   */\n\n  this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;\n  /**\n   * Set to true once the base texture has successfully loaded.\n   *\n   * This is never true if the underlying source fails to load or has no texture data.\n   *\n   * @member {boolean}\n   * @readOnly\n   */\n\n  this.hasLoaded = false;\n  /**\n   * Set to true if the source is currently loading.\n   *\n   * If an Image source is loading the 'loaded' or 'error' event will be\n   * dispatched when the operation ends. An underyling source that is\n   * immediately-available bypasses loading entirely.\n   *\n   * @member {boolean}\n   * @readonly\n   */\n\n  this.isLoading = false;\n  /**\n   * The image source that is used to create the texture.\n   *\n   * TODO: Make this a setter that calls loadSource();\n   *\n   * @member {Image|Canvas}\n   * @readonly\n   */\n\n  this.source = null; // set in loadSource, if at all\n\n  /**\n   * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)\n   *\n   * @member {boolean}\n   * @default true\n   */\n\n  this.premultipliedAlpha = true;\n  /**\n   * @member {string}\n   */\n\n  this.imageUrl = null;\n  /**\n   * Wether or not the texture is a power of two, try to use power of two textures as much as you can\n   * @member {boolean}\n   * @private\n   */\n\n  this.isPowerOfTwo = false; // used for webGL\n\n  /**\n   *\n   * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used\n   * Also the texture must be a power of two size to work\n   *\n   * @member {boolean}\n   */\n\n  this.mipmap = false;\n  /**\n   * A map of renderer IDs to webgl textures\n   *\n   * @member {object<number, WebGLTexture>}\n   * @private\n   */\n\n  this._glTextures = []; // if no source passed don't try to load\n\n  if (source) {\n    this.loadSource(source);\n  }\n  /**\n   * Fired when a not-immediately-available source finishes loading.\n   *\n   * @event loaded\n   * @memberof PIXI.BaseTexture#\n   * @protected\n   */\n\n  /**\n   * Fired when a not-immediately-available source fails to load.\n   *\n   * @event error\n   * @memberof PIXI.BaseTexture#\n   * @protected\n   */\n\n}\n\nBaseTexture.prototype = Object.create(EventEmitter.prototype);\nBaseTexture.prototype.constructor = BaseTexture;\nmodule.exports = BaseTexture;\n/**\n * Updates the texture on all the webgl renderers, this also assumes the src has changed.\n *\n * @fires update\n */\n\nBaseTexture.prototype.update = function () {\n  this.realWidth = this.source.naturalWidth || this.source.width;\n  this.realHeight = this.source.naturalHeight || this.source.height;\n  this.width = this.realWidth / this.resolution;\n  this.height = this.realHeight / this.resolution;\n  this.isPowerOfTwo = utils.isPowerOfTwo(this.realWidth, this.realHeight);\n  this.emit('update', this);\n};\n/**\n * Load a source.\n *\n * If the source is not-immediately-available, such as an image that needs to be\n * downloaded, then the 'loaded' or 'error' event will be dispatched in the future\n * and `hasLoaded` will remain false after this call.\n *\n * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:\n *\n *     if (texture.hasLoaded)\n {\n *        // texture ready for use\n *     } else if (texture.isLoading)\n {\n *        // listen to 'loaded' and/or 'error' events on texture\n *     } else {\n *        // not loading, not going to load UNLESS the source is reloaded\n *        // (it may still make sense to listen to the events)\n *     }\n *\n * @protected\n * @param source {Image|Canvas} the source object of the texture.\n */\n\n\nBaseTexture.prototype.loadSource = function (source) {\n  var wasLoading = this.isLoading;\n  this.hasLoaded = false;\n  this.isLoading = false;\n\n  if (wasLoading && this.source) {\n    this.source.onload = null;\n    this.source.onerror = null;\n  }\n\n  this.source = source; // Apply source if loaded. Otherwise setup appropriate loading monitors.\n\n  if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height) {\n    this._sourceLoaded();\n  } else if (!source.getContext) {\n    // Image fail / not ready\n    this.isLoading = true;\n    var scope = this;\n\n    source.onload = function () {\n      source.onload = null;\n      source.onerror = null;\n\n      if (!scope.isLoading) {\n        return;\n      }\n\n      scope.isLoading = false;\n\n      scope._sourceLoaded();\n\n      scope.emit('loaded', scope);\n    };\n\n    source.onerror = function () {\n      source.onload = null;\n      source.onerror = null;\n\n      if (!scope.isLoading) {\n        return;\n      }\n\n      scope.isLoading = false;\n      scope.emit('error', scope);\n    }; // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element\n    //   \"The value of `complete` can thus change while a script is executing.\"\n    // So complete needs to be re-checked after the callbacks have been added..\n    // NOTE: complete will be true if the image has no src so best to check if the src is set.\n\n\n    if (source.complete && source.src) {\n      this.isLoading = false; // ..and if we're complete now, no need for callbacks\n\n      source.onload = null;\n      source.onerror = null;\n\n      if (source.width && source.height) {\n        this._sourceLoaded(); // If any previous subscribers possible\n\n\n        if (wasLoading) {\n          this.emit('loaded', this);\n        }\n      } else {\n        // If any previous subscribers possible\n        if (wasLoading) {\n          this.emit('error', this);\n        }\n      }\n    }\n  }\n};\n/**\n * Used internally to update the width, height, and some other tracking vars once\n * a source has successfully loaded.\n *\n * @private\n */\n\n\nBaseTexture.prototype._sourceLoaded = function () {\n  this.hasLoaded = true;\n  this.update();\n};\n/**\n * Destroys this base texture\n *\n */\n\n\nBaseTexture.prototype.destroy = function () {\n  if (this.imageUrl) {\n    delete utils.BaseTextureCache[this.imageUrl];\n    delete utils.TextureCache[this.imageUrl];\n    this.imageUrl = null;\n\n    if (!navigator.isCocoonJS) {\n      this.source.src = '';\n    }\n  } else if (this.source && this.source._pixiId) {\n    delete utils.BaseTextureCache[this.source._pixiId];\n  }\n\n  this.source = null;\n  this.dispose();\n};\n/**\n * Frees the texture from WebGL memory without destroying this texture object.\n * This means you can still use the texture later which will upload it to GPU\n * memory again.\n *\n */\n\n\nBaseTexture.prototype.dispose = function () {\n  this.emit('dispose', this);\n  this._glTextures.length = 0;\n};\n/**\n * Changes the source image of the texture.\n * The original source must be an Image element.\n *\n * @param newSrc {string} the path of the image\n */\n\n\nBaseTexture.prototype.updateSourceImage = function (newSrc) {\n  this.source.src = newSrc;\n  this.loadSource(this.source);\n};\n/**\n * Helper function that creates a base texture from the given image url.\n * If the image is not in the base texture cache it will be created and loaded.\n *\n * @static\n * @param imageUrl {string} The image url of the texture\n * @param [crossorigin=(auto)] {boolean} Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values\n * @return BaseTexture\n */\n\n\nBaseTexture.fromImage = function (imageUrl, crossorigin, scaleMode) {\n  var baseTexture = utils.BaseTextureCache[imageUrl];\n\n  if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0) {\n    crossorigin = true;\n  }\n\n  if (!baseTexture) {\n    // new Image() breaks tex loading in some versions of Chrome.\n    // See https://code.google.com/p/chromium/issues/detail?id=238071\n    var image = new Image(); //document.createElement('img');\n\n    if (crossorigin) {\n      image.crossOrigin = '';\n    }\n\n    baseTexture = new BaseTexture(image, scaleMode);\n    baseTexture.imageUrl = imageUrl;\n    image.src = imageUrl;\n    utils.BaseTextureCache[imageUrl] = baseTexture; // if there is an @2x at the end of the url we are going to assume its a highres image\n\n    baseTexture.resolution = utils.getResolutionOfUrl(imageUrl);\n  }\n\n  return baseTexture;\n};\n/**\n * Helper function that creates a base texture from the given canvas element.\n *\n * @static\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {number} See {{#crossLink \"PIXI/scaleModes:property\"}}scaleModes{{/crossLink}} for possible values\n * @return BaseTexture\n */\n\n\nBaseTexture.fromCanvas = function (canvas, scaleMode) {\n  if (!canvas._pixiId) {\n    canvas._pixiId = 'canvas_' + utils.uid();\n  }\n\n  var baseTexture = utils.BaseTextureCache[canvas._pixiId];\n\n  if (!baseTexture) {\n    baseTexture = new BaseTexture(canvas, scaleMode);\n    utils.BaseTextureCache[canvas._pixiId] = baseTexture;\n  }\n\n  return baseTexture;\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/textures/BaseTexture.js"],"names":["utils","require","CONST","EventEmitter","BaseTexture","source","scaleMode","resolution","call","uid","width","height","realWidth","realHeight","SCALE_MODES","DEFAULT","hasLoaded","isLoading","premultipliedAlpha","imageUrl","isPowerOfTwo","mipmap","_glTextures","loadSource","prototype","Object","create","constructor","module","exports","update","naturalWidth","naturalHeight","emit","wasLoading","onload","onerror","complete","getContext","_sourceLoaded","scope","src","destroy","BaseTextureCache","TextureCache","navigator","isCocoonJS","_pixiId","dispose","length","updateSourceImage","newSrc","fromImage","crossorigin","baseTexture","undefined","indexOf","image","Image","crossOrigin","getResolutionOfUrl","fromCanvas","canvas"],"mappings":"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","sourcesContent":["var utils = require('../utils'),\n    CONST = require('../const'),\n    EventEmitter = require('eventemitter3');\n\n/**\n * A texture stores the information that represents an image. All textures have a base texture.\n *\n * @class\n * @memberof PIXI\n * @param source {Image|Canvas} the source object of the texture.\n * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values\n * @param resolution {number} the resolution of the texture for devices with different pixel ratios\n */\nfunction BaseTexture(source, scaleMode, resolution)\n{\n    EventEmitter.call(this);\n\n    this.uid = utils.uid();\n\n    /**\n     * The Resolution of the texture.\n     *\n     * @member {number}\n     */\n    this.resolution = resolution || 1;\n\n    /**\n     * The width of the base texture set when the image has loaded\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.width = 100;\n\n    /**\n     * The height of the base texture set when the image has loaded\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.height = 100;\n\n    // TODO docs\n    // used to store the actual dimensions of the source\n    /**\n     * Used to store the actual width of the source of this texture\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.realWidth = 100;\n    /**\n     * Used to store the actual height of the source of this texture\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.realHeight = 100;\n\n    /**\n     * The scale mode to apply when scaling this texture\n     *\n     * @member {{number}}\n     * @default scaleModes.LINEAR\n     */\n    this.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;\n\n    /**\n     * Set to true once the base texture has successfully loaded.\n     *\n     * This is never true if the underlying source fails to load or has no texture data.\n     *\n     * @member {boolean}\n     * @readOnly\n     */\n    this.hasLoaded = false;\n\n    /**\n     * Set to true if the source is currently loading.\n     *\n     * If an Image source is loading the 'loaded' or 'error' event will be\n     * dispatched when the operation ends. An underyling source that is\n     * immediately-available bypasses loading entirely.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    this.isLoading = false;\n\n    /**\n     * The image source that is used to create the texture.\n     *\n     * TODO: Make this a setter that calls loadSource();\n     *\n     * @member {Image|Canvas}\n     * @readonly\n     */\n    this.source = null; // set in loadSource, if at all\n\n    /**\n     * Controls if RGB channels should be pre-multiplied by Alpha  (WebGL only)\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.premultipliedAlpha = true;\n\n    /**\n     * @member {string}\n     */\n    this.imageUrl = null;\n\n    /**\n     * Wether or not the texture is a power of two, try to use power of two textures as much as you can\n     * @member {boolean}\n     * @private\n     */\n    this.isPowerOfTwo = false;\n\n    // used for webGL\n\n    /**\n     *\n     * Set this to true if a mipmap of this texture needs to be generated. This value needs to be set before the texture is used\n     * Also the texture must be a power of two size to work\n     *\n     * @member {boolean}\n     */\n    this.mipmap = false;\n\n    /**\n     * A map of renderer IDs to webgl textures\n     *\n     * @member {object<number, WebGLTexture>}\n     * @private\n     */\n    this._glTextures = [];\n\n    // if no source passed don't try to load\n    if (source)\n    {\n        this.loadSource(source);\n    }\n\n    /**\n     * Fired when a not-immediately-available source finishes loading.\n     *\n     * @event loaded\n     * @memberof PIXI.BaseTexture#\n     * @protected\n     */\n\n    /**\n     * Fired when a not-immediately-available source fails to load.\n     *\n     * @event error\n     * @memberof PIXI.BaseTexture#\n     * @protected\n     */\n}\n\nBaseTexture.prototype = Object.create(EventEmitter.prototype);\nBaseTexture.prototype.constructor = BaseTexture;\nmodule.exports = BaseTexture;\n\n/**\n * Updates the texture on all the webgl renderers, this also assumes the src has changed.\n *\n * @fires update\n */\nBaseTexture.prototype.update = function ()\n{\n    this.realWidth = this.source.naturalWidth || this.source.width;\n    this.realHeight = this.source.naturalHeight || this.source.height;\n\n    this.width = this.realWidth / this.resolution;\n    this.height = this.realHeight / this.resolution;\n\n    this.isPowerOfTwo = utils.isPowerOfTwo(this.realWidth, this.realHeight);\n\n    this.emit('update', this);\n};\n\n/**\n * Load a source.\n *\n * If the source is not-immediately-available, such as an image that needs to be\n * downloaded, then the 'loaded' or 'error' event will be dispatched in the future\n * and `hasLoaded` will remain false after this call.\n *\n * The logic state after calling `loadSource` directly or indirectly (eg. `fromImage`, `new BaseTexture`) is:\n *\n *     if (texture.hasLoaded)\n {\n *        // texture ready for use\n *     } else if (texture.isLoading)\n {\n *        // listen to 'loaded' and/or 'error' events on texture\n *     } else {\n *        // not loading, not going to load UNLESS the source is reloaded\n *        // (it may still make sense to listen to the events)\n *     }\n *\n * @protected\n * @param source {Image|Canvas} the source object of the texture.\n */\nBaseTexture.prototype.loadSource = function (source)\n{\n    var wasLoading = this.isLoading;\n    this.hasLoaded = false;\n    this.isLoading = false;\n\n    if (wasLoading && this.source)\n    {\n        this.source.onload = null;\n        this.source.onerror = null;\n    }\n\n    this.source = source;\n\n    // Apply source if loaded. Otherwise setup appropriate loading monitors.\n    if ((this.source.complete || this.source.getContext) && this.source.width && this.source.height)\n    {\n        this._sourceLoaded();\n    }\n    else if (!source.getContext)\n    {\n\n        // Image fail / not ready\n        this.isLoading = true;\n\n        var scope = this;\n\n        source.onload = function ()\n        {\n            source.onload = null;\n            source.onerror = null;\n\n            if (!scope.isLoading)\n            {\n                return;\n            }\n\n            scope.isLoading = false;\n            scope._sourceLoaded();\n\n            scope.emit('loaded', scope);\n        };\n\n        source.onerror = function ()\n        {\n            source.onload = null;\n            source.onerror = null;\n\n            if (!scope.isLoading)\n            {\n                return;\n            }\n\n            scope.isLoading = false;\n            scope.emit('error', scope);\n        };\n\n        // Per http://www.w3.org/TR/html5/embedded-content-0.html#the-img-element\n        //   \"The value of `complete` can thus change while a script is executing.\"\n        // So complete needs to be re-checked after the callbacks have been added..\n        // NOTE: complete will be true if the image has no src so best to check if the src is set.\n        if (source.complete && source.src)\n        {\n            this.isLoading = false;\n\n            // ..and if we're complete now, no need for callbacks\n            source.onload = null;\n            source.onerror = null;\n\n            if (source.width && source.height)\n            {\n                this._sourceLoaded();\n\n                // If any previous subscribers possible\n                if (wasLoading)\n                {\n                    this.emit('loaded', this);\n                }\n            }\n            else\n            {\n                // If any previous subscribers possible\n                if (wasLoading)\n                {\n                    this.emit('error', this);\n                }\n            }\n        }\n    }\n};\n\n/**\n * Used internally to update the width, height, and some other tracking vars once\n * a source has successfully loaded.\n *\n * @private\n */\nBaseTexture.prototype._sourceLoaded = function ()\n{\n    this.hasLoaded = true;\n    this.update();\n};\n\n/**\n * Destroys this base texture\n *\n */\nBaseTexture.prototype.destroy = function ()\n{\n    if (this.imageUrl)\n    {\n        delete utils.BaseTextureCache[this.imageUrl];\n        delete utils.TextureCache[this.imageUrl];\n\n        this.imageUrl = null;\n\n        if (!navigator.isCocoonJS)\n        {\n            this.source.src = '';\n        }\n    }\n    else if (this.source && this.source._pixiId)\n    {\n        delete utils.BaseTextureCache[this.source._pixiId];\n    }\n\n    this.source = null;\n\n    this.dispose();\n};\n\n/**\n * Frees the texture from WebGL memory without destroying this texture object.\n * This means you can still use the texture later which will upload it to GPU\n * memory again.\n *\n */\nBaseTexture.prototype.dispose = function ()\n{\n    this.emit('dispose', this);\n\n    this._glTextures.length = 0;\n};\n\n/**\n * Changes the source image of the texture.\n * The original source must be an Image element.\n *\n * @param newSrc {string} the path of the image\n */\nBaseTexture.prototype.updateSourceImage = function (newSrc)\n{\n    this.source.src = newSrc;\n\n    this.loadSource(this.source);\n};\n\n/**\n * Helper function that creates a base texture from the given image url.\n * If the image is not in the base texture cache it will be created and loaded.\n *\n * @static\n * @param imageUrl {string} The image url of the texture\n * @param [crossorigin=(auto)] {boolean} Should use anonymous CORS? Defaults to true if the URL is not a data-URI.\n * @param [scaleMode=scaleModes.DEFAULT] {number} See {@link SCALE_MODES} for possible values\n * @return BaseTexture\n */\nBaseTexture.fromImage = function (imageUrl, crossorigin, scaleMode)\n{\n    var baseTexture = utils.BaseTextureCache[imageUrl];\n\n    if (crossorigin === undefined && imageUrl.indexOf('data:') !== 0)\n    {\n        crossorigin = true;\n    }\n\n    if (!baseTexture)\n    {\n        // new Image() breaks tex loading in some versions of Chrome.\n        // See https://code.google.com/p/chromium/issues/detail?id=238071\n        var image = new Image();//document.createElement('img');\n        if (crossorigin)\n        {\n            image.crossOrigin = '';\n        }\n\n        baseTexture = new BaseTexture(image, scaleMode);\n        baseTexture.imageUrl = imageUrl;\n\n        image.src = imageUrl;\n\n        utils.BaseTextureCache[imageUrl] = baseTexture;\n\n        // if there is an @2x at the end of the url we are going to assume its a highres image\n        baseTexture.resolution = utils.getResolutionOfUrl(imageUrl);\n    }\n\n    return baseTexture;\n};\n\n/**\n * Helper function that creates a base texture from the given canvas element.\n *\n * @static\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {number} See {{#crossLink \"PIXI/scaleModes:property\"}}scaleModes{{/crossLink}} for possible values\n * @return BaseTexture\n */\nBaseTexture.fromCanvas = function (canvas, scaleMode)\n{\n    if (!canvas._pixiId)\n    {\n        canvas._pixiId = 'canvas_' + utils.uid();\n    }\n\n    var baseTexture = utils.BaseTextureCache[canvas._pixiId];\n\n    if (!baseTexture)\n    {\n        baseTexture = new BaseTexture(canvas, scaleMode);\n        utils.BaseTextureCache[canvas._pixiId] = baseTexture;\n    }\n\n    return baseTexture;\n};\n"]},"metadata":{},"sourceType":"script"}