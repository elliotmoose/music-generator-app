{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar BinarySearch_1 = require(\"./BinarySearch\");\n\nvar privatePPQMap = new WeakMap();\n/**\n * @hidden\n */\n\nexports.keySignatureKeys = [\"Cb\", \"Gb\", \"Db\", \"Ab\", \"Eb\", \"Bb\", \"F\", \"C\", \"G\", \"D\", \"A\", \"E\", \"B\", \"F#\", \"C#\"];\n/** The parsed midi file header */\n\nvar Header =\n/** @class */\nfunction () {\n  function Header(midiData) {\n    // look through all the tracks for tempo changes\n    var _this = this;\n    /**\n     * The array of all the tempo events\n     */\n\n\n    this.tempos = [];\n    /**\n     * The time signatures\n     */\n\n    this.timeSignatures = [];\n    /**\n     * The time signatures\n     */\n\n    this.keySignatures = [];\n    /**\n     * Additional meta events\n     */\n\n    this.meta = [];\n    /**\n     * The name of the midi file\n     */\n\n    this.name = \"\";\n    privatePPQMap.set(this, 480);\n\n    if (midiData) {\n      privatePPQMap.set(this, midiData.header.ticksPerBeat); // check time signature and tempo events from all of the tracks\n\n      midiData.tracks.forEach(function (track) {\n        return track.forEach(function (event) {\n          if (event.meta) {\n            if (event.type === \"timeSignature\") {\n              _this.timeSignatures.push({\n                ticks: event.absoluteTime,\n                timeSignature: [event.numerator, event.denominator]\n              });\n            } else if (event.type === \"setTempo\") {\n              _this.tempos.push({\n                bpm: 60000000 / event.microsecondsPerBeat,\n                ticks: event.absoluteTime\n              });\n            } else if (event.type === \"keySignature\") {\n              _this.keySignatures.push({\n                key: exports.keySignatureKeys[event.key + 7],\n                scale: event.scale === 0 ? \"major\" : \"minor\",\n                ticks: event.absoluteTime\n              });\n            }\n          }\n        });\n      }); // check the first track for other relevant data\n\n      midiData.tracks[0].forEach(function (event) {\n        if (event.meta) {\n          if (event.type === \"trackName\") {\n            _this.name = event.text;\n          } else if (event.type === \"text\" || event.type === \"cuePoint\" || event.type === \"marker\" || event.type === \"lyrics\") {\n            _this.meta.push({\n              text: event.text,\n              ticks: event.absoluteTime,\n              type: event.type\n            });\n          }\n        }\n      });\n      this.update();\n    }\n  }\n  /**\n   * This must be invoked after any changes are made to the tempo array\n   * or the timeSignature array for the updated values to be reflected.\n   */\n\n\n  Header.prototype.update = function () {\n    var _this = this;\n\n    var currentTime = 0;\n    var lastEventBeats = 0; // make sure it's sorted\n\n    this.tempos.sort(function (a, b) {\n      return a.ticks - b.ticks;\n    });\n    this.tempos.forEach(function (event, index) {\n      var lastBPM = index > 0 ? _this.tempos[index - 1].bpm : _this.tempos[0].bpm;\n      var beats = event.ticks / _this.ppq - lastEventBeats;\n      var elapsedSeconds = 60 / lastBPM * beats;\n      event.time = elapsedSeconds + currentTime;\n      currentTime = event.time;\n      lastEventBeats += beats;\n    });\n    this.timeSignatures.sort(function (a, b) {\n      return a.ticks - b.ticks;\n    });\n    this.timeSignatures.forEach(function (event, index) {\n      var lastEvent = index > 0 ? _this.timeSignatures[index - 1] : _this.timeSignatures[0];\n      var elapsedBeats = (event.ticks - lastEvent.ticks) / _this.ppq;\n      var elapsedMeasures = elapsedBeats / lastEvent.timeSignature[0] / (lastEvent.timeSignature[1] / 4);\n      lastEvent.measures = lastEvent.measures || 0;\n      event.measures = elapsedMeasures + lastEvent.measures;\n    });\n  };\n  /**\n   * Convert ticks into seconds based on the tempo changes\n   */\n\n\n  Header.prototype.ticksToSeconds = function (ticks) {\n    // find the relevant position\n    var index = BinarySearch_1.search(this.tempos, ticks);\n\n    if (index !== -1) {\n      var tempo = this.tempos[index];\n      var tempoTime = tempo.time;\n      var elapsedBeats = (ticks - tempo.ticks) / this.ppq;\n      return tempoTime + 60 / tempo.bpm * elapsedBeats;\n    } else {\n      // assume 120\n      var beats = ticks / this.ppq;\n      return 60 / 120 * beats;\n    }\n  };\n  /**\n   * Convert ticks into measures based off of the time signatures\n   */\n\n\n  Header.prototype.ticksToMeasures = function (ticks) {\n    var index = BinarySearch_1.search(this.timeSignatures, ticks);\n\n    if (index !== -1) {\n      var timeSigEvent = this.timeSignatures[index];\n      var elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;\n      return timeSigEvent.measures + elapsedBeats / (timeSigEvent.timeSignature[0] / timeSigEvent.timeSignature[1]) / 4;\n    } else {\n      return ticks / this.ppq / 4;\n    }\n  };\n\n  Object.defineProperty(Header.prototype, \"ppq\", {\n    /**\n     * The number of ticks per quarter note\n     */\n    get: function get() {\n      return privatePPQMap.get(this);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Convert seconds to ticks based on the tempo events\n   */\n\n  Header.prototype.secondsToTicks = function (seconds) {\n    // find the relevant position\n    var index = BinarySearch_1.search(this.tempos, seconds, \"time\");\n\n    if (index !== -1) {\n      var tempo = this.tempos[index];\n      var tempoTime = tempo.time;\n      var elapsedTime = seconds - tempoTime;\n      var elapsedBeats = elapsedTime / (60 / tempo.bpm);\n      return Math.round(tempo.ticks + elapsedBeats * this.ppq);\n    } else {\n      // assume 120\n      var beats = seconds / (60 / 120);\n      return Math.round(beats * this.ppq);\n    }\n  };\n  /**\n   * Convert the header into an object.\n   */\n\n\n  Header.prototype.toJSON = function () {\n    return {\n      keySignatures: this.keySignatures,\n      meta: this.meta,\n      name: this.name,\n      ppq: this.ppq,\n      tempos: this.tempos.map(function (t) {\n        return {\n          bpm: t.bpm,\n          ticks: t.ticks\n        };\n      }),\n      timeSignatures: this.timeSignatures\n    };\n  };\n  /**\n   * parse a header json object.\n   */\n\n\n  Header.prototype.fromJSON = function (json) {\n    this.name = json.name; // clone all the attributes\n\n    this.tempos = json.tempos.map(function (t) {\n      return Object.assign({}, t);\n    });\n    this.timeSignatures = json.timeSignatures.map(function (t) {\n      return Object.assign({}, t);\n    });\n    this.keySignatures = json.keySignatures.map(function (t) {\n      return Object.assign({}, t);\n    });\n    this.meta = json.meta.map(function (t) {\n      return Object.assign({}, t);\n    });\n    privatePPQMap.set(this, json.ppq);\n    this.update();\n  };\n  /**\n   * Update the tempo of the midi to a single tempo. Will remove and replace\n   * any other tempos currently set and update all of the event timing.\n   * @param bpm The tempo in beats per second\n   */\n\n\n  Header.prototype.setTempo = function (bpm) {\n    this.tempos = [{\n      bpm: bpm,\n      ticks: 0\n    }];\n    this.update();\n  };\n\n  return Header;\n}();\n\nexports.Header = Header;","map":{"version":3,"sources":["../src/Header.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar BinarySearch_1 = require(\"./BinarySearch\");\nvar privatePPQMap = new WeakMap();\n/**\n * @hidden\n */\nexports.keySignatureKeys = [\n    \"Cb\",\n    \"Gb\",\n    \"Db\",\n    \"Ab\",\n    \"Eb\",\n    \"Bb\",\n    \"F\",\n    \"C\",\n    \"G\",\n    \"D\",\n    \"A\",\n    \"E\",\n    \"B\",\n    \"F#\",\n    \"C#\",\n];\n/** The parsed midi file header */\nvar Header = /** @class */ (function () {\n    function Header(midiData) {\n        // look through all the tracks for tempo changes\n        var _this = this;\n        /**\n         * The array of all the tempo events\n         */\n        this.tempos = [];\n        /**\n         * The time signatures\n         */\n        this.timeSignatures = [];\n        /**\n         * The time signatures\n         */\n        this.keySignatures = [];\n        /**\n         * Additional meta events\n         */\n        this.meta = [];\n        /**\n         * The name of the midi file\n         */\n        this.name = \"\";\n        privatePPQMap.set(this, 480);\n        if (midiData) {\n            privatePPQMap.set(this, midiData.header.ticksPerBeat);\n            // check time signature and tempo events from all of the tracks\n            midiData.tracks.forEach(function (track) {\n                return track.forEach(function (event) {\n                    if (event.meta) {\n                        if (event.type === \"timeSignature\") {\n                            _this.timeSignatures.push({\n                                ticks: event.absoluteTime,\n                                timeSignature: [\n                                    event.numerator,\n                                    event.denominator,\n                                ],\n                            });\n                        }\n                        else if (event.type === \"setTempo\") {\n                            _this.tempos.push({\n                                bpm: 60000000 / event.microsecondsPerBeat,\n                                ticks: event.absoluteTime,\n                            });\n                        }\n                        else if (event.type === \"keySignature\") {\n                            _this.keySignatures.push({\n                                key: exports.keySignatureKeys[event.key + 7],\n                                scale: event.scale === 0 ? \"major\" : \"minor\",\n                                ticks: event.absoluteTime,\n                            });\n                        }\n                    }\n                });\n            });\n            // check the first track for other relevant data\n            midiData.tracks[0].forEach(function (event) {\n                if (event.meta) {\n                    if (event.type === \"trackName\") {\n                        _this.name = event.text;\n                    }\n                    else if (event.type === \"text\" ||\n                        event.type === \"cuePoint\" ||\n                        event.type === \"marker\" ||\n                        event.type === \"lyrics\") {\n                        _this.meta.push({\n                            text: event.text,\n                            ticks: event.absoluteTime,\n                            type: event.type,\n                        });\n                    }\n                }\n            });\n            this.update();\n        }\n    }\n    /**\n     * This must be invoked after any changes are made to the tempo array\n     * or the timeSignature array for the updated values to be reflected.\n     */\n    Header.prototype.update = function () {\n        var _this = this;\n        var currentTime = 0;\n        var lastEventBeats = 0;\n        // make sure it's sorted\n        this.tempos.sort(function (a, b) { return a.ticks - b.ticks; });\n        this.tempos.forEach(function (event, index) {\n            var lastBPM = index > 0 ? _this.tempos[index - 1].bpm : _this.tempos[0].bpm;\n            var beats = event.ticks / _this.ppq - lastEventBeats;\n            var elapsedSeconds = (60 / lastBPM) * beats;\n            event.time = elapsedSeconds + currentTime;\n            currentTime = event.time;\n            lastEventBeats += beats;\n        });\n        this.timeSignatures.sort(function (a, b) { return a.ticks - b.ticks; });\n        this.timeSignatures.forEach(function (event, index) {\n            var lastEvent = index > 0\n                ? _this.timeSignatures[index - 1]\n                : _this.timeSignatures[0];\n            var elapsedBeats = (event.ticks - lastEvent.ticks) / _this.ppq;\n            var elapsedMeasures = elapsedBeats /\n                lastEvent.timeSignature[0] /\n                (lastEvent.timeSignature[1] / 4);\n            lastEvent.measures = lastEvent.measures || 0;\n            event.measures = elapsedMeasures + lastEvent.measures;\n        });\n    };\n    /**\n     * Convert ticks into seconds based on the tempo changes\n     */\n    Header.prototype.ticksToSeconds = function (ticks) {\n        // find the relevant position\n        var index = BinarySearch_1.search(this.tempos, ticks);\n        if (index !== -1) {\n            var tempo = this.tempos[index];\n            var tempoTime = tempo.time;\n            var elapsedBeats = (ticks - tempo.ticks) / this.ppq;\n            return tempoTime + (60 / tempo.bpm) * elapsedBeats;\n        }\n        else {\n            // assume 120\n            var beats = ticks / this.ppq;\n            return (60 / 120) * beats;\n        }\n    };\n    /**\n     * Convert ticks into measures based off of the time signatures\n     */\n    Header.prototype.ticksToMeasures = function (ticks) {\n        var index = BinarySearch_1.search(this.timeSignatures, ticks);\n        if (index !== -1) {\n            var timeSigEvent = this.timeSignatures[index];\n            var elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;\n            return (timeSigEvent.measures +\n                elapsedBeats /\n                    (timeSigEvent.timeSignature[0] /\n                        timeSigEvent.timeSignature[1]) /\n                    4);\n        }\n        else {\n            return ticks / this.ppq / 4;\n        }\n    };\n    Object.defineProperty(Header.prototype, \"ppq\", {\n        /**\n         * The number of ticks per quarter note\n         */\n        get: function () {\n            return privatePPQMap.get(this);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * Convert seconds to ticks based on the tempo events\n     */\n    Header.prototype.secondsToTicks = function (seconds) {\n        // find the relevant position\n        var index = BinarySearch_1.search(this.tempos, seconds, \"time\");\n        if (index !== -1) {\n            var tempo = this.tempos[index];\n            var tempoTime = tempo.time;\n            var elapsedTime = seconds - tempoTime;\n            var elapsedBeats = elapsedTime / (60 / tempo.bpm);\n            return Math.round(tempo.ticks + elapsedBeats * this.ppq);\n        }\n        else {\n            // assume 120\n            var beats = seconds / (60 / 120);\n            return Math.round(beats * this.ppq);\n        }\n    };\n    /**\n     * Convert the header into an object.\n     */\n    Header.prototype.toJSON = function () {\n        return {\n            keySignatures: this.keySignatures,\n            meta: this.meta,\n            name: this.name,\n            ppq: this.ppq,\n            tempos: this.tempos.map(function (t) {\n                return {\n                    bpm: t.bpm,\n                    ticks: t.ticks,\n                };\n            }),\n            timeSignatures: this.timeSignatures,\n        };\n    };\n    /**\n     * parse a header json object.\n     */\n    Header.prototype.fromJSON = function (json) {\n        this.name = json.name;\n        // clone all the attributes\n        this.tempos = json.tempos.map(function (t) { return Object.assign({}, t); });\n        this.timeSignatures = json.timeSignatures.map(function (t) {\n            return Object.assign({}, t);\n        });\n        this.keySignatures = json.keySignatures.map(function (t) {\n            return Object.assign({}, t);\n        });\n        this.meta = json.meta.map(function (t) { return Object.assign({}, t); });\n        privatePPQMap.set(this, json.ppq);\n        this.update();\n    };\n    /**\n     * Update the tempo of the midi to a single tempo. Will remove and replace\n     * any other tempos currently set and update all of the event timing.\n     * @param bpm The tempo in beats per second\n     */\n    Header.prototype.setTempo = function (bpm) {\n        this.tempos = [\n            {\n                bpm: bpm,\n                ticks: 0,\n            },\n        ];\n        this.update();\n    };\n    return Header;\n}());\nexports.Header = Header;\n//# sourceMappingURL=Header.js.map"]},"metadata":{},"sourceType":"script"}