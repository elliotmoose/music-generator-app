{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { timeRange } from \"../core/util/Decorator\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\n\nexport var Monophonic = /*#__PURE__*/function (_Instrument) {\n  _inherits(Monophonic, _Instrument);\n\n  var _super = _createSuper(Monophonic);\n\n  function Monophonic() {\n    var _this;\n\n    _classCallCheck(this, Monophonic);\n\n    _this = _super.call(this, optionsFromArguments(Monophonic.getDefaults(), arguments));\n    var options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n    _this.portamento = options.portamento;\n    _this.onsilence = options.onsilence;\n    return _this;\n  }\n\n  _createClass(Monophonic, [{\n    key: \"triggerAttack\",\n\n    /**\n     * Trigger the attack of the note optionally with a given velocity.\n     * @param  note The note to trigger.\n     * @param  time When the note should start.\n     * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * // trigger the note a half second from now at half velocity\n     * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n     */\n    value: function triggerAttack(note, time) {\n      var velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      this.log(\"triggerAttack\", note, time, velocity);\n      var seconds = this.toSeconds(time);\n\n      this._triggerEnvelopeAttack(seconds, velocity);\n\n      this.setNote(note, seconds);\n      return this;\n    }\n    /**\n     * Trigger the release portion of the envelope\n     * @param  time If no time is given, the release happens immediatly\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // trigger the release a second from now\n     * synth.triggerRelease(\"+1\");\n     */\n\n  }, {\n    key: \"triggerRelease\",\n    value: function triggerRelease(time) {\n      this.log(\"triggerRelease\", time);\n      var seconds = this.toSeconds(time);\n\n      this._triggerEnvelopeRelease(seconds);\n\n      return this;\n    }\n    /**\n     * Set the note at the given time. If no time is given, the note\n     * will set immediately.\n     * @param note The note to change to.\n     * @param  time The time when the note should be set.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // change to F#6 in one quarter note from now.\n     * synth.setNote(\"F#6\", \"+4n\");\n     */\n\n  }, {\n    key: \"setNote\",\n    value: function setNote(note, time) {\n      var computedTime = this.toSeconds(time);\n      var computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\n      if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n        var portTime = this.toSeconds(this.portamento);\n        this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n      } else {\n        this.frequency.setValueAtTime(computedFrequency, computedTime);\n      }\n\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Instrument.getDefaults(), {\n        detune: 0,\n        onsilence: noOp,\n        portamento: 0\n      });\n    }\n  }]);\n\n  return Monophonic;\n}(Instrument);\n\n__decorate([timeRange(0)], Monophonic.prototype, \"portamento\", void 0);","map":{"version":3,"sources":["../../../Tone/instrument/Monophonic.ts"],"names":[],"mappings":";;;;;AAAA,SAAS,cAAT,QAA+B,wBAA/B;AAEA,SAAS,oBAAT,QAAqC,uBAArC;AACA,SAAS,IAAT,QAAqB,wBAArB;AACA,SAAS,UAAT,QAA8C,0BAA9C;AAEA,SAAS,SAAT,QAA0B,wBAA1B;AAUA;;AAEG;;AACH,WAAsB,UAAtB;AAAA;;AAAA;;AAwBC,wBAAA;AAAA;;AAAA;;AAEC,8BAAM,oBAAoB,CAAC,UAAU,CAAC,WAAX,EAAD,EAA2B,SAA3B,CAA1B;AACA,QAAM,OAAO,GAAG,oBAAoB,CAAC,UAAU,CAAC,WAAX,EAAD,EAA2B,SAA3B,CAApC;AAEA,UAAK,UAAL,GAAkB,OAAO,CAAC,UAA1B;AACA,UAAK,SAAL,GAAiB,OAAO,CAAC,SAAzB;AAND;AAOC;;AA/BF;AAAA;;AAyCC;;;;;;;;;AASG;AAlDJ,kCAmDe,IAnDf,EAmDiD,IAnDjD,EAmDuF;AAAA,UAAzB,QAAyB,uEAAD,CAAC;AACrF,WAAK,GAAL,CAAS,eAAT,EAA0B,IAA1B,EAAgC,IAAhC,EAAsC,QAAtC;AACA,UAAM,OAAO,GAAG,KAAK,SAAL,CAAe,IAAf,CAAhB;;AACA,WAAK,sBAAL,CAA4B,OAA5B,EAAqC,QAArC;;AACA,WAAK,OAAL,CAAa,IAAb,EAAmB,OAAnB;AACA,aAAO,IAAP;AACA;AAED;;;;;;;;AAQG;;AAnEJ;AAAA;AAAA,mCAoEgB,IApEhB,EAoE2B;AACzB,WAAK,GAAL,CAAS,gBAAT,EAA2B,IAA3B;AACA,UAAM,OAAO,GAAG,KAAK,SAAL,CAAe,IAAf,CAAhB;;AACA,WAAK,uBAAL,CAA6B,OAA7B;;AACA,aAAO,IAAP;AACA;AAoBD;;;;;;;;;;AAUG;;AAvGJ;AAAA;AAAA,4BAwGS,IAxGT,EAwG2C,IAxG3C,EAwGsD;AACpD,UAAM,YAAY,GAAG,KAAK,SAAL,CAAe,IAAf,CAArB;AACA,UAAM,iBAAiB,GAAG,IAAI,YAAY,cAAhB,GAAiC,IAAI,CAAC,WAAL,EAAjC,GAAsD,IAAhF;;AACA,UAAI,KAAK,UAAL,GAAkB,CAAlB,IAAuB,KAAK,cAAL,CAAoB,YAApB,IAAoC,IAA/D,EAAqE;AACpE,YAAM,QAAQ,GAAG,KAAK,SAAL,CAAe,KAAK,UAApB,CAAjB;AACA,aAAK,SAAL,CAAe,iBAAf,CAAiC,iBAAjC,EAAoD,QAApD,EAA8D,YAA9D;AACA,OAHD,MAGO;AACN,aAAK,SAAL,CAAe,cAAf,CAA8B,iBAA9B,EAAiD,YAAjD;AACA;;AACD,aAAO,IAAP;AACA;AAlHF;AAAA;AAAA,kCAiCmB;AACjB,aAAO,MAAM,CAAC,MAAP,CAAc,UAAU,CAAC,WAAX,EAAd,EAAwC;AAC9C,QAAA,MAAM,EAAE,CADsC;AAE9C,QAAA,SAAS,EAAE,IAFmC;AAG9C,QAAA,UAAU,EAAE;AAHkC,OAAxC,CAAP;AAKA;AAvCF;;AAAA;AAAA,EAA4E,UAA5E;;AAMC,UAAA,CAAA,CADC,SAAS,CAAC,CAAD,CACV,CAAA,E,oBAAA,E,YAAA,E,KAAoB,CAApB,CAAA","sourceRoot":"","sourcesContent":["import { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { timeRange } from \"../core/util/Decorator\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport class Monophonic extends Instrument {\n    constructor() {\n        super(optionsFromArguments(Monophonic.getDefaults(), arguments));\n        const options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n        this.portamento = options.portamento;\n        this.onsilence = options.onsilence;\n    }\n    static getDefaults() {\n        return Object.assign(Instrument.getDefaults(), {\n            detune: 0,\n            onsilence: noOp,\n            portamento: 0,\n        });\n    }\n    /**\n     * Trigger the attack of the note optionally with a given velocity.\n     * @param  note The note to trigger.\n     * @param  time When the note should start.\n     * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * // trigger the note a half second from now at half velocity\n     * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n     */\n    triggerAttack(note, time, velocity = 1) {\n        this.log(\"triggerAttack\", note, time, velocity);\n        const seconds = this.toSeconds(time);\n        this._triggerEnvelopeAttack(seconds, velocity);\n        this.setNote(note, seconds);\n        return this;\n    }\n    /**\n     * Trigger the release portion of the envelope\n     * @param  time If no time is given, the release happens immediatly\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // trigger the release a second from now\n     * synth.triggerRelease(\"+1\");\n     */\n    triggerRelease(time) {\n        this.log(\"triggerRelease\", time);\n        const seconds = this.toSeconds(time);\n        this._triggerEnvelopeRelease(seconds);\n        return this;\n    }\n    /**\n     * Set the note at the given time. If no time is given, the note\n     * will set immediately.\n     * @param note The note to change to.\n     * @param  time The time when the note should be set.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // change to F#6 in one quarter note from now.\n     * synth.setNote(\"F#6\", \"+4n\");\n     */\n    setNote(note, time) {\n        const computedTime = this.toSeconds(time);\n        const computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n        if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n            const portTime = this.toSeconds(this.portamento);\n            this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n        }\n        else {\n            this.frequency.setValueAtTime(computedFrequency, computedTime);\n        }\n        return this;\n    }\n}\n__decorate([\n    timeRange(0)\n], Monophonic.prototype, \"portamento\", void 0);\n//# sourceMappingURL=Monophonic.js.map"]},"metadata":{},"sourceType":"module"}