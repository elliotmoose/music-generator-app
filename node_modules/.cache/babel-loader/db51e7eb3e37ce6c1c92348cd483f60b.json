{"ast":null,"code":"var math = require('../math'),\n    RenderTexture = require('../textures/RenderTexture'),\n    EventEmitter = require('eventemitter3'),\n    CONST = require('../const'),\n    _tempMatrix = new math.Matrix();\n/**\n * The base class for all objects that are rendered on the screen.\n * This is an abstract class and should not be used on its own rather it should be extended.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\n\n\nfunction DisplayObject() {\n  EventEmitter.call(this);\n  /**\n   * The coordinate of the object relative to the local coordinates of the parent.\n   *\n   * @member {Point}\n   */\n\n  this.position = new math.Point();\n  /**\n   * The scale factor of the object.\n   *\n   * @member {Point}\n   */\n\n  this.scale = new math.Point(1, 1);\n  /**\n   * The pivot point of the displayObject that it rotates around\n   *\n   * @member {Point}\n   */\n\n  this.pivot = new math.Point(0, 0);\n  /**\n   * The rotation of the object in radians.\n   *\n   * @member {number}\n   */\n\n  this.rotation = 0;\n  /**\n   * The opacity of the object.\n   *\n   * @member {number}\n   */\n\n  this.alpha = 1;\n  /**\n   * The visibility of the object. If false the object will not be drawn, and\n   * the updateTransform function will not be called.\n   *\n   * @member {boolean}\n   */\n\n  this.visible = true;\n  /**\n   * Can this object be rendered, if false the object will not be drawn but the updateTransform\n   * methods will still be called.\n   *\n   * @member {boolean}\n   */\n\n  this.renderable = true;\n  /**\n   * The display object container that contains this display object.\n   *\n   * @member {Container}\n   * @readOnly\n   */\n\n  this.parent = null;\n  /**\n   * The multiplied alpha of the displayObject\n   *\n   * @member {number}\n   * @readOnly\n   */\n\n  this.worldAlpha = 1;\n  /**\n   * Current transform of the object based on world (parent) factors\n   *\n   * @member {Matrix}\n   * @readOnly\n   */\n\n  this.worldTransform = new math.Matrix();\n  /**\n   * The area the filter is applied to. This is used as more of an optimisation\n   * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle\n   *\n   * @member {Rectangle}\n   */\n\n  this.filterArea = null;\n  /**\n   * cached sin rotation\n   *\n   * @member {number}\n   * @private\n   */\n\n  this._sr = 0;\n  /**\n   * cached cos rotation\n   *\n   * @member {number}\n   * @private\n   */\n\n  this._cr = 1;\n  /**\n   * The original, cached bounds of the object\n   *\n   * @member {Rectangle}\n   * @private\n   */\n\n  this._bounds = new math.Rectangle(0, 0, 1, 1);\n  /**\n   * The most up-to-date bounds of the object\n   *\n   * @member {Rectangle}\n   * @private\n   */\n\n  this._currentBounds = null;\n  /**\n   * The original, cached mask of the object\n   *\n   * @member {Rectangle}\n   * @private\n   */\n\n  this._mask = null; //TODO rename to _isMask\n  // this.isMask = false;\n\n  /**\n   * Cached internal flag.\n   *\n   * @member {boolean}\n   * @private\n   */\n\n  this._cacheAsBitmap = false;\n  this._cachedObject = null;\n} // constructor\n\n\nDisplayObject.prototype = Object.create(EventEmitter.prototype);\nDisplayObject.prototype.constructor = DisplayObject;\nmodule.exports = DisplayObject;\nObject.defineProperties(DisplayObject.prototype, {\n  /**\n   * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n   *\n   * @member {number}\n   * @memberof DisplayObject#\n   */\n  x: {\n    get: function () {\n      return this.position.x;\n    },\n    set: function (value) {\n      this.position.x = value;\n    }\n  },\n\n  /**\n   * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n   *\n   * @member {number}\n   * @memberof DisplayObject#\n   */\n  y: {\n    get: function () {\n      return this.position.y;\n    },\n    set: function (value) {\n      this.position.y = value;\n    }\n  },\n\n  /**\n   * Indicates if the sprite is globally visible.\n   *\n   * @member {boolean}\n   * @memberof PIXI.DisplayObject#\n   * @readonly\n   */\n  worldVisible: {\n    get: function () {\n      var item = this;\n\n      do {\n        if (!item.visible) {\n          return false;\n        }\n\n        item = item.parent;\n      } while (item);\n\n      return true;\n    }\n  },\n\n  /**\n   * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.\n   * In PIXI a regular mask must be a PIXI.Graphics object. This allows for much faster masking in canvas as it utilises shape clipping.\n   * To remove a mask, set this property to null.\n   *\n   * @member {Graphics}\n   * @memberof PIXI.DisplayObject#\n   */\n  mask: {\n    get: function () {\n      return this._mask;\n    },\n    set: function (value) {\n      if (this._mask) {\n        this._mask.renderable = true;\n      }\n\n      this._mask = value;\n\n      if (this._mask) {\n        this._mask.renderable = false;\n      }\n    }\n  },\n\n  /**\n   * Sets the filters for the displayObject.\n   * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n   * To remove filters simply set this property to 'null'\n   *\n   * @member {Filter[]}\n   * @memberof PIXI.DisplayObject#\n   */\n  filters: {\n    get: function () {\n      return this._filters && this._filters.slice();\n    },\n    set: function (value) {\n      this._filters = value && value.slice();\n    }\n  }\n});\n/*\n * Updates the object transform for rendering\n *\n * TODO - Optimization pass!\n */\n\nDisplayObject.prototype.updateTransform = function () {\n  // create some matrix refs for easy access\n  var pt = this.parent.worldTransform;\n  var wt = this.worldTransform; // temporary matrix variables\n\n  var a, b, c, d, tx, ty; // so if rotation is between 0 then we can simplify the multiplication process...\n\n  if (this.rotation % CONST.PI_2) {\n    // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes\n    if (this.rotation !== this.rotationCache) {\n      this.rotationCache = this.rotation;\n      this._sr = Math.sin(this.rotation);\n      this._cr = Math.cos(this.rotation);\n    } // get the matrix values of the displayobject based on its transform properties..\n\n\n    a = this._cr * this.scale.x;\n    b = this._sr * this.scale.x;\n    c = -this._sr * this.scale.y;\n    d = this._cr * this.scale.y;\n    tx = this.position.x;\n    ty = this.position.y; // check for pivot.. not often used so geared towards that fact!\n\n    if (this.pivot.x || this.pivot.y) {\n      tx -= this.pivot.x * a + this.pivot.y * c;\n      ty -= this.pivot.x * b + this.pivot.y * d;\n    } // concat the parent matrix with the objects transform.\n\n\n    wt.a = a * pt.a + b * pt.c;\n    wt.b = a * pt.b + b * pt.d;\n    wt.c = c * pt.a + d * pt.c;\n    wt.d = c * pt.b + d * pt.d;\n    wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n    wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n  } else {\n    // lets do the fast version as we know there is no rotation..\n    a = this.scale.x;\n    d = this.scale.y;\n    tx = this.position.x - this.pivot.x * a;\n    ty = this.position.y - this.pivot.y * d;\n    wt.a = a * pt.a;\n    wt.b = a * pt.b;\n    wt.c = d * pt.c;\n    wt.d = d * pt.d;\n    wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n    wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n  } // multiply the alphas..\n\n\n  this.worldAlpha = this.alpha * this.parent.worldAlpha; // reset the bounds each time this is called!\n\n  this._currentBounds = null;\n}; // performance increase to avoid using call.. (10x faster)\n\n\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n/**\n *\n *\n * Retrieves the bounds of the displayObject as a rectangle object\n *\n * @param matrix {Matrix}\n * @return {Rectangle} the rectangular bounding area\n */\n\nDisplayObject.prototype.getBounds = function (matrix) // jshint unused:false\n{\n  return math.Rectangle.EMPTY;\n};\n/**\n * Retrieves the local bounds of the displayObject as a rectangle object\n *\n * @return {Rectangle} the rectangular bounding area\n */\n\n\nDisplayObject.prototype.getLocalBounds = function () {\n  return this.getBounds(math.Matrix.IDENTITY);\n};\n/**\n * Calculates the global position of the display object\n *\n * @param position {Point} The world origin to calculate from\n * @return {Point} A point object representing the position of this object\n */\n\n\nDisplayObject.prototype.toGlobal = function (position) {\n  // don't need to update the lot\n  this.displayObjectUpdateTransform();\n  return this.worldTransform.apply(position);\n};\n/**\n * Calculates the local position of the display object relative to another point\n *\n * @param position {Point} The world origin to calculate from\n * @param [from] {DisplayObject} The DisplayObject to calculate the global position from\n * @return {Point} A point object representing the position of this object\n */\n\n\nDisplayObject.prototype.toLocal = function (position, from) {\n  if (from) {\n    position = from.toGlobal(position);\n  } // don't need to update the lot\n\n\n  this.displayObjectUpdateTransform();\n  return this.worldTransform.applyInverse(position);\n};\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer} The renderer\n * @private\n */\n\n\nDisplayObject.prototype.renderWebGL = function (renderer) // jshint unused:false\n{// OVERWRITE;\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer} The renderer\n * @private\n */\n\n\nDisplayObject.prototype.renderCanvas = function (renderer) // jshint unused:false\n{// OVERWRITE;\n};\n/**\n * Useful function that returns a texture of the display object that can then be used to create sprites\n * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.\n *\n * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used to generate the texture.\n * @param scaleMode {Number} See {@link SCALE_MODES} for possible values\n * @param resolution {Number} The resolution of the texture being generated\n * @return {Texture} a texture of the display object\n */\n\n\nDisplayObject.prototype.generateTexture = function (renderer, scaleMode, resolution) {\n  var bounds = this.getLocalBounds();\n  var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);\n  _tempMatrix.tx = -bounds.x;\n  _tempMatrix.ty = -bounds.y;\n  renderTexture.render(this, _tempMatrix);\n  return renderTexture;\n};\n/**\n * Base destroy method for generic display objects\n *\n */\n\n\nDisplayObject.prototype.destroy = function () {\n  this.position = null;\n  this.scale = null;\n  this.pivot = null;\n  this.parent = null;\n  this._bounds = null;\n  this._currentBounds = null;\n  this._mask = null;\n  this.worldTransform = null;\n  this.filterArea = null;\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/display/DisplayObject.js"],"names":["math","require","RenderTexture","EventEmitter","CONST","_tempMatrix","Matrix","DisplayObject","call","position","Point","scale","pivot","rotation","alpha","visible","renderable","parent","worldAlpha","worldTransform","filterArea","_sr","_cr","_bounds","Rectangle","_currentBounds","_mask","_cacheAsBitmap","_cachedObject","prototype","Object","create","constructor","module","exports","defineProperties","x","get","set","value","y","worldVisible","item","mask","filters","_filters","slice","updateTransform","pt","wt","a","b","c","d","tx","ty","PI_2","rotationCache","Math","sin","cos","displayObjectUpdateTransform","getBounds","matrix","EMPTY","getLocalBounds","IDENTITY","toGlobal","apply","toLocal","from","applyInverse","renderWebGL","renderer","renderCanvas","generateTexture","scaleMode","resolution","bounds","renderTexture","width","height","render","destroy"],"mappings":"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","sourcesContent":["var math = require('../math'),\n    RenderTexture = require('../textures/RenderTexture'),\n    EventEmitter = require('eventemitter3'),\n    CONST = require('../const'),\n    _tempMatrix = new math.Matrix();\n\n/**\n * The base class for all objects that are rendered on the screen.\n * This is an abstract class and should not be used on its own rather it should be extended.\n *\n * @class\n * @extends EventEmitter\n * @memberof PIXI\n */\nfunction DisplayObject()\n{\n    EventEmitter.call(this);\n\n    /**\n     * The coordinate of the object relative to the local coordinates of the parent.\n     *\n     * @member {Point}\n     */\n    this.position = new math.Point();\n\n    /**\n     * The scale factor of the object.\n     *\n     * @member {Point}\n     */\n    this.scale = new math.Point(1, 1);\n\n    /**\n     * The pivot point of the displayObject that it rotates around\n     *\n     * @member {Point}\n     */\n    this.pivot = new math.Point(0, 0);\n\n    /**\n     * The rotation of the object in radians.\n     *\n     * @member {number}\n     */\n    this.rotation = 0;\n\n    /**\n     * The opacity of the object.\n     *\n     * @member {number}\n     */\n    this.alpha = 1;\n\n    /**\n     * The visibility of the object. If false the object will not be drawn, and\n     * the updateTransform function will not be called.\n     *\n     * @member {boolean}\n     */\n    this.visible = true;\n\n    /**\n     * Can this object be rendered, if false the object will not be drawn but the updateTransform\n     * methods will still be called.\n     *\n     * @member {boolean}\n     */\n    this.renderable = true;\n\n    /**\n     * The display object container that contains this display object.\n     *\n     * @member {Container}\n     * @readOnly\n     */\n    this.parent = null;\n\n    /**\n     * The multiplied alpha of the displayObject\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.worldAlpha = 1;\n\n    /**\n     * Current transform of the object based on world (parent) factors\n     *\n     * @member {Matrix}\n     * @readOnly\n     */\n    this.worldTransform = new math.Matrix();\n\n    /**\n     * The area the filter is applied to. This is used as more of an optimisation\n     * rather than figuring out the dimensions of the displayObject each frame you can set this rectangle\n     *\n     * @member {Rectangle}\n     */\n    this.filterArea = null;\n\n    /**\n     * cached sin rotation\n     *\n     * @member {number}\n     * @private\n     */\n    this._sr = 0;\n\n    /**\n     * cached cos rotation\n     *\n     * @member {number}\n     * @private\n     */\n    this._cr = 1;\n\n    /**\n     * The original, cached bounds of the object\n     *\n     * @member {Rectangle}\n     * @private\n     */\n    this._bounds = new math.Rectangle(0, 0, 1, 1);\n\n    /**\n     * The most up-to-date bounds of the object\n     *\n     * @member {Rectangle}\n     * @private\n     */\n    this._currentBounds = null;\n\n    /**\n     * The original, cached mask of the object\n     *\n     * @member {Rectangle}\n     * @private\n     */\n    this._mask = null;\n\n    //TODO rename to _isMask\n   // this.isMask = false;\n\n    /**\n     * Cached internal flag.\n     *\n     * @member {boolean}\n     * @private\n     */\n    this._cacheAsBitmap = false;\n    this._cachedObject = null;\n}\n\n// constructor\nDisplayObject.prototype = Object.create(EventEmitter.prototype);\nDisplayObject.prototype.constructor = DisplayObject;\nmodule.exports = DisplayObject;\n\nObject.defineProperties(DisplayObject.prototype, {\n    /**\n     * The position of the displayObject on the x axis relative to the local coordinates of the parent.\n     *\n     * @member {number}\n     * @memberof DisplayObject#\n     */\n    x: {\n        get: function ()\n        {\n            return this.position.x;\n        },\n        set: function (value)\n        {\n            this.position.x = value;\n        }\n    },\n\n    /**\n     * The position of the displayObject on the y axis relative to the local coordinates of the parent.\n     *\n     * @member {number}\n     * @memberof DisplayObject#\n     */\n    y: {\n        get: function ()\n        {\n            return this.position.y;\n        },\n        set: function (value)\n        {\n            this.position.y = value;\n        }\n    },\n\n    /**\n     * Indicates if the sprite is globally visible.\n     *\n     * @member {boolean}\n     * @memberof PIXI.DisplayObject#\n     * @readonly\n     */\n    worldVisible: {\n        get: function ()\n        {\n            var item = this;\n\n            do {\n                if (!item.visible)\n                {\n                    return false;\n                }\n\n                item = item.parent;\n            } while (item);\n\n            return true;\n        }\n    },\n\n    /**\n     * Sets a mask for the displayObject. A mask is an object that limits the visibility of an object to the shape of the mask applied to it.\n     * In PIXI a regular mask must be a PIXI.Graphics object. This allows for much faster masking in canvas as it utilises shape clipping.\n     * To remove a mask, set this property to null.\n     *\n     * @member {Graphics}\n     * @memberof PIXI.DisplayObject#\n     */\n    mask: {\n        get: function ()\n        {\n            return this._mask;\n        },\n        set: function (value)\n        {\n            if (this._mask)\n            {\n                this._mask.renderable = true;\n            }\n\n            this._mask = value;\n\n            if (this._mask)\n            {\n                this._mask.renderable = false;\n            }\n        }\n    },\n\n    /**\n     * Sets the filters for the displayObject.\n     * * IMPORTANT: This is a webGL only feature and will be ignored by the canvas renderer.\n     * To remove filters simply set this property to 'null'\n     *\n     * @member {Filter[]}\n     * @memberof PIXI.DisplayObject#\n     */\n    filters: {\n        get: function ()\n        {\n            return this._filters && this._filters.slice();\n        },\n        set: function (value)\n        {\n            this._filters = value && value.slice();\n        }\n    }\n\n});\n\n/*\n * Updates the object transform for rendering\n *\n * TODO - Optimization pass!\n */\nDisplayObject.prototype.updateTransform = function ()\n{\n\n    // create some matrix refs for easy access\n    var pt = this.parent.worldTransform;\n    var wt = this.worldTransform;\n\n    // temporary matrix variables\n    var a, b, c, d, tx, ty;\n\n    // so if rotation is between 0 then we can simplify the multiplication process...\n    if (this.rotation % CONST.PI_2)\n    {\n        // check to see if the rotation is the same as the previous render. This means we only need to use sin and cos when rotation actually changes\n        if (this.rotation !== this.rotationCache)\n        {\n            this.rotationCache = this.rotation;\n            this._sr = Math.sin(this.rotation);\n            this._cr = Math.cos(this.rotation);\n        }\n\n        // get the matrix values of the displayobject based on its transform properties..\n        a  =  this._cr * this.scale.x;\n        b  =  this._sr * this.scale.x;\n        c  = -this._sr * this.scale.y;\n        d  =  this._cr * this.scale.y;\n        tx =  this.position.x;\n        ty =  this.position.y;\n\n        // check for pivot.. not often used so geared towards that fact!\n        if (this.pivot.x || this.pivot.y)\n        {\n            tx -= this.pivot.x * a + this.pivot.y * c;\n            ty -= this.pivot.x * b + this.pivot.y * d;\n        }\n\n        // concat the parent matrix with the objects transform.\n        wt.a  = a  * pt.a + b  * pt.c;\n        wt.b  = a  * pt.b + b  * pt.d;\n        wt.c  = c  * pt.a + d  * pt.c;\n        wt.d  = c  * pt.b + d  * pt.d;\n        wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n        wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n    }\n    else\n    {\n        // lets do the fast version as we know there is no rotation..\n        a  = this.scale.x;\n        d  = this.scale.y;\n\n        tx = this.position.x - this.pivot.x * a;\n        ty = this.position.y - this.pivot.y * d;\n\n        wt.a  = a  * pt.a;\n        wt.b  = a  * pt.b;\n        wt.c  = d  * pt.c;\n        wt.d  = d  * pt.d;\n        wt.tx = tx * pt.a + ty * pt.c + pt.tx;\n        wt.ty = tx * pt.b + ty * pt.d + pt.ty;\n    }\n\n    // multiply the alphas..\n    this.worldAlpha = this.alpha * this.parent.worldAlpha;\n\n    // reset the bounds each time this is called!\n    this._currentBounds = null;\n};\n\n// performance increase to avoid using call.. (10x faster)\nDisplayObject.prototype.displayObjectUpdateTransform = DisplayObject.prototype.updateTransform;\n\n/**\n *\n *\n * Retrieves the bounds of the displayObject as a rectangle object\n *\n * @param matrix {Matrix}\n * @return {Rectangle} the rectangular bounding area\n */\nDisplayObject.prototype.getBounds = function (matrix) // jshint unused:false\n{\n    return math.Rectangle.EMPTY;\n};\n\n/**\n * Retrieves the local bounds of the displayObject as a rectangle object\n *\n * @return {Rectangle} the rectangular bounding area\n */\nDisplayObject.prototype.getLocalBounds = function ()\n{\n    return this.getBounds(math.Matrix.IDENTITY);\n};\n\n/**\n * Calculates the global position of the display object\n *\n * @param position {Point} The world origin to calculate from\n * @return {Point} A point object representing the position of this object\n */\nDisplayObject.prototype.toGlobal = function (position)\n{\n    // don't need to update the lot\n    this.displayObjectUpdateTransform();\n    return this.worldTransform.apply(position);\n};\n\n/**\n * Calculates the local position of the display object relative to another point\n *\n * @param position {Point} The world origin to calculate from\n * @param [from] {DisplayObject} The DisplayObject to calculate the global position from\n * @return {Point} A point object representing the position of this object\n */\nDisplayObject.prototype.toLocal = function (position, from)\n{\n    if (from)\n    {\n        position = from.toGlobal(position);\n    }\n\n    // don't need to update the lot\n    this.displayObjectUpdateTransform();\n    return this.worldTransform.applyInverse(position);\n};\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer} The renderer\n * @private\n */\nDisplayObject.prototype.renderWebGL = function (renderer) // jshint unused:false\n{\n    // OVERWRITE;\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer} The renderer\n * @private\n */\nDisplayObject.prototype.renderCanvas = function (renderer) // jshint unused:false\n{\n    // OVERWRITE;\n};\n/**\n * Useful function that returns a texture of the display object that can then be used to create sprites\n * This can be quite useful if your displayObject is static / complicated and needs to be reused multiple times.\n *\n * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used to generate the texture.\n * @param scaleMode {Number} See {@link SCALE_MODES} for possible values\n * @param resolution {Number} The resolution of the texture being generated\n * @return {Texture} a texture of the display object\n */\nDisplayObject.prototype.generateTexture = function (renderer, scaleMode, resolution)\n{\n    var bounds = this.getLocalBounds();\n\n    var renderTexture = new RenderTexture(renderer, bounds.width | 0, bounds.height | 0, scaleMode, resolution);\n\n    _tempMatrix.tx = -bounds.x;\n    _tempMatrix.ty = -bounds.y;\n\n    renderTexture.render(this, _tempMatrix);\n\n    return renderTexture;\n};\n\n/**\n * Base destroy method for generic display objects\n *\n */\nDisplayObject.prototype.destroy = function ()\n{\n\n    this.position = null;\n    this.scale = null;\n    this.pivot = null;\n\n    this.parent = null;\n\n    this._bounds = null;\n    this._currentBounds = null;\n    this._mask = null;\n\n    this.worldTransform = null;\n    this.filterArea = null;\n};\n"]},"metadata":{},"sourceType":"script"}