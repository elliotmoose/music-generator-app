{"ast":null,"code":"var math = require('../math'),\n    Texture = require('../textures/Texture'),\n    Container = require('../display/Container'),\n    CanvasTinter = require('../renderers/canvas/utils/CanvasTinter'),\n    utils = require('../utils'),\n    CONST = require('../const'),\n    tempPoint = new math.Point();\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * var sprite = new PIXI.Sprite.fromImage('assets/image.png');\n * ```\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n * @param texture {Texture} The texture for this sprite\n */\n\n\nfunction Sprite(texture) {\n  Container.call(this);\n  /**\n   * The anchor sets the origin point of the texture.\n   * The default is 0,0 this means the texture's origin is the top left\n   * Setting the anchor to 0.5,0.5 means the texture's origin is centered\n   * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner\n   *\n   * @member {Point}\n   */\n\n  this.anchor = new math.Point();\n  /**\n   * The texture that the sprite is using\n   *\n   * @member {Texture}\n   * @private\n   */\n\n  this._texture = null;\n  /**\n   * The width of the sprite (this is initially set by the texture)\n   *\n   * @member {number}\n   * @private\n   */\n\n  this._width = 0;\n  /**\n   * The height of the sprite (this is initially set by the texture)\n   *\n   * @member {number}\n   * @private\n   */\n\n  this._height = 0;\n  /**\n   * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n   *\n   * @member {number}\n   * @default [0xFFFFFF]\n   */\n\n  this.tint = 0xFFFFFF;\n  /**\n   * The blend mode to be applied to the sprite. Apply a value of blendModes.NORMAL to reset the blend mode.\n   *\n   * @member {number}\n   * @default CONST.BLEND_MODES.NORMAL;\n   */\n\n  this.blendMode = CONST.BLEND_MODES.NORMAL;\n  /**\n   * The shader that will be used to render the sprite. Set to null to remove a current shader.\n   *\n   * @member {AbstractFilter}\n   */\n\n  this.shader = null;\n  /**\n   * An internal cached value of the tint.\n   *\n   * @member {number}\n   * @default [0xFFFFFF]\n   */\n\n  this.cachedTint = 0xFFFFFF; // call texture setter\n\n  this.texture = texture || Texture.EMPTY;\n} // constructor\n\n\nSprite.prototype = Object.create(Container.prototype);\nSprite.prototype.constructor = Sprite;\nmodule.exports = Sprite;\nObject.defineProperties(Sprite.prototype, {\n  /**\n   * The width of the sprite, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   * @memberof PIXI.Sprite#\n   */\n  width: {\n    get: function () {\n      return this.scale.x * this.texture._frame.width;\n    },\n    set: function (value) {\n      this.scale.x = value / this.texture._frame.width;\n      this._width = value;\n    }\n  },\n\n  /**\n   * The height of the sprite, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   * @memberof PIXI.Sprite#\n   */\n  height: {\n    get: function () {\n      return this.scale.y * this.texture._frame.height;\n    },\n    set: function (value) {\n      this.scale.y = value / this.texture._frame.height;\n      this._height = value;\n    }\n  },\n\n  /**\n   * The texture that the sprite is using\n   *\n   * @member {PIXI.Texture}\n   * @memberof PIXI.Sprite#\n   */\n  texture: {\n    get: function () {\n      return this._texture;\n    },\n    set: function (value) {\n      if (this._texture === value) {\n        return;\n      }\n\n      this._texture = value;\n      this.cachedTint = 0xFFFFFF;\n\n      if (value) {\n        // wait for the texture to load\n        if (value.baseTexture.hasLoaded) {\n          this._onTextureUpdate();\n        } else {\n          value.once('update', this._onTextureUpdate, this);\n        }\n      }\n    }\n  }\n});\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @private\n */\n\nSprite.prototype._onTextureUpdate = function () {\n  // so if _width is 0 then width was not set..\n  if (this._width) {\n    this.scale.x = this._width / this.texture.frame.width;\n  }\n\n  if (this._height) {\n    this.scale.y = this._height / this.texture.frame.height;\n  }\n};\n/**\n*\n* Renders the object using the WebGL renderer\n*\n* @param renderer {WebGLRenderer}\n* @private\n*/\n\n\nSprite.prototype._renderWebGL = function (renderer) {\n  renderer.setObjectRenderer(renderer.plugins.sprite);\n  renderer.plugins.sprite.render(this);\n};\n/**\n * Returns the bounds of the Sprite as a rectangle. The bounds calculation takes the worldTransform into account.\n *\n * @param matrix {Matrix} the transformation matrix of the sprite\n * @return {Rectangle} the framing rectangle\n */\n\n\nSprite.prototype.getBounds = function (matrix) {\n  if (!this._currentBounds) {\n    var width = this._texture._frame.width;\n    var height = this._texture._frame.height;\n    var w0 = width * (1 - this.anchor.x);\n    var w1 = width * -this.anchor.x;\n    var h0 = height * (1 - this.anchor.y);\n    var h1 = height * -this.anchor.y;\n    var worldTransform = matrix || this.worldTransform;\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n    var minX, maxX, minY, maxY;\n\n    if (b === 0 && c === 0) {\n      // scale may be negative!\n      if (a < 0) {\n        a *= -1;\n      }\n\n      if (d < 0) {\n        d *= -1;\n      } // this means there is no rotation going on right? RIGHT?\n      // if thats the case then we can avoid checking the bound values! yay\n\n\n      minX = a * w1 + tx;\n      maxX = a * w0 + tx;\n      minY = d * h1 + ty;\n      maxY = d * h0 + ty;\n    } else {\n      var x1 = a * w1 + c * h1 + tx;\n      var y1 = d * h1 + b * w1 + ty;\n      var x2 = a * w0 + c * h1 + tx;\n      var y2 = d * h1 + b * w0 + ty;\n      var x3 = a * w0 + c * h0 + tx;\n      var y3 = d * h0 + b * w0 + ty;\n      var x4 = a * w1 + c * h0 + tx;\n      var y4 = d * h0 + b * w1 + ty;\n      minX = x1;\n      minX = x2 < minX ? x2 : minX;\n      minX = x3 < minX ? x3 : minX;\n      minX = x4 < minX ? x4 : minX;\n      minY = y1;\n      minY = y2 < minY ? y2 : minY;\n      minY = y3 < minY ? y3 : minY;\n      minY = y4 < minY ? y4 : minY;\n      maxX = x1;\n      maxX = x2 > maxX ? x2 : maxX;\n      maxX = x3 > maxX ? x3 : maxX;\n      maxX = x4 > maxX ? x4 : maxX;\n      maxY = y1;\n      maxY = y2 > maxY ? y2 : maxY;\n      maxY = y3 > maxY ? y3 : maxY;\n      maxY = y4 > maxY ? y4 : maxY;\n    } // check for children\n\n\n    if (this.children.length) {\n      var childBounds = this.containerGetBounds();\n      w0 = childBounds.x;\n      w1 = childBounds.x + childBounds.width;\n      h0 = childBounds.y;\n      h1 = childBounds.y + childBounds.height;\n      minX = minX < w0 ? minX : w0;\n      minY = minY < h0 ? minY : h0;\n      maxX = maxX > w1 ? maxX : w1;\n      maxY = maxY > h1 ? maxY : h1;\n    }\n\n    var bounds = this._bounds;\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n    bounds.y = minY;\n    bounds.height = maxY - minY; // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n\n    this._currentBounds = bounds;\n  }\n\n  return this._currentBounds;\n};\n\nSprite.prototype.getLocalBounds = function () {\n  this._bounds.x = -this._texture._frame.width * this.anchor.x;\n  this._bounds.y = -this._texture._frame.height * this.anchor.y;\n  this._bounds.width = this._texture._frame.width;\n  this._bounds.height = this._texture._frame.height;\n  return this._bounds;\n};\n/**\n* Tests if a point is inside this sprite\n*\n* @param point {Point} the point to test\n* @return {boolean} the result of the test\n*/\n\n\nSprite.prototype.containsPoint = function (point) {\n  this.worldTransform.applyInverse(point, tempPoint);\n  var width = this._texture._frame.width;\n  var height = this._texture._frame.height;\n  var x1 = -width * this.anchor.x;\n  var y1;\n\n  if (tempPoint.x > x1 && tempPoint.x < x1 + width) {\n    y1 = -height * this.anchor.y;\n\n    if (tempPoint.y > y1 && tempPoint.y < y1 + height) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n* Renders the object using the Canvas renderer\n*\n* @param renderer {CanvasRenderer} The renderer\n* @private\n*/\n\n\nSprite.prototype._renderCanvas = function (renderer) {\n  if (this.texture.crop.width <= 0 || this.texture.crop.height <= 0) {\n    return;\n  }\n\n  if (this.blendMode !== renderer.currentBlendMode) {\n    renderer.currentBlendMode = this.blendMode;\n    renderer.context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];\n  } //  Ignore null sources\n\n\n  if (this.texture.valid) {\n    var texture = this._texture,\n        wt = this.worldTransform,\n        dx,\n        dy,\n        width,\n        height;\n    renderer.context.globalAlpha = this.worldAlpha; // If smoothingEnabled is supported and we need to change the smoothing property for this texture\n\n    if (renderer.smoothProperty && renderer.currentScaleMode !== texture.baseTexture.scaleMode) {\n      renderer.currentScaleMode = texture.baseTexture.scaleMode;\n      renderer.context[renderer.smoothProperty] = renderer.currentScaleMode === CONST.SCALE_MODES.LINEAR;\n    } // If the texture is trimmed we offset by the trim x/y, otherwise we use the frame dimensions\n\n\n    if (texture.rotate) {\n      // cheeky rotation!\n      var a = wt.a;\n      var b = wt.b;\n      wt.a = -wt.c;\n      wt.b = -wt.d;\n      wt.c = a;\n      wt.d = b;\n      width = texture.crop.height;\n      height = texture.crop.width;\n      dx = texture.trim ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;\n      dy = texture.trim ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;\n    } else {\n      width = texture.crop.width;\n      height = texture.crop.height;\n      dx = texture.trim ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;\n      dy = texture.trim ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;\n    } // Allow for pixel rounding\n\n\n    if (renderer.roundPixels) {\n      renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution | 0, wt.ty * renderer.resolution | 0);\n      dx = dx | 0;\n      dy = dy | 0;\n    } else {\n      renderer.context.setTransform(wt.a, wt.b, wt.c, wt.d, wt.tx * renderer.resolution, wt.ty * renderer.resolution);\n    }\n\n    var resolution = texture.baseTexture.resolution;\n\n    if (this.tint !== 0xFFFFFF) {\n      if (this.cachedTint !== this.tint) {\n        this.cachedTint = this.tint; // TODO clean up caching - how to clean up the caches?\n\n        this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);\n      }\n\n      renderer.context.drawImage(this.tintedTexture, 0, 0, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);\n    } else {\n      renderer.context.drawImage(texture.baseTexture.source, texture.crop.x * resolution, texture.crop.y * resolution, width * resolution, height * resolution, dx * renderer.resolution, dy * renderer.resolution, width * renderer.resolution, height * renderer.resolution);\n    }\n  }\n};\n/**\n * Destroys this sprite and optionally its texture\n *\n * @param [destroyTexture=false] {boolean} Should it destroy the current texture of the sprite as well\n * @param [destroyBaseTexture=false] {boolean} Should it destroy the base texture of the sprite as well\n */\n\n\nSprite.prototype.destroy = function (destroyTexture, destroyBaseTexture) {\n  Container.prototype.destroy.call(this);\n  this.anchor = null;\n\n  if (destroyTexture) {\n    this._texture.destroy(destroyBaseTexture);\n  }\n\n  this._texture = null;\n  this.shader = null;\n}; // some helper functions..\n\n/**\n * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @static\n * @param frameId {String} The frame Id of the texture in the cache\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId\n * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter\n * @param [scaleMode=scaleModes.DEFAULT] {number} if you want to specify the scale mode, see {@link SCALE_MODES} for possible values\n */\n\n\nSprite.fromFrame = function (frameId) {\n  var texture = utils.TextureCache[frameId];\n\n  if (!texture) {\n    throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache');\n  }\n\n  return new Sprite(texture);\n};\n/**\n * Helper function that creates a sprite that will contain a texture based on an image url\n * If the image is not in the texture cache it will be loaded\n *\n * @static\n * @param imageId {String} The image url of the texture\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id\n */\n\n\nSprite.fromImage = function (imageId, crossorigin, scaleMode) {\n  return new Sprite(Texture.fromImage(imageId, crossorigin, scaleMode));\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/sprites/Sprite.js"],"names":["math","require","Texture","Container","CanvasTinter","utils","CONST","tempPoint","Point","Sprite","texture","call","anchor","_texture","_width","_height","tint","blendMode","BLEND_MODES","NORMAL","shader","cachedTint","EMPTY","prototype","Object","create","constructor","module","exports","defineProperties","width","get","scale","x","_frame","set","value","height","y","baseTexture","hasLoaded","_onTextureUpdate","once","frame","_renderWebGL","renderer","setObjectRenderer","plugins","sprite","render","getBounds","matrix","_currentBounds","w0","w1","h0","h1","worldTransform","a","b","c","d","tx","ty","minX","maxX","minY","maxY","x1","y1","x2","y2","x3","y3","x4","y4","children","length","childBounds","containerGetBounds","bounds","_bounds","getLocalBounds","containsPoint","point","applyInverse","_renderCanvas","crop","currentBlendMode","context","globalCompositeOperation","blendModes","valid","wt","dx","dy","globalAlpha","worldAlpha","smoothProperty","currentScaleMode","scaleMode","SCALE_MODES","LINEAR","rotate","trim","roundPixels","setTransform","resolution","tintedTexture","getTintedTexture","drawImage","source","destroy","destroyTexture","destroyBaseTexture","fromFrame","frameId","TextureCache","Error","fromImage","imageId","crossorigin"],"mappings":"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","sourcesContent":["var math = require('../math'),\n    Texture = require('../textures/Texture'),\n    Container = require('../display/Container'),\n    CanvasTinter = require('../renderers/canvas/utils/CanvasTinter'),\n    utils = require('../utils'),\n    CONST = require('../const'),\n    tempPoint = new math.Point();\n\n/**\n * The Sprite object is the base for all textured objects that are rendered to the screen\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * var sprite = new PIXI.Sprite.fromImage('assets/image.png');\n * ```\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n * @param texture {Texture} The texture for this sprite\n */\nfunction Sprite(texture)\n{\n    Container.call(this);\n\n    /**\n     * The anchor sets the origin point of the texture.\n     * The default is 0,0 this means the texture's origin is the top left\n     * Setting the anchor to 0.5,0.5 means the texture's origin is centered\n     * Setting the anchor to 1,1 would mean the texture's origin point will be the bottom right corner\n     *\n     * @member {Point}\n     */\n    this.anchor = new math.Point();\n\n    /**\n     * The texture that the sprite is using\n     *\n     * @member {Texture}\n     * @private\n     */\n    this._texture = null;\n\n    /**\n     * The width of the sprite (this is initially set by the texture)\n     *\n     * @member {number}\n     * @private\n     */\n    this._width = 0;\n\n    /**\n     * The height of the sprite (this is initially set by the texture)\n     *\n     * @member {number}\n     * @private\n     */\n    this._height = 0;\n\n    /**\n     * The tint applied to the sprite. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @default [0xFFFFFF]\n     */\n    this.tint = 0xFFFFFF;\n\n    /**\n     * The blend mode to be applied to the sprite. Apply a value of blendModes.NORMAL to reset the blend mode.\n     *\n     * @member {number}\n     * @default CONST.BLEND_MODES.NORMAL;\n     */\n    this.blendMode = CONST.BLEND_MODES.NORMAL;\n\n    /**\n     * The shader that will be used to render the sprite. Set to null to remove a current shader.\n     *\n     * @member {AbstractFilter}\n     */\n    this.shader = null;\n\n    /**\n     * An internal cached value of the tint.\n     *\n     * @member {number}\n     * @default [0xFFFFFF]\n     */\n    this.cachedTint = 0xFFFFFF;\n\n    // call texture setter\n    this.texture = texture || Texture.EMPTY;\n}\n\n// constructor\nSprite.prototype = Object.create(Container.prototype);\nSprite.prototype.constructor = Sprite;\nmodule.exports = Sprite;\n\nObject.defineProperties(Sprite.prototype, {\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.Sprite#\n     */\n    width: {\n        get: function ()\n        {\n            return this.scale.x * this.texture._frame.width;\n        },\n        set: function (value)\n        {\n            this.scale.x = value / this.texture._frame.width;\n            this._width = value;\n        }\n    },\n\n    /**\n     * The height of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof PIXI.Sprite#\n     */\n    height: {\n        get: function ()\n        {\n            return  this.scale.y * this.texture._frame.height;\n        },\n        set: function (value)\n        {\n            this.scale.y = value / this.texture._frame.height;\n            this._height = value;\n        }\n    },\n\n    /**\n     * The texture that the sprite is using\n     *\n     * @member {PIXI.Texture}\n     * @memberof PIXI.Sprite#\n     */\n    texture: {\n        get: function ()\n        {\n            return  this._texture;\n        },\n        set: function (value)\n        {\n            if (this._texture === value)\n            {\n                return;\n            }\n\n            this._texture = value;\n            this.cachedTint = 0xFFFFFF;\n\n            if (value)\n            {\n                // wait for the texture to load\n                if (value.baseTexture.hasLoaded)\n                {\n                    this._onTextureUpdate();\n                }\n                else\n                {\n                    value.once('update', this._onTextureUpdate, this);\n                }\n            }\n        }\n    }\n});\n\n/**\n * When the texture is updated, this event will fire to update the scale and frame\n *\n * @private\n */\nSprite.prototype._onTextureUpdate = function ()\n{\n    // so if _width is 0 then width was not set..\n    if (this._width)\n    {\n        this.scale.x = this._width / this.texture.frame.width;\n    }\n\n    if (this._height)\n    {\n        this.scale.y = this._height / this.texture.frame.height;\n    }\n};\n\n/**\n*\n* Renders the object using the WebGL renderer\n*\n* @param renderer {WebGLRenderer}\n* @private\n*/\nSprite.prototype._renderWebGL = function (renderer)\n{\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    renderer.plugins.sprite.render(this);\n};\n\n/**\n * Returns the bounds of the Sprite as a rectangle. The bounds calculation takes the worldTransform into account.\n *\n * @param matrix {Matrix} the transformation matrix of the sprite\n * @return {Rectangle} the framing rectangle\n */\nSprite.prototype.getBounds = function (matrix)\n{\n    if(!this._currentBounds)\n    {\n\n        var width = this._texture._frame.width;\n        var height = this._texture._frame.height;\n\n        var w0 = width * (1-this.anchor.x);\n        var w1 = width * -this.anchor.x;\n\n        var h0 = height * (1-this.anchor.y);\n        var h1 = height * -this.anchor.y;\n\n        var worldTransform = matrix || this.worldTransform ;\n\n        var a = worldTransform.a;\n        var b = worldTransform.b;\n        var c = worldTransform.c;\n        var d = worldTransform.d;\n        var tx = worldTransform.tx;\n        var ty = worldTransform.ty;\n\n        var minX,\n            maxX,\n            minY,\n            maxY;\n\n\n        if (b === 0 && c === 0)\n        {\n            // scale may be negative!\n            if (a < 0)\n            {\n                a *= -1;\n            }\n\n            if (d < 0)\n            {\n                d *= -1;\n            }\n\n            // this means there is no rotation going on right? RIGHT?\n            // if thats the case then we can avoid checking the bound values! yay\n            minX = a * w1 + tx;\n            maxX = a * w0 + tx;\n            minY = d * h1 + ty;\n            maxY = d * h0 + ty;\n        }\n        else\n        {\n            var x1 = a * w1 + c * h1 + tx;\n            var y1 = d * h1 + b * w1 + ty;\n\n            var x2 = a * w0 + c * h1 + tx;\n            var y2 = d * h1 + b * w0 + ty;\n\n            var x3 = a * w0 + c * h0 + tx;\n            var y3 = d * h0 + b * w0 + ty;\n\n            var x4 =  a * w1 + c * h0 + tx;\n            var y4 =  d * h0 + b * w1 + ty;\n\n            minX = x1;\n            minX = x2 < minX ? x2 : minX;\n            minX = x3 < minX ? x3 : minX;\n            minX = x4 < minX ? x4 : minX;\n\n            minY = y1;\n            minY = y2 < minY ? y2 : minY;\n            minY = y3 < minY ? y3 : minY;\n            minY = y4 < minY ? y4 : minY;\n\n            maxX = x1;\n            maxX = x2 > maxX ? x2 : maxX;\n            maxX = x3 > maxX ? x3 : maxX;\n            maxX = x4 > maxX ? x4 : maxX;\n\n            maxY = y1;\n            maxY = y2 > maxY ? y2 : maxY;\n            maxY = y3 > maxY ? y3 : maxY;\n            maxY = y4 > maxY ? y4 : maxY;\n        }\n\n        // check for children\n        if(this.children.length)\n        {\n            var childBounds = this.containerGetBounds();\n\n            w0 = childBounds.x;\n            w1 = childBounds.x + childBounds.width;\n            h0 = childBounds.y;\n            h1 = childBounds.y + childBounds.height;\n\n            minX = (minX < w0) ? minX : w0;\n            minY = (minY < h0) ? minY : h0;\n\n            maxX = (maxX > w1) ? maxX : w1;\n            maxY = (maxY > h1) ? maxY : h1;\n        }\n\n        var bounds = this._bounds;\n\n        bounds.x = minX;\n        bounds.width = maxX - minX;\n\n        bounds.y = minY;\n        bounds.height = maxY - minY;\n\n        // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n        this._currentBounds = bounds;\n    }\n\n    return this._currentBounds;\n};\n\nSprite.prototype.getLocalBounds = function ()\n{\n    this._bounds.x = -this._texture._frame.width * this.anchor.x;\n    this._bounds.y = -this._texture._frame.height * this.anchor.y;\n    this._bounds.width = this._texture._frame.width;\n    this._bounds.height = this._texture._frame.height;\n    return this._bounds;\n};\n\n/**\n* Tests if a point is inside this sprite\n*\n* @param point {Point} the point to test\n* @return {boolean} the result of the test\n*/\nSprite.prototype.containsPoint = function( point )\n{\n    this.worldTransform.applyInverse(point,  tempPoint);\n\n    var width = this._texture._frame.width;\n    var height = this._texture._frame.height;\n    var x1 = -width * this.anchor.x;\n    var y1;\n\n    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )\n    {\n        y1 = -height * this.anchor.y;\n\n        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )\n        {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n/**\n* Renders the object using the Canvas renderer\n*\n* @param renderer {CanvasRenderer} The renderer\n* @private\n*/\nSprite.prototype._renderCanvas = function (renderer)\n{\n    if (this.texture.crop.width <= 0 || this.texture.crop.height <= 0)\n    {\n        return;\n    }\n\n    if (this.blendMode !== renderer.currentBlendMode)\n    {\n        renderer.currentBlendMode = this.blendMode;\n        renderer.context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];\n    }\n\n    //  Ignore null sources\n    if (this.texture.valid)\n    {\n        var texture = this._texture,\n            wt = this.worldTransform,\n            dx,\n            dy,\n            width,\n            height;\n\n        renderer.context.globalAlpha = this.worldAlpha;\n\n        // If smoothingEnabled is supported and we need to change the smoothing property for this texture\n        if (renderer.smoothProperty && renderer.currentScaleMode !== texture.baseTexture.scaleMode)\n        {\n            renderer.currentScaleMode = texture.baseTexture.scaleMode;\n            renderer.context[renderer.smoothProperty] = (renderer.currentScaleMode === CONST.SCALE_MODES.LINEAR);\n        }\n\n        // If the texture is trimmed we offset by the trim x/y, otherwise we use the frame dimensions\n\n        if(texture.rotate)\n        {\n\n            // cheeky rotation!\n            var a = wt.a;\n            var b = wt.b;\n\n            wt.a  = -wt.c;\n            wt.b  = -wt.d;\n            wt.c  =  a;\n            wt.d  =  b;\n\n            width = texture.crop.height;\n            height = texture.crop.width;\n\n            dx = (texture.trim) ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;\n            dy = (texture.trim) ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;\n        }\n        else\n        {\n            width = texture.crop.width;\n            height = texture.crop.height;\n\n            dx = (texture.trim) ? texture.trim.x - this.anchor.x * texture.trim.width : this.anchor.x * -texture._frame.width;\n            dy = (texture.trim) ? texture.trim.y - this.anchor.y * texture.trim.height : this.anchor.y * -texture._frame.height;\n        }\n\n\n\n        // Allow for pixel rounding\n        if (renderer.roundPixels)\n        {\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                (wt.tx * renderer.resolution) | 0,\n                (wt.ty * renderer.resolution) | 0\n            );\n\n            dx = dx | 0;\n            dy = dy | 0;\n        }\n        else\n        {\n\n            renderer.context.setTransform(\n                wt.a,\n                wt.b,\n                wt.c,\n                wt.d,\n                wt.tx * renderer.resolution,\n                wt.ty * renderer.resolution\n            );\n\n\n        }\n\n        var resolution = texture.baseTexture.resolution;\n\n        if (this.tint !== 0xFFFFFF)\n        {\n            if (this.cachedTint !== this.tint)\n            {\n                this.cachedTint = this.tint;\n\n                // TODO clean up caching - how to clean up the caches?\n                this.tintedTexture = CanvasTinter.getTintedTexture(this, this.tint);\n            }\n\n            renderer.context.drawImage(\n                this.tintedTexture,\n                0,\n                0,\n                width * resolution,\n                height * resolution,\n                dx * renderer.resolution,\n                dy * renderer.resolution,\n                width * renderer.resolution,\n                height * renderer.resolution\n            );\n        }\n        else\n        {\n            renderer.context.drawImage(\n                texture.baseTexture.source,\n                texture.crop.x * resolution,\n                texture.crop.y * resolution,\n                width * resolution,\n                height * resolution,\n                dx  * renderer.resolution,\n                dy  * renderer.resolution,\n                width * renderer.resolution,\n                height * renderer.resolution\n            );\n        }\n    }\n};\n\n/**\n * Destroys this sprite and optionally its texture\n *\n * @param [destroyTexture=false] {boolean} Should it destroy the current texture of the sprite as well\n * @param [destroyBaseTexture=false] {boolean} Should it destroy the base texture of the sprite as well\n */\nSprite.prototype.destroy = function (destroyTexture, destroyBaseTexture)\n{\n    Container.prototype.destroy.call(this);\n\n    this.anchor = null;\n\n    if (destroyTexture)\n    {\n        this._texture.destroy(destroyBaseTexture);\n    }\n\n    this._texture = null;\n    this.shader = null;\n};\n\n// some helper functions..\n\n/**\n * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @static\n * @param frameId {String} The frame Id of the texture in the cache\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the frameId\n * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter\n * @param [scaleMode=scaleModes.DEFAULT] {number} if you want to specify the scale mode, see {@link SCALE_MODES} for possible values\n */\nSprite.fromFrame = function (frameId)\n{\n    var texture = utils.TextureCache[frameId];\n\n    if (!texture)\n    {\n        throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache');\n    }\n\n    return new Sprite(texture);\n};\n\n/**\n * Helper function that creates a sprite that will contain a texture based on an image url\n * If the image is not in the texture cache it will be loaded\n *\n * @static\n * @param imageId {String} The image url of the texture\n * @return {Sprite} A new Sprite using a texture from the texture cache matching the image id\n */\nSprite.fromImage = function (imageId, crossorigin, scaleMode)\n{\n    return new Sprite(Texture.fromImage(imageId, crossorigin, scaleMode));\n};\n"]},"metadata":{},"sourceType":"script"}