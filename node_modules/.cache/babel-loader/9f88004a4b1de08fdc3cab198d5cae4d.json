{"ast":null,"code":"import { AutomationEventList } from 'automation-events';\nexport var createAudioParamFactory = function createAudioParamFactory(addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor) {\n  return function (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam) {\n    var maxValue = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var minValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    var automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n    var audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n    var audioParam = {\n      get defaultValue() {\n        return nativeAudioParam.defaultValue;\n      },\n\n      get maxValue() {\n        return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n      },\n\n      get minValue() {\n        return minValue === null ? nativeAudioParam.minValue : minValue;\n      },\n\n      get value() {\n        return nativeAudioParam.value;\n      },\n\n      set value(value) {\n        nativeAudioParam.value = value; // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n\n        audioParam.setValueAtTime(value, audioNode.context.currentTime);\n      },\n\n      cancelAndHoldAtTime: function cancelAndHoldAtTime(cancelTime) {\n        // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n        if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n        } else {\n          var previousLastEvent = Array.from(automationEventList).pop();\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n          var currentLastEvent = Array.from(automationEventList).pop();\n          nativeAudioParam.cancelScheduledValues(cancelTime);\n\n          if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n            if (currentLastEvent.type === 'exponentialRampToValue') {\n              nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'linearRampToValue') {\n              nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n            } else if (currentLastEvent.type === 'setValue') {\n              nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n            } else if (currentLastEvent.type === 'setValueCurve') {\n              nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n            }\n          }\n        }\n\n        return audioParam;\n      },\n      cancelScheduledValues: function cancelScheduledValues(cancelTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n        nativeAudioParam.cancelScheduledValues(cancelTime);\n        return audioParam;\n      },\n      exponentialRampToValueAtTime: function exponentialRampToValueAtTime(value, endTime) {\n        // Bug #45: Safari does not throw an error yet.\n        if (value === 0) {\n          throw new RangeError();\n        } // Bug #187: Safari does not throw an error yet.\n\n\n        if (!Number.isFinite(endTime) || endTime < 0) {\n          throw new RangeError();\n        }\n\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n      linearRampToValueAtTime: function linearRampToValueAtTime(value, endTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n        nativeAudioParam.linearRampToValueAtTime(value, endTime);\n        return audioParam;\n      },\n      setTargetAtTime: function setTargetAtTime(target, startTime, timeConstant) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n        nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n        return audioParam;\n      },\n      setValueAtTime: function setValueAtTime(value, startTime) {\n        if (audioParamRenderer === null) {\n          automationEventList.flush(audioNode.context.currentTime);\n        }\n\n        automationEventList.add(createSetValueAutomationEvent(value, startTime));\n        nativeAudioParam.setValueAtTime(value, startTime);\n        return audioParam;\n      },\n      setValueCurveAtTime: function setValueCurveAtTime(values, startTime, duration) {\n        // Bug 183: Safari only accepts a Float32Array.\n        var convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n        /*\n         * Bug #152: Safari does not correctly interpolate the values of the curve.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n         * existence of the webkitAudioContext is used as a workaround here.\n         */\n\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n          var endTime = startTime + duration;\n          var sampleRate = audioNode.context.sampleRate;\n          var firstSample = Math.ceil(startTime * sampleRate);\n          var lastSample = Math.floor(endTime * sampleRate);\n          var numberOfInterpolatedValues = lastSample - firstSample;\n          var interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n          for (var i = 0; i < numberOfInterpolatedValues; i += 1) {\n            var theoreticIndex = (convertedValues.length - 1) / duration * ((firstSample + i) / sampleRate - startTime);\n            var lowerIndex = Math.floor(theoreticIndex);\n            var upperIndex = Math.ceil(theoreticIndex);\n            interpolatedValues[i] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n          }\n\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n          var timeOfLastSample = lastSample / sampleRate;\n\n          if (timeOfLastSample < endTime) {\n            audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n          }\n\n          audioParam.setValueAtTime(convertedValues[convertedValues.length - 1], endTime);\n        } else {\n          if (audioParamRenderer === null) {\n            automationEventList.flush(audioNode.context.currentTime);\n          }\n\n          automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n          nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n        }\n\n        return audioParam;\n      }\n    };\n    audioParamStore.set(audioParam, nativeAudioParam);\n    audioParamAudioNodeStore.set(audioParam, audioNode);\n    addAudioParamConnections(audioParam, audioParamRenderer);\n    return audioParam;\n  };\n};","map":{"version":3,"sources":["../../../src/factories/audio-param-factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { AutomationEventList } from 'automation-events';\nexport const createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore, audioParamStore, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor) => {\n    return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {\n        const automationEventList = new AutomationEventList(nativeAudioParam.defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue() {\n                return nativeAudioParam.defaultValue;\n            },\n            get maxValue() {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue() {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value() {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime) {\n                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                }\n                else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    const currentLastEvent = Array.from(automationEventList).pop();\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        }\n                        else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        }\n                        else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);\n                        }\n                    }\n                }\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value, endTime) {\n                // Bug #45: Safari does not throw an error yet.\n                if (value === 0) {\n                    throw new RangeError();\n                }\n                // Bug #187: Safari does not throw an error yet.\n                if (!Number.isFinite(endTime) || endTime < 0) {\n                    throw new RangeError();\n                }\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            linearRampToValueAtTime(value, endTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n                return audioParam;\n            },\n            setTargetAtTime(target, startTime, timeConstant) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n                return audioParam;\n            },\n            setValueAtTime(value, startTime) {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n                return audioParam;\n            },\n            setValueCurveAtTime(values, startTime, duration) {\n                // Bug 183: Safari only accepts a Float32Array.\n                const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((convertedValues.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? convertedValues[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] +\n                                    (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n                    }\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n                    const timeOfLastSample = lastSample / sampleRate;\n                    if (timeOfLastSample < endTime) {\n                        audioParam.setValueAtTime(interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n                    audioParam.setValueAtTime(convertedValues[convertedValues.length - 1], endTime);\n                }\n                else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n                    automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n                }\n                return audioParam;\n            }\n        };\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n        addAudioParamConnections(audioParam, audioParamRenderer);\n        return audioParam;\n    };\n};\n//# sourceMappingURL=audio-param-factory.js.map"]},"metadata":{},"sourceType":"module"}