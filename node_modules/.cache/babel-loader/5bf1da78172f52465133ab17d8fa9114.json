{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\n\nexport var Sequence = /*#__PURE__*/function (_ToneEvent) {\n  _inherits(Sequence, _ToneEvent);\n\n  var _super = _createSuper(Sequence);\n\n  function Sequence() {\n    var _this;\n\n    _classCallCheck(this, Sequence);\n\n    _this = _super.call(this, optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n    _this.name = \"Sequence\";\n    /**\n     * The object responsible for scheduling all of the events\n     */\n\n    _this._part = new Part({\n      callback: _this._seqCallback.bind(_assertThisInitialized(_this)),\n      context: _this.context\n    });\n    /**\n     * private reference to all of the sequence proxies\n     */\n\n    _this._events = [];\n    /**\n     * The proxied array\n     */\n\n    _this._eventsArray = [];\n    var options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n    _this._subdivision = _this.toTicks(options.subdivision);\n    _this.events = options.events; // set all of the values\n\n    _this.loop = options.loop;\n    _this.loopStart = options.loopStart;\n    _this.loopEnd = options.loopEnd;\n    _this.playbackRate = options.playbackRate;\n    _this.probability = options.probability;\n    _this.humanize = options.humanize;\n    _this.mute = options.mute;\n    _this.playbackRate = options.playbackRate;\n    return _this;\n  }\n\n  _createClass(Sequence, [{\n    key: \"_seqCallback\",\n\n    /**\n     * The internal callback for when an event is invoked\n     */\n    value: function _seqCallback(time, value) {\n      if (value !== null) {\n        this.callback(time, value);\n      }\n    }\n    /**\n     * The sequence\n     */\n\n  }, {\n    key: \"start\",\n\n    /**\n     * Start the part at the given time.\n     * @param  time    When to start the part.\n     * @param  offset  The offset index to start at\n     */\n    value: function start(time, offset) {\n      this._part.start(time, offset ? this._indexTime(offset) : offset);\n\n      return this;\n    }\n    /**\n     * Stop the part at the given time.\n     * @param  time  When to stop the part.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      this._part.stop(time);\n\n      return this;\n    }\n    /**\n     * The subdivision of the sequence. This can only be\n     * set in the constructor. The subdivision is the\n     * interval between successive steps.\n     */\n\n  }, {\n    key: \"_createSequence\",\n\n    /**\n     * Create a sequence proxy which can be monitored to create subsequences\n     */\n    value: function _createSequence(array) {\n      var _this2 = this;\n\n      return new Proxy(array, {\n        get: function get(target, property) {\n          // property is index in this case\n          return target[property];\n        },\n        set: function set(target, property, value) {\n          if (isString(property) && isFinite(parseInt(property, 10))) {\n            if (isArray(value)) {\n              target[property] = _this2._createSequence(value);\n            } else {\n              target[property] = value;\n            }\n          } else {\n            target[property] = value;\n          }\n\n          _this2._eventsUpdated(); // return true to accept the changes\n\n\n          return true;\n        }\n      });\n    }\n    /**\n     * When the sequence has changed, all of the events need to be recreated\n     */\n\n  }, {\n    key: \"_eventsUpdated\",\n    value: function _eventsUpdated() {\n      this._part.clear();\n\n      this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset); // update the loopEnd\n\n\n      this.loopEnd = this.loopEnd;\n    }\n    /**\n     * reschedule all of the events that need to be rescheduled\n     */\n\n  }, {\n    key: \"_rescheduleSequence\",\n    value: function _rescheduleSequence(sequence, subdivision, startOffset) {\n      var _this3 = this;\n\n      sequence.forEach(function (value, index) {\n        var eventOffset = index * subdivision + startOffset;\n\n        if (isArray(value)) {\n          _this3._rescheduleSequence(value, subdivision / value.length, eventOffset);\n        } else {\n          var startTime = new TicksClass(_this3.context, eventOffset, \"i\").toSeconds();\n\n          _this3._part.add(startTime, value);\n        }\n      });\n    }\n    /**\n     * Get the time of the index given the Sequence's subdivision\n     * @param  index\n     * @return The time of that index\n     */\n\n  }, {\n    key: \"_indexTime\",\n    value: function _indexTime(index) {\n      return new TicksClass(this.context, index * this._subdivision + this.startOffset).toSeconds();\n    }\n    /**\n     * Clear all of the events\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._part.clear();\n\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Sequence.prototype), \"dispose\", this).call(this);\n\n      this._part.dispose();\n\n      return this;\n    } //-------------------------------------\n    // PROXY CALLS\n    //-------------------------------------\n\n  }, {\n    key: \"events\",\n    get: function get() {\n      return this._events;\n    },\n    set: function set(s) {\n      this.clear();\n      this._eventsArray = s;\n      this._events = this._createSequence(this._eventsArray);\n\n      this._eventsUpdated();\n    }\n  }, {\n    key: \"subdivision\",\n    get: function get() {\n      return new TicksClass(this.context, this._subdivision).toSeconds();\n    }\n  }, {\n    key: \"loop\",\n    get: function get() {\n      return this._part.loop;\n    },\n    set: function set(l) {\n      this._part.loop = l;\n    }\n    /**\n     * The index at which the sequence should start looping\n     */\n\n  }, {\n    key: \"loopStart\",\n    get: function get() {\n      return this._loopStart;\n    },\n    set: function set(index) {\n      this._loopStart = index;\n      this._part.loopStart = this._indexTime(index);\n    }\n    /**\n     * The index at which the sequence should end looping\n     */\n\n  }, {\n    key: \"loopEnd\",\n    get: function get() {\n      return this._loopEnd;\n    },\n    set: function set(index) {\n      this._loopEnd = index;\n\n      if (index === 0) {\n        this._part.loopEnd = this._indexTime(this._eventsArray.length);\n      } else {\n        this._part.loopEnd = this._indexTime(index);\n      }\n    }\n  }, {\n    key: \"startOffset\",\n    get: function get() {\n      return this._part.startOffset;\n    },\n    set: function set(start) {\n      this._part.startOffset = start;\n    }\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._part.playbackRate;\n    },\n    set: function set(rate) {\n      this._part.playbackRate = rate;\n    }\n  }, {\n    key: \"probability\",\n    get: function get() {\n      return this._part.probability;\n    },\n    set: function set(prob) {\n      this._part.probability = prob;\n    }\n  }, {\n    key: \"progress\",\n    get: function get() {\n      return this._part.progress;\n    }\n  }, {\n    key: \"humanize\",\n    get: function get() {\n      return this._part.humanize;\n    },\n    set: function set(variation) {\n      this._part.humanize = variation;\n    }\n    /**\n     * The number of scheduled events\n     */\n\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._part.length;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n        events: [],\n        loop: true,\n        loopEnd: 0,\n        loopStart: 0,\n        subdivision: \"8n\"\n      });\n    }\n  }]);\n\n  return Sequence;\n}(ToneEvent);","map":{"version":3,"sources":["../../../Tone/event/Sequence.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { TicksClass } from \"../core/type/Ticks\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Sequence extends ToneEvent {\n    constructor() {\n        super(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n        this.name = \"Sequence\";\n        /**\n         * The object responsible for scheduling all of the events\n         */\n        this._part = new Part({\n            callback: this._seqCallback.bind(this),\n            context: this.context,\n        });\n        /**\n         * private reference to all of the sequence proxies\n         */\n        this._events = [];\n        /**\n         * The proxied array\n         */\n        this._eventsArray = [];\n        const options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n        this._subdivision = this.toTicks(options.subdivision);\n        this.events = options.events;\n        // set all of the values\n        this.loop = options.loop;\n        this.loopStart = options.loopStart;\n        this.loopEnd = options.loopEnd;\n        this.playbackRate = options.playbackRate;\n        this.probability = options.probability;\n        this.humanize = options.humanize;\n        this.mute = options.mute;\n        this.playbackRate = options.playbackRate;\n    }\n    static getDefaults() {\n        return Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n            events: [],\n            loop: true,\n            loopEnd: 0,\n            loopStart: 0,\n            subdivision: \"8n\",\n        });\n    }\n    /**\n     * The internal callback for when an event is invoked\n     */\n    _seqCallback(time, value) {\n        if (value !== null) {\n            this.callback(time, value);\n        }\n    }\n    /**\n     * The sequence\n     */\n    get events() {\n        return this._events;\n    }\n    set events(s) {\n        this.clear();\n        this._eventsArray = s;\n        this._events = this._createSequence(this._eventsArray);\n        this._eventsUpdated();\n    }\n    /**\n     * Start the part at the given time.\n     * @param  time    When to start the part.\n     * @param  offset  The offset index to start at\n     */\n    start(time, offset) {\n        this._part.start(time, offset ? this._indexTime(offset) : offset);\n        return this;\n    }\n    /**\n     * Stop the part at the given time.\n     * @param  time  When to stop the part.\n     */\n    stop(time) {\n        this._part.stop(time);\n        return this;\n    }\n    /**\n     * The subdivision of the sequence. This can only be\n     * set in the constructor. The subdivision is the\n     * interval between successive steps.\n     */\n    get subdivision() {\n        return new TicksClass(this.context, this._subdivision).toSeconds();\n    }\n    /**\n     * Create a sequence proxy which can be monitored to create subsequences\n     */\n    _createSequence(array) {\n        return new Proxy(array, {\n            get: (target, property) => {\n                // property is index in this case\n                return target[property];\n            },\n            set: (target, property, value) => {\n                if (isString(property) && isFinite(parseInt(property, 10))) {\n                    if (isArray(value)) {\n                        target[property] = this._createSequence(value);\n                    }\n                    else {\n                        target[property] = value;\n                    }\n                }\n                else {\n                    target[property] = value;\n                }\n                this._eventsUpdated();\n                // return true to accept the changes\n                return true;\n            },\n        });\n    }\n    /**\n     * When the sequence has changed, all of the events need to be recreated\n     */\n    _eventsUpdated() {\n        this._part.clear();\n        this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n        // update the loopEnd\n        this.loopEnd = this.loopEnd;\n    }\n    /**\n     * reschedule all of the events that need to be rescheduled\n     */\n    _rescheduleSequence(sequence, subdivision, startOffset) {\n        sequence.forEach((value, index) => {\n            const eventOffset = index * (subdivision) + startOffset;\n            if (isArray(value)) {\n                this._rescheduleSequence(value, subdivision / value.length, eventOffset);\n            }\n            else {\n                const startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n                this._part.add(startTime, value);\n            }\n        });\n    }\n    /**\n     * Get the time of the index given the Sequence's subdivision\n     * @param  index\n     * @return The time of that index\n     */\n    _indexTime(index) {\n        return new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n    }\n    /**\n     * Clear all of the events\n     */\n    clear() {\n        this._part.clear();\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._part.dispose();\n        return this;\n    }\n    //-------------------------------------\n    // PROXY CALLS\n    //-------------------------------------\n    get loop() {\n        return this._part.loop;\n    }\n    set loop(l) {\n        this._part.loop = l;\n    }\n    /**\n     * The index at which the sequence should start looping\n     */\n    get loopStart() {\n        return this._loopStart;\n    }\n    set loopStart(index) {\n        this._loopStart = index;\n        this._part.loopStart = this._indexTime(index);\n    }\n    /**\n     * The index at which the sequence should end looping\n     */\n    get loopEnd() {\n        return this._loopEnd;\n    }\n    set loopEnd(index) {\n        this._loopEnd = index;\n        if (index === 0) {\n            this._part.loopEnd = this._indexTime(this._eventsArray.length);\n        }\n        else {\n            this._part.loopEnd = this._indexTime(index);\n        }\n    }\n    get startOffset() {\n        return this._part.startOffset;\n    }\n    set startOffset(start) {\n        this._part.startOffset = start;\n    }\n    get playbackRate() {\n        return this._part.playbackRate;\n    }\n    set playbackRate(rate) {\n        this._part.playbackRate = rate;\n    }\n    get probability() {\n        return this._part.probability;\n    }\n    set probability(prob) {\n        this._part.probability = prob;\n    }\n    get progress() {\n        return this._part.progress;\n    }\n    get humanize() {\n        return this._part.humanize;\n    }\n    set humanize(variation) {\n        this._part.humanize = variation;\n    }\n    /**\n     * The number of scheduled events\n     */\n    get length() {\n        return this._part.length;\n    }\n}\n//# sourceMappingURL=Sequence.js.map"]},"metadata":{},"sourceType":"module"}