{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { ToneEvent } from \"./ToneEvent\";\nimport { ToneWithContext } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Loop creates a looped callback at the\n * specified interval. The callback can be\n * started, stopped and scheduled along\n * the Transport's timeline.\n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note.\n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\n\nexport var Loop = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(Loop, _ToneWithContext);\n\n  var _super = _createSuper(Loop);\n\n  function Loop() {\n    var _this;\n\n    _classCallCheck(this, Loop);\n\n    _this = _super.call(this, optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n    _this.name = \"Loop\";\n    var options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n    _this._event = new ToneEvent({\n      context: _this.context,\n      callback: _this._tick.bind(_assertThisInitialized(_this)),\n      loop: true,\n      loopEnd: options.interval,\n      playbackRate: options.playbackRate,\n      probability: options.probability\n    });\n    _this.callback = options.callback; // set the iterations\n\n    _this.iterations = options.iterations;\n    return _this;\n  }\n\n  _createClass(Loop, [{\n    key: \"start\",\n\n    /**\n     * Start the loop at the specified time along the Transport's timeline.\n     * @param  time  When to start the Loop.\n     */\n    value: function start(time) {\n      this._event.start(time);\n\n      return this;\n    }\n    /**\n     * Stop the loop at the given time.\n     * @param  time  When to stop the Loop.\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      this._event.stop(time);\n\n      return this;\n    }\n    /**\n     * Cancel all scheduled events greater than or equal to the given time\n     * @param  time  The time after which events will be cancel.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(time) {\n      this._event.cancel(time);\n\n      return this;\n    }\n    /**\n     * Internal function called when the notes should be called\n     * @param time  The time the event occurs\n     */\n\n  }, {\n    key: \"_tick\",\n    value: function _tick(time) {\n      this.callback(time);\n    }\n    /**\n     * The state of the Loop, either started or stopped.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Loop.prototype), \"dispose\", this).call(this);\n\n      this._event.dispose();\n\n      return this;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._event.state;\n    }\n    /**\n     * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.\n     */\n\n  }, {\n    key: \"progress\",\n    get: function get() {\n      return this._event.progress;\n    }\n    /**\n     * The time between successive callbacks.\n     * @example\n     * const loop = new Tone.Loop();\n     * loop.interval = \"8n\"; // loop every 8n\n     */\n\n  }, {\n    key: \"interval\",\n    get: function get() {\n      return this._event.loopEnd;\n    },\n    set: function set(interval) {\n      this._event.loopEnd = interval;\n    }\n    /**\n     * The playback rate of the loop. The normal playback rate is 1 (no change).\n     * A `playbackRate` of 2 would be twice as fast.\n     */\n\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._event.playbackRate;\n    },\n    set: function set(rate) {\n      this._event.playbackRate = rate;\n    }\n    /**\n     * Random variation +/-0.01s to the scheduled time.\n     * Or give it a time value which it will randomize by.\n     */\n\n  }, {\n    key: \"humanize\",\n    get: function get() {\n      return this._event.humanize;\n    },\n    set: function set(variation) {\n      this._event.humanize = variation;\n    }\n    /**\n     * The probably of the callback being invoked.\n     */\n\n  }, {\n    key: \"probability\",\n    get: function get() {\n      return this._event.probability;\n    },\n    set: function set(prob) {\n      this._event.probability = prob;\n    }\n    /**\n     * Muting the Loop means that no callbacks are invoked.\n     */\n\n  }, {\n    key: \"mute\",\n    get: function get() {\n      return this._event.mute;\n    },\n    set: function set(mute) {\n      this._event.mute = mute;\n    }\n    /**\n     * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n     */\n\n  }, {\n    key: \"iterations\",\n    get: function get() {\n      if (this._event.loop === true) {\n        return Infinity;\n      } else {\n        return this._event.loop;\n      }\n    },\n    set: function set(iters) {\n      if (iters === Infinity) {\n        this._event.loop = true;\n      } else {\n        this._event.loop = iters;\n      }\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneWithContext.getDefaults(), {\n        interval: \"4n\",\n        callback: noOp,\n        playbackRate: 1,\n        iterations: Infinity,\n        probability: 1,\n        mute: false,\n        humanize: false\n      });\n    }\n  }]);\n\n  return Loop;\n}(ToneWithContext);","map":{"version":3,"sources":["../../../Tone/event/Loop.ts"],"names":[],"mappings":";;;;;;;AAAA,SAAS,SAAT,QAA0B,aAA1B;AAEA,SAAS,eAAT,QAAwD,iCAAxD;AACA,SAAS,oBAAT,QAAqC,uBAArC;AACA,SAAS,IAAT,QAAqB,wBAArB;AAaA;;;;;;;;;;;;AAYG;;AACH,WAAa,IAAb;AAAA;;AAAA;;AAoBC,kBAAA;AAAA;;AAAA;;AACC,8BAAM,oBAAoB,CAAC,IAAI,CAAC,WAAL,EAAD,EAAqB,SAArB,EAAgC,CAAC,UAAD,EAAa,UAAb,CAAhC,CAA1B;AAnBQ,UAAA,IAAA,GAAe,MAAf;AAoBR,QAAM,OAAO,GAAG,oBAAoB,CAAC,IAAI,CAAC,WAAL,EAAD,EAAqB,SAArB,EAAgC,CAAC,UAAD,EAAa,UAAb,CAAhC,CAApC;AAEA,UAAK,MAAL,GAAc,IAAI,SAAJ,CAAc;AAC3B,MAAA,OAAO,EAAE,MAAK,OADa;AAE3B,MAAA,QAAQ,EAAE,MAAK,KAAL,CAAW,IAAX,+BAFiB;AAG3B,MAAA,IAAI,EAAE,IAHqB;AAI3B,MAAA,OAAO,EAAE,OAAO,CAAC,QAJU;AAK3B,MAAA,YAAY,EAAE,OAAO,CAAC,YALK;AAM3B,MAAA,WAAW,EAAE,OAAO,CAAC;AANM,KAAd,CAAd;AASA,UAAK,QAAL,GAAgB,OAAO,CAAC,QAAxB,CAbD,CAcC;;AACA,UAAK,UAAL,GAAkB,OAAO,CAAC,UAA1B;AAfD;AAgBC;;AApCF;AAAA;;AAkDC;;;AAGG;AArDJ,0BAsDO,IAtDP,EAsD2B;AACzB,WAAK,MAAL,CAAY,KAAZ,CAAkB,IAAlB;;AACA,aAAO,IAAP;AACA;AAED;;;AAGG;;AA9DJ;AAAA;AAAA,yBA+DM,IA/DN,EA+D0B;AACxB,WAAK,MAAL,CAAY,IAAZ,CAAiB,IAAjB;;AACA,aAAO,IAAP;AACA;AAED;;;AAGG;;AAvEJ;AAAA;AAAA,2BAwEQ,IAxER,EAwE4B;AAC1B,WAAK,MAAL,CAAY,MAAZ,CAAmB,IAAnB;;AACA,aAAO,IAAP;AACA;AAED;;;AAGG;;AAhFJ;AAAA;AAAA,0BAiFiB,IAjFjB,EAiF8B;AAC5B,WAAK,QAAL,CAAc,IAAd;AACA;AAED;;AAEG;;AAvFJ;AAAA;AAAA,8BA8KQ;AACN;;AACA,WAAK,MAAL,CAAY,OAAZ;;AACA,aAAO,IAAP;AACA;AAlLF;AAAA;AAAA,wBAwFU;AACR,aAAO,KAAK,MAAL,CAAY,KAAnB;AACA;AAED;;AAEG;;AA9FJ;AAAA;AAAA,wBA+Fa;AACX,aAAO,KAAK,MAAL,CAAY,QAAnB;AACA;AAED;;;;;AAKG;;AAxGJ;AAAA;AAAA,wBAyGa;AACX,aAAO,KAAK,MAAL,CAAY,OAAnB;AACA,KA3GF;AAAA,sBA4Gc,QA5Gd,EA4GsB;AACpB,WAAK,MAAL,CAAY,OAAZ,GAAsB,QAAtB;AACA;AAED;;;AAGG;;AAnHJ;AAAA;AAAA,wBAoHiB;AACf,aAAO,KAAK,MAAL,CAAY,YAAnB;AACA,KAtHF;AAAA,sBAuHkB,IAvHlB,EAuHsB;AACpB,WAAK,MAAL,CAAY,YAAZ,GAA2B,IAA3B;AACA;AAED;;;AAGG;;AA9HJ;AAAA;AAAA,wBA+Ha;AACX,aAAO,KAAK,MAAL,CAAY,QAAnB;AACA,KAjIF;AAAA,sBAkIc,SAlId,EAkIuB;AACrB,WAAK,MAAL,CAAY,QAAZ,GAAuB,SAAvB;AACA;AAED;;AAEG;;AAxIJ;AAAA;AAAA,wBAyIgB;AACd,aAAO,KAAK,MAAL,CAAY,WAAnB;AACA,KA3IF;AAAA,sBA6IiB,IA7IjB,EA6IqB;AACnB,WAAK,MAAL,CAAY,WAAZ,GAA0B,IAA1B;AACA;AAED;;AAEG;;AAnJJ;AAAA;AAAA,wBAoJS;AACP,aAAO,KAAK,MAAL,CAAY,IAAnB;AACA,KAtJF;AAAA,sBAwJU,IAxJV,EAwJc;AACZ,WAAK,MAAL,CAAY,IAAZ,GAAmB,IAAnB;AACA;AAED;;AAEG;;AA9JJ;AAAA;AAAA,wBA+Je;AACb,UAAI,KAAK,MAAL,CAAY,IAAZ,KAAqB,IAAzB,EAA+B;AAC9B,eAAO,QAAP;AACA,OAFD,MAEO;AACN,eAAO,KAAK,MAAL,CAAY,IAAnB;AACA;AACD,KArKF;AAAA,sBAsKgB,KAtKhB,EAsKqB;AACnB,UAAI,KAAK,KAAK,QAAd,EAAwB;AACvB,aAAK,MAAL,CAAY,IAAZ,GAAmB,IAAnB;AACA,OAFD,MAEO;AACN,aAAK,MAAL,CAAY,IAAZ,GAAmB,KAAnB;AACA;AACD;AA5KF;AAAA;AAAA,kCAsCmB;AACjB,aAAO,MAAM,CAAC,MAAP,CAAc,eAAe,CAAC,WAAhB,EAAd,EAA6C;AACnD,QAAA,QAAQ,EAAE,IADyC;AAEnD,QAAA,QAAQ,EAAE,IAFyC;AAGnD,QAAA,YAAY,EAAE,CAHqC;AAInD,QAAA,UAAU,EAAE,QAJuC;AAKnD,QAAA,WAAW,EAAE,CALsC;AAMnD,QAAA,IAAI,EAAE,KAN6C;AAOnD,QAAA,QAAQ,EAAE;AAPyC,OAA7C,CAAP;AASA;AAhDF;;AAAA;AAAA,EAAqE,eAArE","sourceRoot":"","sourcesContent":["import { ToneEvent } from \"./ToneEvent\";\nimport { ToneWithContext } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Loop creates a looped callback at the\n * specified interval. The callback can be\n * started, stopped and scheduled along\n * the Transport's timeline.\n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note.\n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Loop extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n        this.name = \"Loop\";\n        const options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n        this._event = new ToneEvent({\n            context: this.context,\n            callback: this._tick.bind(this),\n            loop: true,\n            loopEnd: options.interval,\n            playbackRate: options.playbackRate,\n            probability: options.probability\n        });\n        this.callback = options.callback;\n        // set the iterations\n        this.iterations = options.iterations;\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            interval: \"4n\",\n            callback: noOp,\n            playbackRate: 1,\n            iterations: Infinity,\n            probability: 1,\n            mute: false,\n            humanize: false\n        });\n    }\n    /**\n     * Start the loop at the specified time along the Transport's timeline.\n     * @param  time  When to start the Loop.\n     */\n    start(time) {\n        this._event.start(time);\n        return this;\n    }\n    /**\n     * Stop the loop at the given time.\n     * @param  time  When to stop the Loop.\n     */\n    stop(time) {\n        this._event.stop(time);\n        return this;\n    }\n    /**\n     * Cancel all scheduled events greater than or equal to the given time\n     * @param  time  The time after which events will be cancel.\n     */\n    cancel(time) {\n        this._event.cancel(time);\n        return this;\n    }\n    /**\n     * Internal function called when the notes should be called\n     * @param time  The time the event occurs\n     */\n    _tick(time) {\n        this.callback(time);\n    }\n    /**\n     * The state of the Loop, either started or stopped.\n     */\n    get state() {\n        return this._event.state;\n    }\n    /**\n     * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.\n     */\n    get progress() {\n        return this._event.progress;\n    }\n    /**\n     * The time between successive callbacks.\n     * @example\n     * const loop = new Tone.Loop();\n     * loop.interval = \"8n\"; // loop every 8n\n     */\n    get interval() {\n        return this._event.loopEnd;\n    }\n    set interval(interval) {\n        this._event.loopEnd = interval;\n    }\n    /**\n     * The playback rate of the loop. The normal playback rate is 1 (no change).\n     * A `playbackRate` of 2 would be twice as fast.\n     */\n    get playbackRate() {\n        return this._event.playbackRate;\n    }\n    set playbackRate(rate) {\n        this._event.playbackRate = rate;\n    }\n    /**\n     * Random variation +/-0.01s to the scheduled time.\n     * Or give it a time value which it will randomize by.\n     */\n    get humanize() {\n        return this._event.humanize;\n    }\n    set humanize(variation) {\n        this._event.humanize = variation;\n    }\n    /**\n     * The probably of the callback being invoked.\n     */\n    get probability() {\n        return this._event.probability;\n    }\n    set probability(prob) {\n        this._event.probability = prob;\n    }\n    /**\n     * Muting the Loop means that no callbacks are invoked.\n     */\n    get mute() {\n        return this._event.mute;\n    }\n    set mute(mute) {\n        this._event.mute = mute;\n    }\n    /**\n     * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n     */\n    get iterations() {\n        if (this._event.loop === true) {\n            return Infinity;\n        }\n        else {\n            return this._event.loop;\n        }\n    }\n    set iterations(iters) {\n        if (iters === Infinity) {\n            this._event.loop = true;\n        }\n        else {\n            this._event.loop = iters;\n        }\n    }\n    dispose() {\n        super.dispose();\n        this._event.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=Loop.js.map"]},"metadata":{},"sourceType":"module"}