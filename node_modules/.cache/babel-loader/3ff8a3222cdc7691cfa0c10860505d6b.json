{"ast":null,"code":"export var createWrapAudioBufferCopyChannelMethodsOutOfBounds = function createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong) {\n  return function (audioBuffer) {\n    audioBuffer.copyFromChannel = function (copyFromChannel) {\n      return function (destination, channelNumberAsNumber) {\n        var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n        var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n        if (bufferOffset < audioBuffer.length) {\n          return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n        }\n      };\n    }(audioBuffer.copyFromChannel);\n\n    audioBuffer.copyToChannel = function (copyToChannel) {\n      return function (source, channelNumberAsNumber) {\n        var bufferOffsetAsNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        var bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n        var channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n        if (bufferOffset < audioBuffer.length) {\n          return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n        }\n      };\n    }(audioBuffer.copyToChannel);\n  };\n};","map":{"version":3,"sources":["../../../src/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.ts"],"names":[],"mappings":"AAEA,OAAO,IAAM,kDAAkD,GAAyD,SAA3G,kDAA2G,CACpH,2BADoH,EAEpH;AACA,SAAO,UAAC,WAAD,EAA0C;AAC7C,IAAA,WAAW,CAAC,eAAZ,GAA+B,UAAC,eAAD,EAAoB;AAC/C,aAAO,UAAC,WAAD,EAA4B,qBAA5B,EAAuF;AAAA,YAA5B,oBAA4B,uEAAL,CAAK;AAC1F,YAAM,YAAY,GAAG,2BAA2B,CAAC,oBAAD,CAAhD;AACA,YAAM,aAAa,GAAG,2BAA2B,CAAC,qBAAD,CAAjD;;AAEA,YAAI,YAAY,GAAG,WAAW,CAAC,MAA/B,EAAuC;AACnC,iBAAO,eAAe,CAAC,IAAhB,CAAqB,WAArB,EAAkC,WAAlC,EAA+C,aAA/C,EAA8D,YAA9D,CAAP;AACH;AACJ,OAPD;AAQH,KAT6B,CAS3B,WAAW,CAAC,eATe,CAA9B;;AAWA,IAAA,WAAW,CAAC,aAAZ,GAA6B,UAAC,aAAD,EAAkB;AAC3C,aAAO,UAAC,MAAD,EAAuB,qBAAvB,EAAkF;AAAA,YAA5B,oBAA4B,uEAAL,CAAK;AACrF,YAAM,YAAY,GAAG,2BAA2B,CAAC,oBAAD,CAAhD;AACA,YAAM,aAAa,GAAG,2BAA2B,CAAC,qBAAD,CAAjD;;AAEA,YAAI,YAAY,GAAG,WAAW,CAAC,MAA/B,EAAuC;AACnC,iBAAO,aAAa,CAAC,IAAd,CAAmB,WAAnB,EAAgC,MAAhC,EAAwC,aAAxC,EAAuD,YAAvD,CAAP;AACH;AACJ,OAPD;AAQH,KAT2B,CASzB,WAAW,CAAC,aATa,CAA5B;AAUH,GAtBD;AAuBH,CA1BM","sourceRoot":"","sourcesContent":["export const createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong) => {\n    return (audioBuffer) => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n//# sourceMappingURL=wrap-audio-buffer-copy-channel-methods-out-of-bounds.js.map"]},"metadata":{},"sourceType":"module"}