{"ast":null,"code":"var BaseTexture = require('./BaseTexture'),\n    utils = require('../utils');\n/**\n * A texture of a [playing] Video.\n *\n * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.\n *\n * This can be used in several ways, such as:\n *\n * ```js\n * var texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');\n *\n * var texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });\n *\n * var texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);\n *\n * var texture = PIXI.VideoBaseTexture.fromUrls([\n *     { src: '/video.webm', mime: 'video/webm' },\n *     { src: '/video.mp4', mime: 'video/mp4' }\n * ]);\n * ```\n *\n * See the [\"deus\" demo](http://www.goodboydigital.com/pixijs/examples/deus/).\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n * @param source {HTMLVideoElement}\n * @param [scaleMode] {number} See {@link SCALE_MODES} for possible values\n */\n\n\nfunction VideoBaseTexture(source, scaleMode) {\n  if (!source) {\n    throw new Error('No video source element specified.');\n  } // hook in here to check if video is already available.\n  // BaseTexture looks for a source.complete boolean, plus width & height.\n\n\n  if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height) {\n    source.complete = true;\n  }\n\n  BaseTexture.call(this, source, scaleMode);\n  /**\n   * Should the base texture automatically update itself, set to true by default\n   *\n   * @member {boolean}\n   * @default true\n   */\n\n  this.autoUpdate = false;\n  this._onUpdate = this._onUpdate.bind(this);\n  this._onCanPlay = this._onCanPlay.bind(this);\n\n  if (!source.complete) {\n    source.addEventListener('canplay', this._onCanPlay);\n    source.addEventListener('canplaythrough', this._onCanPlay); // started playing..\n\n    source.addEventListener('play', this._onPlayStart.bind(this));\n    source.addEventListener('pause', this._onPlayStop.bind(this));\n  }\n\n  this.__loaded = false;\n}\n\nVideoBaseTexture.prototype = Object.create(BaseTexture.prototype);\nVideoBaseTexture.prototype.constructor = VideoBaseTexture;\nmodule.exports = VideoBaseTexture;\n/**\n * The internal update loop of the video base texture, only runs when autoUpdate is set to true\n * @private\n */\n\nVideoBaseTexture.prototype._onUpdate = function () {\n  if (this.autoUpdate) {\n    window.requestAnimationFrame(this._onUpdate);\n    this.update();\n  }\n};\n/**\n * Runs the update loop when the video is ready to play\n * @private\n */\n\n\nVideoBaseTexture.prototype._onPlayStart = function () {\n  if (!this.autoUpdate) {\n    window.requestAnimationFrame(this._onUpdate);\n    this.autoUpdate = true;\n  }\n};\n/**\n * Fired when a pause event is triggered, stops the update loop\n * @private\n */\n\n\nVideoBaseTexture.prototype._onPlayStop = function () {\n  this.autoUpdate = false;\n};\n/**\n * Fired when the video is loaded and ready to play\n * @private\n */\n\n\nVideoBaseTexture.prototype._onCanPlay = function () {\n  this.hasLoaded = true;\n\n  if (this.source) {\n    this.source.removeEventListener('canplay', this._onCanPlay);\n    this.source.removeEventListener('canplaythrough', this._onCanPlay);\n    this.width = this.source.videoWidth;\n    this.height = this.source.videoHeight;\n    this.source.play(); // prevent multiple loaded dispatches..\n\n    if (!this.__loaded) {\n      this.__loaded = true;\n      this.emit('loaded', this);\n    }\n  }\n};\n/**\n * Destroys this texture\n *\n */\n\n\nVideoBaseTexture.prototype.destroy = function () {\n  if (this.source && this.source._pixiId) {\n    delete utils.BaseTextureCache[this.source._pixiId];\n    delete this.source._pixiId;\n  }\n\n  BaseTexture.prototype.destroy.call(this);\n};\n/**\n * Mimic Pixi BaseTexture.from.... method.\n *\n * @static\n * @param video {HTMLVideoElement}\n * @param scaleMode {number} See {@link SCALE_MODES} for possible values\n * @return {VideoBaseTexture}\n */\n\n\nVideoBaseTexture.fromVideo = function (video, scaleMode) {\n  if (!video._pixiId) {\n    video._pixiId = 'video_' + utils.uid();\n  }\n\n  var baseTexture = utils.BaseTextureCache[video._pixiId];\n\n  if (!baseTexture) {\n    baseTexture = new VideoBaseTexture(video, scaleMode);\n    utils.BaseTextureCache[video._pixiId] = baseTexture;\n  }\n\n  return baseTexture;\n};\n/**\n * Helper function that creates a new BaseTexture based on the given video element.\n * This BaseTexture can then be used to create a texture\n *\n * @static\n * @param videoSrc {string|object|string[]|object[]} The URL(s) for the video.\n * @param [videoSrc.src] {string} One of the source urls for the video\n * @param [videoSrc.mime] {string} The mimetype of the video (e.g. 'video/mp4'). If not specified\n *  the url's extension will be used as the second part of the mime type.\n * @param scaleMode {number} See {@link SCALE_MODES} for possible values\n * @return {VideoBaseTexture}\n */\n\n\nVideoBaseTexture.fromUrl = function (videoSrc, scaleMode) {\n  var video = document.createElement('video'); // array of objects or strings\n\n  if (Array.isArray(videoSrc)) {\n    for (var i = 0; i < videoSrc.length; ++i) {\n      video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));\n    }\n  } // single object or string\n  else {\n      video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));\n    }\n\n  video.load();\n  video.play();\n  return VideoBaseTexture.fromVideo(video, scaleMode);\n};\n\nVideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;\n\nfunction createSource(path, type) {\n  if (!type) {\n    type = 'video/' + path.substr(path.lastIndexOf('.') + 1);\n  }\n\n  var source = document.createElement('source');\n  source.src = path;\n  source.type = type;\n  return source;\n}","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/textures/VideoBaseTexture.js"],"names":["BaseTexture","require","utils","VideoBaseTexture","source","scaleMode","Error","readyState","HAVE_ENOUGH_DATA","HAVE_FUTURE_DATA","width","height","complete","call","autoUpdate","_onUpdate","bind","_onCanPlay","addEventListener","_onPlayStart","_onPlayStop","__loaded","prototype","Object","create","constructor","module","exports","window","requestAnimationFrame","update","hasLoaded","removeEventListener","videoWidth","videoHeight","play","emit","destroy","_pixiId","BaseTextureCache","fromVideo","video","uid","baseTexture","fromUrl","videoSrc","document","createElement","Array","isArray","i","length","appendChild","createSource","src","mime","load","fromUrls","path","type","substr","lastIndexOf"],"mappings":"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","sourcesContent":["var BaseTexture = require('./BaseTexture'),\n    utils = require('../utils');\n\n/**\n * A texture of a [playing] Video.\n *\n * Video base textures mimic Pixi BaseTexture.from.... method in their creation process.\n *\n * This can be used in several ways, such as:\n *\n * ```js\n * var texture = PIXI.VideoBaseTexture.fromUrl('http://mydomain.com/video.mp4');\n *\n * var texture = PIXI.VideoBaseTexture.fromUrl({ src: 'http://mydomain.com/video.mp4', mime: 'video/mp4' });\n *\n * var texture = PIXI.VideoBaseTexture.fromUrls(['/video.webm', '/video.mp4']);\n *\n * var texture = PIXI.VideoBaseTexture.fromUrls([\n *     { src: '/video.webm', mime: 'video/webm' },\n *     { src: '/video.mp4', mime: 'video/mp4' }\n * ]);\n * ```\n *\n * See the [\"deus\" demo](http://www.goodboydigital.com/pixijs/examples/deus/).\n *\n * @class\n * @extends PIXI.BaseTexture\n * @memberof PIXI\n * @param source {HTMLVideoElement}\n * @param [scaleMode] {number} See {@link SCALE_MODES} for possible values\n */\nfunction VideoBaseTexture(source, scaleMode)\n{\n    if (!source)\n    {\n        throw new Error('No video source element specified.');\n    }\n\n    // hook in here to check if video is already available.\n    // BaseTexture looks for a source.complete boolean, plus width & height.\n\n    if ((source.readyState === source.HAVE_ENOUGH_DATA || source.readyState === source.HAVE_FUTURE_DATA) && source.width && source.height)\n    {\n        source.complete = true;\n    }\n\n    BaseTexture.call(this, source, scaleMode);\n\n    /**\n     * Should the base texture automatically update itself, set to true by default\n     *\n     * @member {boolean}\n     * @default true\n     */\n    this.autoUpdate = false;\n\n    this._onUpdate = this._onUpdate.bind(this);\n    this._onCanPlay = this._onCanPlay.bind(this);\n\n    if (!source.complete)\n    {\n        source.addEventListener('canplay', this._onCanPlay);\n        source.addEventListener('canplaythrough', this._onCanPlay);\n\n        // started playing..\n        source.addEventListener('play', this._onPlayStart.bind(this));\n        source.addEventListener('pause', this._onPlayStop.bind(this));\n    }\n\n    this.__loaded = false;\n}\n\nVideoBaseTexture.prototype = Object.create(BaseTexture.prototype);\nVideoBaseTexture.prototype.constructor = VideoBaseTexture;\nmodule.exports = VideoBaseTexture;\n\n/**\n * The internal update loop of the video base texture, only runs when autoUpdate is set to true\n * @private\n */\nVideoBaseTexture.prototype._onUpdate = function ()\n{\n    if (this.autoUpdate)\n    {\n        window.requestAnimationFrame(this._onUpdate);\n        this.update();\n    }\n};\n\n/**\n * Runs the update loop when the video is ready to play\n * @private\n */\nVideoBaseTexture.prototype._onPlayStart = function ()\n{\n    if (!this.autoUpdate)\n    {\n        window.requestAnimationFrame(this._onUpdate);\n        this.autoUpdate = true;\n    }\n};\n\n/**\n * Fired when a pause event is triggered, stops the update loop\n * @private\n */\nVideoBaseTexture.prototype._onPlayStop = function ()\n{\n    this.autoUpdate = false;\n};\n\n/**\n * Fired when the video is loaded and ready to play\n * @private\n */\nVideoBaseTexture.prototype._onCanPlay = function ()\n{\n    this.hasLoaded = true;\n\n    if (this.source)\n    {\n        this.source.removeEventListener('canplay', this._onCanPlay);\n        this.source.removeEventListener('canplaythrough', this._onCanPlay);\n\n        this.width = this.source.videoWidth;\n        this.height = this.source.videoHeight;\n\n        this.source.play();\n\n        // prevent multiple loaded dispatches..\n        if (!this.__loaded)\n        {\n            this.__loaded = true;\n            this.emit('loaded', this);\n        }\n    }\n};\n\n/**\n * Destroys this texture\n *\n */\nVideoBaseTexture.prototype.destroy = function ()\n{\n    if (this.source && this.source._pixiId)\n    {\n        delete utils.BaseTextureCache[ this.source._pixiId ];\n        delete this.source._pixiId;\n    }\n\n    BaseTexture.prototype.destroy.call(this);\n};\n\n/**\n * Mimic Pixi BaseTexture.from.... method.\n *\n * @static\n * @param video {HTMLVideoElement}\n * @param scaleMode {number} See {@link SCALE_MODES} for possible values\n * @return {VideoBaseTexture}\n */\nVideoBaseTexture.fromVideo = function (video, scaleMode)\n{\n    if (!video._pixiId)\n    {\n        video._pixiId = 'video_' + utils.uid();\n    }\n\n    var baseTexture = utils.BaseTextureCache[video._pixiId];\n\n    if (!baseTexture)\n    {\n        baseTexture = new VideoBaseTexture(video, scaleMode);\n        utils.BaseTextureCache[ video._pixiId ] = baseTexture;\n    }\n\n    return baseTexture;\n};\n\n/**\n * Helper function that creates a new BaseTexture based on the given video element.\n * This BaseTexture can then be used to create a texture\n *\n * @static\n * @param videoSrc {string|object|string[]|object[]} The URL(s) for the video.\n * @param [videoSrc.src] {string} One of the source urls for the video\n * @param [videoSrc.mime] {string} The mimetype of the video (e.g. 'video/mp4'). If not specified\n *  the url's extension will be used as the second part of the mime type.\n * @param scaleMode {number} See {@link SCALE_MODES} for possible values\n * @return {VideoBaseTexture}\n */\nVideoBaseTexture.fromUrl = function (videoSrc, scaleMode)\n{\n    var video = document.createElement('video');\n\n    // array of objects or strings\n    if (Array.isArray(videoSrc))\n    {\n        for (var i = 0; i < videoSrc.length; ++i)\n        {\n            video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));\n        }\n    }\n    // single object or string\n    else\n    {\n        video.appendChild(createSource(videoSrc.src || videoSrc, videoSrc.mime));\n    }\n\n    video.load();\n    video.play();\n\n    return VideoBaseTexture.fromVideo(video, scaleMode);\n};\n\nVideoBaseTexture.fromUrls = VideoBaseTexture.fromUrl;\n\nfunction createSource(path, type)\n{\n    if (!type)\n    {\n        type = 'video/' + path.substr(path.lastIndexOf('.') + 1);\n    }\n\n    var source = document.createElement('source');\n\n    source.src = path;\n    source.type = type;\n\n    return source;\n}\n"]},"metadata":{},"sourceType":"script"}