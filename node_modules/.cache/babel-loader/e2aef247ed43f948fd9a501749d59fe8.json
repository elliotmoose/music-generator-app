{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\n\nexport var Clock = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(Clock, _ToneWithContext);\n\n  var _super = _createSuper(Clock);\n\n  function Clock() {\n    var _this;\n\n    _classCallCheck(this, Clock);\n\n    _this = _super.call(this, optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n    _this.name = \"Clock\";\n    /**\n     * The callback function to invoke at the scheduled tick.\n     */\n\n    _this.callback = noOp;\n    /**\n     * The last time the loop callback was invoked\n     */\n\n    _this._lastUpdate = 0;\n    /**\n     * Keep track of the playback state\n     */\n\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * Context bound reference to the _loop method\n     * This is necessary to remove the event in the end.\n     */\n\n    _this._boundLoop = _this._loop.bind(_assertThisInitialized(_this));\n    var options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n    _this.callback = options.callback;\n    _this._tickSource = new TickSource({\n      context: _this.context,\n      frequency: options.frequency,\n      units: options.units\n    });\n    _this._lastUpdate = 0;\n    _this.frequency = _this._tickSource.frequency;\n    readOnly(_assertThisInitialized(_this), \"frequency\"); // add an initial state\n\n    _this._state.setStateAtTime(\"stopped\", 0); // bind a callback to the worker thread\n\n\n    _this.context.on(\"tick\", _this._boundLoop);\n\n    return _this;\n  }\n\n  _createClass(Clock, [{\n    key: \"start\",\n\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset  Where the tick counter starts counting from.\n     */\n    value: function start(time, offset) {\n      // make sure the context is running\n      assertContextRunning(this.context); // start the loop\n\n      var computedTime = this.toSeconds(time);\n      this.log(\"start\", computedTime);\n\n      if (this._state.getValueAtTime(computedTime) !== \"started\") {\n        this._state.setStateAtTime(\"started\", computedTime);\n\n        this._tickSource.start(computedTime, offset);\n\n        if (computedTime < this._lastUpdate) {\n          this.emit(\"start\", computedTime, offset);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     * @example\n     * const clock = new Tone.Clock(time => {\n     * \tconsole.log(time);\n     * }, 1);\n     * clock.start();\n     * // stop the clock after 10 seconds\n     * clock.stop(\"+10\");\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = this.toSeconds(time);\n      this.log(\"stop\", computedTime);\n\n      this._state.cancel(computedTime);\n\n      this._state.setStateAtTime(\"stopped\", computedTime);\n\n      this._tickSource.stop(computedTime);\n\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"stop\", computedTime);\n      }\n\n      return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause(time) {\n      var computedTime = this.toSeconds(time);\n\n      if (this._state.getValueAtTime(computedTime) === \"started\") {\n        this._state.setStateAtTime(\"paused\", computedTime);\n\n        this._tickSource.pause(computedTime);\n\n        if (computedTime < this._lastUpdate) {\n          this.emit(\"pause\", computedTime);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked.\n     */\n\n  }, {\n    key: \"getSecondsAtTime\",\n\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    value: function getSecondsAtTime(time) {\n      return this._tickSource.getSecondsAtTime(time);\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n\n  }, {\n    key: \"setTicksAtTime\",\n    value: function setTicksAtTime(ticks, time) {\n      this._tickSource.setTicksAtTime(ticks, time);\n\n      return this;\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n\n  }, {\n    key: \"getTimeOfTick\",\n    value: function getTimeOfTick(tick) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n      return this._tickSource.getTimeOfTick(tick, before);\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      return this._tickSource.getTicksAtTime(time);\n    }\n    /**\n     * Get the time of the next tick\n     * @param  offset The tick number.\n     */\n\n  }, {\n    key: \"nextTickTime\",\n    value: function nextTickTime(offset, when) {\n      var computedTime = this.toSeconds(when);\n      var currentTick = this.getTicksAtTime(computedTime);\n      return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n    }\n    /**\n     * The scheduling loop.\n     */\n\n  }, {\n    key: \"_loop\",\n    value: function _loop() {\n      var _this2 = this;\n\n      var startTime = this._lastUpdate;\n      var endTime = this.now();\n      this._lastUpdate = endTime;\n      this.log(\"loop\", startTime, endTime);\n\n      if (startTime !== endTime) {\n        // the state change events\n        this._state.forEachBetween(startTime, endTime, function (e) {\n          switch (e.state) {\n            case \"started\":\n              var offset = _this2._tickSource.getTicksAtTime(e.time);\n\n              _this2.emit(\"start\", e.time, offset);\n\n              break;\n\n            case \"stopped\":\n              if (e.time !== 0) {\n                _this2.emit(\"stop\", e.time);\n              }\n\n              break;\n\n            case \"paused\":\n              _this2.emit(\"pause\", e.time);\n\n              break;\n          }\n        }); // the tick callbacks\n\n\n        this._tickSource.forEachTickBetween(startTime, endTime, function (time, ticks) {\n          _this2.callback(time, ticks);\n        });\n      }\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     * @return  The name of the state input in setStateAtTime.\n     * @example\n     * const clock = new Tone.Clock();\n     * clock.start(\"+0.1\");\n     * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n     */\n\n  }, {\n    key: \"getStateAtTime\",\n    value: function getStateAtTime(time) {\n      var computedTime = this.toSeconds(time);\n      return this._state.getValueAtTime(computedTime);\n    }\n    /**\n     * Clean up\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Clock.prototype), \"dispose\", this).call(this);\n\n      this.context.off(\"tick\", this._boundLoop);\n\n      this._tickSource.dispose();\n\n      this._state.dispose();\n\n      return this;\n    }\n  }, {\n    key: \"state\",\n\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get: function get() {\n      return this._state.getValueAtTime(this.now());\n    }\n  }, {\n    key: \"ticks\",\n    get: function get() {\n      return Math.ceil(this.getTicksAtTime(this.now()));\n    },\n    set: function set(t) {\n      this._tickSource.ticks = t;\n    }\n    /**\n     * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n     */\n\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this._tickSource.seconds;\n    },\n    set: function set(s) {\n      this._tickSource.seconds = s;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneWithContext.getDefaults(), {\n        callback: noOp,\n        frequency: 1,\n        units: \"hertz\"\n      });\n    }\n  }]);\n\n  return Clock;\n}(ToneWithContext);\nEmitter.mixin(Clock);","map":{"version":3,"sources":["../../../../Tone/core/clock/Clock.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n        this.name = \"Clock\";\n        /**\n         * The callback function to invoke at the scheduled tick.\n         */\n        this.callback = noOp;\n        /**\n         * The last time the loop callback was invoked\n         */\n        this._lastUpdate = 0;\n        /**\n         * Keep track of the playback state\n         */\n        this._state = new StateTimeline(\"stopped\");\n        /**\n         * Context bound reference to the _loop method\n         * This is necessary to remove the event in the end.\n         */\n        this._boundLoop = this._loop.bind(this);\n        const options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n        this.callback = options.callback;\n        this._tickSource = new TickSource({\n            context: this.context,\n            frequency: options.frequency,\n            units: options.units,\n        });\n        this._lastUpdate = 0;\n        this.frequency = this._tickSource.frequency;\n        readOnly(this, \"frequency\");\n        // add an initial state\n        this._state.setStateAtTime(\"stopped\", 0);\n        // bind a callback to the worker thread\n        this.context.on(\"tick\", this._boundLoop);\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            callback: noOp,\n            frequency: 1,\n            units: \"hertz\",\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    get state() {\n        return this._state.getValueAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset  Where the tick counter starts counting from.\n     */\n    start(time, offset) {\n        // make sure the context is running\n        assertContextRunning(this.context);\n        // start the loop\n        const computedTime = this.toSeconds(time);\n        this.log(\"start\", computedTime);\n        if (this._state.getValueAtTime(computedTime) !== \"started\") {\n            this._state.setStateAtTime(\"started\", computedTime);\n            this._tickSource.start(computedTime, offset);\n            if (computedTime < this._lastUpdate) {\n                this.emit(\"start\", computedTime, offset);\n            }\n        }\n        return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     * @example\n     * const clock = new Tone.Clock(time => {\n     * \tconsole.log(time);\n     * }, 1);\n     * clock.start();\n     * // stop the clock after 10 seconds\n     * clock.stop(\"+10\");\n     */\n    stop(time) {\n        const computedTime = this.toSeconds(time);\n        this.log(\"stop\", computedTime);\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"stopped\", computedTime);\n        this._tickSource.stop(computedTime);\n        if (computedTime < this._lastUpdate) {\n            this.emit(\"stop\", computedTime);\n        }\n        return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n    pause(time) {\n        const computedTime = this.toSeconds(time);\n        if (this._state.getValueAtTime(computedTime) === \"started\") {\n            this._state.setStateAtTime(\"paused\", computedTime);\n            this._tickSource.pause(computedTime);\n            if (computedTime < this._lastUpdate) {\n                this.emit(\"pause\", computedTime);\n            }\n        }\n        return this;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked.\n     */\n    get ticks() {\n        return Math.ceil(this.getTicksAtTime(this.now()));\n    }\n    set ticks(t) {\n        this._tickSource.ticks = t;\n    }\n    /**\n     * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n     */\n    get seconds() {\n        return this._tickSource.seconds;\n    }\n    set seconds(s) {\n        this._tickSource.seconds = s;\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        return this._tickSource.getSecondsAtTime(time);\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n    setTicksAtTime(ticks, time) {\n        this._tickSource.setTicksAtTime(ticks, time);\n        return this;\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n    getTimeOfTick(tick, before = this.now()) {\n        return this._tickSource.getTimeOfTick(tick, before);\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n    getTicksAtTime(time) {\n        return this._tickSource.getTicksAtTime(time);\n    }\n    /**\n     * Get the time of the next tick\n     * @param  offset The tick number.\n     */\n    nextTickTime(offset, when) {\n        const computedTime = this.toSeconds(when);\n        const currentTick = this.getTicksAtTime(computedTime);\n        return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n    }\n    /**\n     * The scheduling loop.\n     */\n    _loop() {\n        const startTime = this._lastUpdate;\n        const endTime = this.now();\n        this._lastUpdate = endTime;\n        this.log(\"loop\", startTime, endTime);\n        if (startTime !== endTime) {\n            // the state change events\n            this._state.forEachBetween(startTime, endTime, e => {\n                switch (e.state) {\n                    case \"started\":\n                        const offset = this._tickSource.getTicksAtTime(e.time);\n                        this.emit(\"start\", e.time, offset);\n                        break;\n                    case \"stopped\":\n                        if (e.time !== 0) {\n                            this.emit(\"stop\", e.time);\n                        }\n                        break;\n                    case \"paused\":\n                        this.emit(\"pause\", e.time);\n                        break;\n                }\n            });\n            // the tick callbacks\n            this._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n                this.callback(time, ticks);\n            });\n        }\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     * @return  The name of the state input in setStateAtTime.\n     * @example\n     * const clock = new Tone.Clock();\n     * clock.start(\"+0.1\");\n     * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n     */\n    getStateAtTime(time) {\n        const computedTime = this.toSeconds(time);\n        return this._state.getValueAtTime(computedTime);\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this.context.off(\"tick\", this._boundLoop);\n        this._tickSource.dispose();\n        this._state.dispose();\n        return this;\n    }\n}\nEmitter.mixin(Clock);\n//# sourceMappingURL=Clock.js.map"]},"metadata":{},"sourceType":"module"}