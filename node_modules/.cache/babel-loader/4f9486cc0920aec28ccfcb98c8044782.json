{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\n\nexport var Transport = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(Transport, _ToneWithContext);\n\n  var _super = _createSuper(Transport);\n\n  function Transport() {\n    var _this;\n\n    _classCallCheck(this, Transport);\n\n    _this = _super.call(this, optionsFromArguments(Transport.getDefaults(), arguments));\n    _this.name = \"Transport\"; //-------------------------------------\n    // \tLOOPING\n    //-------------------------------------\n\n    /**\n     * If the transport loops or not.\n     */\n\n    _this._loop = new TimelineValue(false);\n    /**\n     * The loop start position in ticks\n     */\n\n    _this._loopStart = 0;\n    /**\n     * The loop end position in ticks\n     */\n\n    _this._loopEnd = 0; //-------------------------------------\n    // \tTIMELINE EVENTS\n    //-------------------------------------\n\n    /**\n     * All the events in an object to keep track by ID\n     */\n\n    _this._scheduledEvents = {};\n    /**\n     * The scheduled events.\n     */\n\n    _this._timeline = new Timeline();\n    /**\n     * Repeated events\n     */\n\n    _this._repeatedEvents = new IntervalTimeline();\n    /**\n     * All of the synced Signals\n     */\n\n    _this._syncedSignals = [];\n    /**\n     * The swing amount\n     */\n\n    _this._swingAmount = 0;\n    var options = optionsFromArguments(Transport.getDefaults(), arguments); // CLOCK/TEMPO\n\n    _this._ppq = options.ppq;\n    _this._clock = new Clock({\n      callback: _this._processTick.bind(_assertThisInitialized(_this)),\n      context: _this.context,\n      frequency: 0,\n      units: \"bpm\"\n    });\n\n    _this._bindClockEvents();\n\n    _this.bpm = _this._clock.frequency;\n    _this._clock.frequency.multiplier = options.ppq;\n\n    _this.bpm.setValueAtTime(options.bpm, 0);\n\n    readOnly(_assertThisInitialized(_this), \"bpm\");\n    _this._timeSignature = options.timeSignature; // SWING\n\n    _this._swingTicks = options.ppq / 2; // 8n\n\n    return _this;\n  }\n\n  _createClass(Transport, [{\n    key: \"_processTick\",\n    //-------------------------------------\n    // \tTICKS\n    //-------------------------------------\n\n    /**\n     * called on every tick\n     * @param  tickTime clock relative tick time\n     */\n    value: function _processTick(tickTime, ticks) {\n      // handle swing\n      if (this._swingAmount > 0 && ticks % this._ppq !== 0 && // not on a downbeat\n      ticks % (this._swingTicks * 2) !== 0) {\n        // add some swing\n        var progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n\n        var amount = Math.sin(progress * Math.PI) * this._swingAmount;\n\n        tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n      } // do the loop test\n\n\n      if (this._loop.get(tickTime)) {\n        if (ticks >= this._loopEnd) {\n          this.emit(\"loopEnd\", tickTime);\n\n          this._clock.setTicksAtTime(this._loopStart, tickTime);\n\n          ticks = this._loopStart;\n          this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n          this.emit(\"loop\", tickTime);\n        }\n      } // invoke the timeline events scheduled on this tick\n\n\n      this._timeline.forEachAtTime(ticks, function (event) {\n        return event.invoke(tickTime);\n      });\n    } //-------------------------------------\n    // \tSCHEDULABLE EVENTS\n    //-------------------------------------\n\n    /**\n     * Schedule an event along the timeline.\n     * @param callback The callback to be invoked at the time.\n     * @param time The time to invoke the callback at.\n     * @return The id of the event which can be used for canceling the event.\n     * @example\n     * // schedule an event on the 16th measure\n     * Tone.Transport.schedule((time) => {\n     * \t// invoked on measure 16\n     * \tconsole.log(\"measure 16!\");\n     * }, \"16:0:0\");\n     */\n\n  }, {\n    key: \"schedule\",\n    value: function schedule(callback, time) {\n      var event = new TransportEvent(this, {\n        callback: callback,\n        time: new TransportTimeClass(this.context, time).toTicks()\n      });\n      return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Schedule a repeated event along the timeline. The event will fire\n     * at the `interval` starting at the `startTime` and for the specified\n     * `duration`.\n     * @param  callback   The callback to invoke.\n     * @param  interval   The duration between successive callbacks. Must be a positive number.\n     * @param  startTime  When along the timeline the events should start being invoked.\n     * @param  duration How long the event should repeat.\n     * @return  The ID of the scheduled event. Use this to cancel the event.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // a callback invoked every eighth note after the first measure\n     * Tone.Transport.scheduleRepeat((time) => {\n     * \tosc.start(time).stop(time + 0.1);\n     * }, \"8n\", \"1m\");\n     */\n\n  }, {\n    key: \"scheduleRepeat\",\n    value: function scheduleRepeat(callback, interval, startTime) {\n      var duration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      var event = new TransportRepeatEvent(this, {\n        callback: callback,\n        duration: new TimeClass(this.context, duration).toTicks(),\n        interval: new TimeClass(this.context, interval).toTicks(),\n        time: new TransportTimeClass(this.context, startTime).toTicks()\n      }); // kick it off if the Transport is started\n      // @ts-ignore\n\n      return this._addEvent(event, this._repeatedEvents);\n    }\n    /**\n     * Schedule an event that will be removed after it is invoked.\n     * @param callback The callback to invoke once.\n     * @param time The time the callback should be invoked.\n     * @returns The ID of the scheduled event.\n     */\n\n  }, {\n    key: \"scheduleOnce\",\n    value: function scheduleOnce(callback, time) {\n      var event = new TransportEvent(this, {\n        callback: callback,\n        once: true,\n        time: new TransportTimeClass(this.context, time).toTicks()\n      });\n      return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Clear the passed in event id from the timeline\n     * @param eventId The id of the event.\n     */\n\n  }, {\n    key: \"clear\",\n    value: function clear(eventId) {\n      if (this._scheduledEvents.hasOwnProperty(eventId)) {\n        var item = this._scheduledEvents[eventId.toString()];\n\n        item.timeline.remove(item.event);\n        item.event.dispose();\n        delete this._scheduledEvents[eventId.toString()];\n      }\n\n      return this;\n    }\n    /**\n     * Add an event to the correct timeline. Keep track of the\n     * timeline it was added to.\n     * @returns the event id which was just added\n     */\n\n  }, {\n    key: \"_addEvent\",\n    value: function _addEvent(event, timeline) {\n      this._scheduledEvents[event.id.toString()] = {\n        event: event,\n        timeline: timeline\n      };\n      timeline.add(event);\n      return event.id;\n    }\n    /**\n     * Remove scheduled events from the timeline after\n     * the given time. Repeated events will be removed\n     * if their startTime is after the given time\n     * @param after Clear all events after this time.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var _this2 = this;\n\n      var after = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var computedAfter = this.toTicks(after);\n\n      this._timeline.forEachFrom(computedAfter, function (event) {\n        return _this2.clear(event.id);\n      });\n\n      this._repeatedEvents.forEachFrom(computedAfter, function (event) {\n        return _this2.clear(event.id);\n      });\n\n      return this;\n    } //-------------------------------------\n    // \tSTART/STOP/PAUSE\n    //-------------------------------------\n\n    /**\n     * Bind start/stop/pause events from the clock and emit them.\n     */\n\n  }, {\n    key: \"_bindClockEvents\",\n    value: function _bindClockEvents() {\n      var _this3 = this;\n\n      this._clock.on(\"start\", function (time, offset) {\n        offset = new TicksClass(_this3.context, offset).toSeconds();\n\n        _this3.emit(\"start\", time, offset);\n      });\n\n      this._clock.on(\"stop\", function (time) {\n        _this3.emit(\"stop\", time);\n      });\n\n      this._clock.on(\"pause\", function (time) {\n        _this3.emit(\"pause\", time);\n      });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n     */\n\n  }, {\n    key: \"start\",\n\n    /**\n     * Start the transport and all sources synced to the transport.\n     * @param  time The time when the transport should start.\n     * @param  offset The timeline offset to start the transport.\n     * @example\n     * // start the transport in one second starting at beginning of the 5th measure.\n     * Tone.Transport.start(\"+1\", \"4:0:0\");\n     */\n    value: function start(time, offset) {\n      var offsetTicks;\n\n      if (isDefined(offset)) {\n        offsetTicks = this.toTicks(offset);\n      } // start the clock\n\n\n      this._clock.start(time, offsetTicks);\n\n      return this;\n    }\n    /**\n     * Stop the transport and all sources synced to the transport.\n     * @param time The time when the transport should stop.\n     * @example\n     * Tone.Transport.stop();\n     */\n\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      this._clock.stop(time);\n\n      return this;\n    }\n    /**\n     * Pause the transport and all sources synced to the transport.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause(time) {\n      this._clock.pause(time);\n\n      return this;\n    }\n    /**\n     * Toggle the current state of the transport. If it is\n     * started, it will stop it, otherwise it will start the Transport.\n     * @param  time The time of the event\n     */\n\n  }, {\n    key: \"toggle\",\n    value: function toggle(time) {\n      time = this.toSeconds(time);\n\n      if (this._clock.getStateAtTime(time) !== \"started\") {\n        this.start(time);\n      } else {\n        this.stop(time);\n      }\n\n      return this;\n    } //-------------------------------------\n    // \tSETTERS/GETTERS\n    //-------------------------------------\n\n    /**\n     * The time signature as just the numerator over 4.\n     * For example 4/4 would be just 4 and 6/8 would be 3.\n     * @example\n     * // common time\n     * Tone.Transport.timeSignature = 4;\n     * // 7/8\n     * Tone.Transport.timeSignature = [7, 8];\n     * // this will be reduced to a single number\n     * Tone.Transport.timeSignature; // returns 3.5\n     */\n\n  }, {\n    key: \"setLoopPoints\",\n\n    /**\n     * Set the loop start and stop at the same time.\n     * @example\n     * // loop over the first measure\n     * Tone.Transport.setLoopPoints(0, \"1m\");\n     * Tone.Transport.loop = true;\n     */\n    value: function setLoopPoints(startPosition, endPosition) {\n      this.loopStart = startPosition;\n      this.loopEnd = endPosition;\n      return this;\n    }\n    /**\n     * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n     */\n\n  }, {\n    key: \"getTicksAtTime\",\n\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n    value: function getTicksAtTime(time) {\n      return Math.round(this._clock.getTicksAtTime(time));\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n\n  }, {\n    key: \"getSecondsAtTime\",\n    value: function getSecondsAtTime(time) {\n      return this._clock.getSecondsAtTime(time);\n    }\n    /**\n     * Pulses Per Quarter note. This is the smallest resolution\n     * the Transport timing supports. This should be set once\n     * on initialization and not set again. Changing this value\n     * after other objects have been created can cause problems.\n     */\n\n  }, {\n    key: \"nextSubdivision\",\n    //-------------------------------------\n    // \tSYNCING\n    //-------------------------------------\n\n    /**\n     * Returns the time aligned to the next subdivision\n     * of the Transport. If the Transport is not started,\n     * it will return 0.\n     * Note: this will not work precisely during tempo ramps.\n     * @param  subdivision  The subdivision to quantize to\n     * @return  The context time of the next subdivision.\n     * @example\n     * // the transport must be started, otherwise returns 0\n     * Tone.Transport.start();\n     * Tone.Transport.nextSubdivision(\"4n\");\n     */\n    value: function nextSubdivision(subdivision) {\n      subdivision = this.toTicks(subdivision);\n\n      if (this.state !== \"started\") {\n        // if the transport's not started, return 0\n        return 0;\n      } else {\n        var now = this.now(); // the remainder of the current ticks and the subdivision\n\n        var transportPos = this.getTicksAtTime(now);\n        var remainingTicks = subdivision - transportPos % subdivision;\n        return this._clock.nextTickTime(remainingTicks, now);\n      }\n    }\n    /**\n     * Attaches the signal to the tempo control signal so that\n     * any changes in the tempo will change the signal in the same\n     * ratio.\n     *\n     * @param signal\n     * @param ratio Optionally pass in the ratio between the two signals.\n     * \t\t\tOtherwise it will be computed based on their current values.\n     */\n\n  }, {\n    key: \"syncSignal\",\n    value: function syncSignal(signal, ratio) {\n      if (!ratio) {\n        // get the sync ratio\n        var now = this.now();\n\n        if (signal.getValueAtTime(now) !== 0) {\n          var bpm = this.bpm.getValueAtTime(now);\n          var computedFreq = 1 / (60 / bpm / this.PPQ);\n          ratio = signal.getValueAtTime(now) / computedFreq;\n        } else {\n          ratio = 0;\n        }\n      }\n\n      var ratioSignal = new Gain(ratio); // @ts-ignore\n\n      this.bpm.connect(ratioSignal); // @ts-ignore\n\n      ratioSignal.connect(signal._param);\n\n      this._syncedSignals.push({\n        initial: signal.value,\n        ratio: ratioSignal,\n        signal: signal\n      });\n\n      signal.value = 0;\n      return this;\n    }\n    /**\n     * Unsyncs a previously synced signal from the transport's control.\n     * See Transport.syncSignal.\n     */\n\n  }, {\n    key: \"unsyncSignal\",\n    value: function unsyncSignal(signal) {\n      for (var i = this._syncedSignals.length - 1; i >= 0; i--) {\n        var syncedSignal = this._syncedSignals[i];\n\n        if (syncedSignal.signal === signal) {\n          syncedSignal.ratio.dispose();\n          syncedSignal.signal.value = syncedSignal.initial;\n\n          this._syncedSignals.splice(i, 1);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Clean up.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Transport.prototype), \"dispose\", this).call(this);\n\n      this._clock.dispose();\n\n      writable(this, \"bpm\");\n\n      this._timeline.dispose();\n\n      this._repeatedEvents.dispose();\n\n      return this;\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._clock.getStateAtTime(this.now());\n    }\n  }, {\n    key: \"timeSignature\",\n    get: function get() {\n      return this._timeSignature;\n    },\n    set: function set(timeSig) {\n      if (isArray(timeSig)) {\n        timeSig = timeSig[0] / timeSig[1] * 4;\n      }\n\n      this._timeSignature = timeSig;\n    }\n    /**\n     * When the Transport.loop = true, this is the starting position of the loop.\n     */\n\n  }, {\n    key: \"loopStart\",\n    get: function get() {\n      return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n    },\n    set: function set(startPosition) {\n      this._loopStart = this.toTicks(startPosition);\n    }\n    /**\n     * When the Transport.loop = true, this is the ending position of the loop.\n     */\n\n  }, {\n    key: \"loopEnd\",\n    get: function get() {\n      return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n    },\n    set: function set(endPosition) {\n      this._loopEnd = this.toTicks(endPosition);\n    }\n    /**\n     * If the transport loops or not.\n     */\n\n  }, {\n    key: \"loop\",\n    get: function get() {\n      return this._loop.get(this.now());\n    },\n    set: function set(loop) {\n      this._loop.set(loop, this.now());\n    }\n  }, {\n    key: \"swing\",\n    get: function get() {\n      return this._swingAmount;\n    },\n    set: function set(amount) {\n      // scale the values to a normal range\n      this._swingAmount = amount;\n    }\n    /**\n     * Set the subdivision which the swing will be applied to.\n     * The default value is an 8th note. Value must be less\n     * than a quarter note.\n     */\n\n  }, {\n    key: \"swingSubdivision\",\n    get: function get() {\n      return new TicksClass(this.context, this._swingTicks).toNotation();\n    },\n    set: function set(subdivision) {\n      this._swingTicks = this.toTicks(subdivision);\n    }\n    /**\n     * The Transport's position in Bars:Beats:Sixteenths.\n     * Setting the value will jump to that position right away.\n     */\n\n  }, {\n    key: \"position\",\n    get: function get() {\n      var now = this.now();\n\n      var ticks = this._clock.getTicksAtTime(now);\n\n      return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n    },\n    set: function set(progress) {\n      var ticks = this.toTicks(progress);\n      this.ticks = ticks;\n    }\n    /**\n     * The Transport's position in seconds\n     * Setting the value will jump to that position right away.\n     */\n\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this._clock.seconds;\n    },\n    set: function set(s) {\n      var now = this.now();\n\n      var ticks = this._clock.frequency.timeToTicks(s, now);\n\n      this.ticks = ticks;\n    }\n    /**\n     * The Transport's loop position as a normalized value. Always\n     * returns 0 if the transport if loop is not true.\n     */\n\n  }, {\n    key: \"progress\",\n    get: function get() {\n      if (this.loop) {\n        var now = this.now();\n\n        var ticks = this._clock.getTicksAtTime(now);\n\n        return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The transports current tick position.\n     */\n\n  }, {\n    key: \"ticks\",\n    get: function get() {\n      return this._clock.ticks;\n    },\n    set: function set(t) {\n      if (this._clock.ticks !== t) {\n        var now = this.now(); // stop everything synced to the transport\n\n        if (this.state === \"started\") {\n          var ticks = this._clock.getTicksAtTime(now); // schedule to start on the next tick, #573\n\n\n          var time = this._clock.getTimeOfTick(Math.ceil(ticks));\n\n          this.emit(\"stop\", time);\n\n          this._clock.setTicksAtTime(t, time); // restart it with the new time\n\n\n          this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n        } else {\n          this._clock.setTicksAtTime(t, now);\n        }\n      }\n    }\n  }, {\n    key: \"PPQ\",\n    get: function get() {\n      return this._clock.frequency.multiplier;\n    },\n    set: function set(ppq) {\n      this._clock.frequency.multiplier = ppq;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneWithContext.getDefaults(), {\n        bpm: 120,\n        loopEnd: \"4m\",\n        loopStart: 0,\n        ppq: 192,\n        swing: 0,\n        swingSubdivision: \"8n\",\n        timeSignature: 4\n      });\n    }\n  }]);\n\n  return Transport;\n}(ToneWithContext);\nEmitter.mixin(Transport); //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(function (context) {\n  context.transport = new Transport({\n    context: context\n  });\n});\nonContextClose(function (context) {\n  context.transport.dispose();\n});","map":{"version":3,"sources":["../../../../Tone/core/clock/Transport.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\nexport class Transport extends ToneWithContext {\n    constructor() {\n        super(optionsFromArguments(Transport.getDefaults(), arguments));\n        this.name = \"Transport\";\n        //-------------------------------------\n        // \tLOOPING\n        //-------------------------------------\n        /**\n         * If the transport loops or not.\n         */\n        this._loop = new TimelineValue(false);\n        /**\n         * The loop start position in ticks\n         */\n        this._loopStart = 0;\n        /**\n         * The loop end position in ticks\n         */\n        this._loopEnd = 0;\n        //-------------------------------------\n        // \tTIMELINE EVENTS\n        //-------------------------------------\n        /**\n         * All the events in an object to keep track by ID\n         */\n        this._scheduledEvents = {};\n        /**\n         * The scheduled events.\n         */\n        this._timeline = new Timeline();\n        /**\n         * Repeated events\n         */\n        this._repeatedEvents = new IntervalTimeline();\n        /**\n         * All of the synced Signals\n         */\n        this._syncedSignals = [];\n        /**\n         * The swing amount\n         */\n        this._swingAmount = 0;\n        const options = optionsFromArguments(Transport.getDefaults(), arguments);\n        // CLOCK/TEMPO\n        this._ppq = options.ppq;\n        this._clock = new Clock({\n            callback: this._processTick.bind(this),\n            context: this.context,\n            frequency: 0,\n            units: \"bpm\",\n        });\n        this._bindClockEvents();\n        this.bpm = this._clock.frequency;\n        this._clock.frequency.multiplier = options.ppq;\n        this.bpm.setValueAtTime(options.bpm, 0);\n        readOnly(this, \"bpm\");\n        this._timeSignature = options.timeSignature;\n        // SWING\n        this._swingTicks = options.ppq / 2; // 8n\n    }\n    static getDefaults() {\n        return Object.assign(ToneWithContext.getDefaults(), {\n            bpm: 120,\n            loopEnd: \"4m\",\n            loopStart: 0,\n            ppq: 192,\n            swing: 0,\n            swingSubdivision: \"8n\",\n            timeSignature: 4,\n        });\n    }\n    //-------------------------------------\n    // \tTICKS\n    //-------------------------------------\n    /**\n     * called on every tick\n     * @param  tickTime clock relative tick time\n     */\n    _processTick(tickTime, ticks) {\n        // handle swing\n        if (this._swingAmount > 0 &&\n            ticks % this._ppq !== 0 && // not on a downbeat\n            ticks % (this._swingTicks * 2) !== 0) {\n            // add some swing\n            const progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n            const amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n            tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n        }\n        // do the loop test\n        if (this._loop.get(tickTime)) {\n            if (ticks >= this._loopEnd) {\n                this.emit(\"loopEnd\", tickTime);\n                this._clock.setTicksAtTime(this._loopStart, tickTime);\n                ticks = this._loopStart;\n                this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n                this.emit(\"loop\", tickTime);\n            }\n        }\n        // invoke the timeline events scheduled on this tick\n        this._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n    }\n    //-------------------------------------\n    // \tSCHEDULABLE EVENTS\n    //-------------------------------------\n    /**\n     * Schedule an event along the timeline.\n     * @param callback The callback to be invoked at the time.\n     * @param time The time to invoke the callback at.\n     * @return The id of the event which can be used for canceling the event.\n     * @example\n     * // schedule an event on the 16th measure\n     * Tone.Transport.schedule((time) => {\n     * \t// invoked on measure 16\n     * \tconsole.log(\"measure 16!\");\n     * }, \"16:0:0\");\n     */\n    schedule(callback, time) {\n        const event = new TransportEvent(this, {\n            callback,\n            time: new TransportTimeClass(this.context, time).toTicks(),\n        });\n        return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Schedule a repeated event along the timeline. The event will fire\n     * at the `interval` starting at the `startTime` and for the specified\n     * `duration`.\n     * @param  callback   The callback to invoke.\n     * @param  interval   The duration between successive callbacks. Must be a positive number.\n     * @param  startTime  When along the timeline the events should start being invoked.\n     * @param  duration How long the event should repeat.\n     * @return  The ID of the scheduled event. Use this to cancel the event.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // a callback invoked every eighth note after the first measure\n     * Tone.Transport.scheduleRepeat((time) => {\n     * \tosc.start(time).stop(time + 0.1);\n     * }, \"8n\", \"1m\");\n     */\n    scheduleRepeat(callback, interval, startTime, duration = Infinity) {\n        const event = new TransportRepeatEvent(this, {\n            callback,\n            duration: new TimeClass(this.context, duration).toTicks(),\n            interval: new TimeClass(this.context, interval).toTicks(),\n            time: new TransportTimeClass(this.context, startTime).toTicks(),\n        });\n        // kick it off if the Transport is started\n        // @ts-ignore\n        return this._addEvent(event, this._repeatedEvents);\n    }\n    /**\n     * Schedule an event that will be removed after it is invoked.\n     * @param callback The callback to invoke once.\n     * @param time The time the callback should be invoked.\n     * @returns The ID of the scheduled event.\n     */\n    scheduleOnce(callback, time) {\n        const event = new TransportEvent(this, {\n            callback,\n            once: true,\n            time: new TransportTimeClass(this.context, time).toTicks(),\n        });\n        return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Clear the passed in event id from the timeline\n     * @param eventId The id of the event.\n     */\n    clear(eventId) {\n        if (this._scheduledEvents.hasOwnProperty(eventId)) {\n            const item = this._scheduledEvents[eventId.toString()];\n            item.timeline.remove(item.event);\n            item.event.dispose();\n            delete this._scheduledEvents[eventId.toString()];\n        }\n        return this;\n    }\n    /**\n     * Add an event to the correct timeline. Keep track of the\n     * timeline it was added to.\n     * @returns the event id which was just added\n     */\n    _addEvent(event, timeline) {\n        this._scheduledEvents[event.id.toString()] = {\n            event,\n            timeline,\n        };\n        timeline.add(event);\n        return event.id;\n    }\n    /**\n     * Remove scheduled events from the timeline after\n     * the given time. Repeated events will be removed\n     * if their startTime is after the given time\n     * @param after Clear all events after this time.\n     */\n    cancel(after = 0) {\n        const computedAfter = this.toTicks(after);\n        this._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n        this._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n        return this;\n    }\n    //-------------------------------------\n    // \tSTART/STOP/PAUSE\n    //-------------------------------------\n    /**\n     * Bind start/stop/pause events from the clock and emit them.\n     */\n    _bindClockEvents() {\n        this._clock.on(\"start\", (time, offset) => {\n            offset = new TicksClass(this.context, offset).toSeconds();\n            this.emit(\"start\", time, offset);\n        });\n        this._clock.on(\"stop\", (time) => {\n            this.emit(\"stop\", time);\n        });\n        this._clock.on(\"pause\", (time) => {\n            this.emit(\"pause\", time);\n        });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n     */\n    get state() {\n        return this._clock.getStateAtTime(this.now());\n    }\n    /**\n     * Start the transport and all sources synced to the transport.\n     * @param  time The time when the transport should start.\n     * @param  offset The timeline offset to start the transport.\n     * @example\n     * // start the transport in one second starting at beginning of the 5th measure.\n     * Tone.Transport.start(\"+1\", \"4:0:0\");\n     */\n    start(time, offset) {\n        let offsetTicks;\n        if (isDefined(offset)) {\n            offsetTicks = this.toTicks(offset);\n        }\n        // start the clock\n        this._clock.start(time, offsetTicks);\n        return this;\n    }\n    /**\n     * Stop the transport and all sources synced to the transport.\n     * @param time The time when the transport should stop.\n     * @example\n     * Tone.Transport.stop();\n     */\n    stop(time) {\n        this._clock.stop(time);\n        return this;\n    }\n    /**\n     * Pause the transport and all sources synced to the transport.\n     */\n    pause(time) {\n        this._clock.pause(time);\n        return this;\n    }\n    /**\n     * Toggle the current state of the transport. If it is\n     * started, it will stop it, otherwise it will start the Transport.\n     * @param  time The time of the event\n     */\n    toggle(time) {\n        time = this.toSeconds(time);\n        if (this._clock.getStateAtTime(time) !== \"started\") {\n            this.start(time);\n        }\n        else {\n            this.stop(time);\n        }\n        return this;\n    }\n    //-------------------------------------\n    // \tSETTERS/GETTERS\n    //-------------------------------------\n    /**\n     * The time signature as just the numerator over 4.\n     * For example 4/4 would be just 4 and 6/8 would be 3.\n     * @example\n     * // common time\n     * Tone.Transport.timeSignature = 4;\n     * // 7/8\n     * Tone.Transport.timeSignature = [7, 8];\n     * // this will be reduced to a single number\n     * Tone.Transport.timeSignature; // returns 3.5\n     */\n    get timeSignature() {\n        return this._timeSignature;\n    }\n    set timeSignature(timeSig) {\n        if (isArray(timeSig)) {\n            timeSig = (timeSig[0] / timeSig[1]) * 4;\n        }\n        this._timeSignature = timeSig;\n    }\n    /**\n     * When the Transport.loop = true, this is the starting position of the loop.\n     */\n    get loopStart() {\n        return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n    }\n    set loopStart(startPosition) {\n        this._loopStart = this.toTicks(startPosition);\n    }\n    /**\n     * When the Transport.loop = true, this is the ending position of the loop.\n     */\n    get loopEnd() {\n        return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n    }\n    set loopEnd(endPosition) {\n        this._loopEnd = this.toTicks(endPosition);\n    }\n    /**\n     * If the transport loops or not.\n     */\n    get loop() {\n        return this._loop.get(this.now());\n    }\n    set loop(loop) {\n        this._loop.set(loop, this.now());\n    }\n    /**\n     * Set the loop start and stop at the same time.\n     * @example\n     * // loop over the first measure\n     * Tone.Transport.setLoopPoints(0, \"1m\");\n     * Tone.Transport.loop = true;\n     */\n    setLoopPoints(startPosition, endPosition) {\n        this.loopStart = startPosition;\n        this.loopEnd = endPosition;\n        return this;\n    }\n    /**\n     * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n     */\n    get swing() {\n        return this._swingAmount;\n    }\n    set swing(amount) {\n        // scale the values to a normal range\n        this._swingAmount = amount;\n    }\n    /**\n     * Set the subdivision which the swing will be applied to.\n     * The default value is an 8th note. Value must be less\n     * than a quarter note.\n     */\n    get swingSubdivision() {\n        return new TicksClass(this.context, this._swingTicks).toNotation();\n    }\n    set swingSubdivision(subdivision) {\n        this._swingTicks = this.toTicks(subdivision);\n    }\n    /**\n     * The Transport's position in Bars:Beats:Sixteenths.\n     * Setting the value will jump to that position right away.\n     */\n    get position() {\n        const now = this.now();\n        const ticks = this._clock.getTicksAtTime(now);\n        return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n    }\n    set position(progress) {\n        const ticks = this.toTicks(progress);\n        this.ticks = ticks;\n    }\n    /**\n     * The Transport's position in seconds\n     * Setting the value will jump to that position right away.\n     */\n    get seconds() {\n        return this._clock.seconds;\n    }\n    set seconds(s) {\n        const now = this.now();\n        const ticks = this._clock.frequency.timeToTicks(s, now);\n        this.ticks = ticks;\n    }\n    /**\n     * The Transport's loop position as a normalized value. Always\n     * returns 0 if the transport if loop is not true.\n     */\n    get progress() {\n        if (this.loop) {\n            const now = this.now();\n            const ticks = this._clock.getTicksAtTime(now);\n            return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The transports current tick position.\n     */\n    get ticks() {\n        return this._clock.ticks;\n    }\n    set ticks(t) {\n        if (this._clock.ticks !== t) {\n            const now = this.now();\n            // stop everything synced to the transport\n            if (this.state === \"started\") {\n                const ticks = this._clock.getTicksAtTime(now);\n                // schedule to start on the next tick, #573\n                const time = this._clock.getTimeOfTick(Math.ceil(ticks));\n                this.emit(\"stop\", time);\n                this._clock.setTicksAtTime(t, time);\n                // restart it with the new time\n                this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n            }\n            else {\n                this._clock.setTicksAtTime(t, now);\n            }\n        }\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n    getTicksAtTime(time) {\n        return Math.round(this._clock.getTicksAtTime(time));\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n    getSecondsAtTime(time) {\n        return this._clock.getSecondsAtTime(time);\n    }\n    /**\n     * Pulses Per Quarter note. This is the smallest resolution\n     * the Transport timing supports. This should be set once\n     * on initialization and not set again. Changing this value\n     * after other objects have been created can cause problems.\n     */\n    get PPQ() {\n        return this._clock.frequency.multiplier;\n    }\n    set PPQ(ppq) {\n        this._clock.frequency.multiplier = ppq;\n    }\n    //-------------------------------------\n    // \tSYNCING\n    //-------------------------------------\n    /**\n     * Returns the time aligned to the next subdivision\n     * of the Transport. If the Transport is not started,\n     * it will return 0.\n     * Note: this will not work precisely during tempo ramps.\n     * @param  subdivision  The subdivision to quantize to\n     * @return  The context time of the next subdivision.\n     * @example\n     * // the transport must be started, otherwise returns 0\n     * Tone.Transport.start();\n     * Tone.Transport.nextSubdivision(\"4n\");\n     */\n    nextSubdivision(subdivision) {\n        subdivision = this.toTicks(subdivision);\n        if (this.state !== \"started\") {\n            // if the transport's not started, return 0\n            return 0;\n        }\n        else {\n            const now = this.now();\n            // the remainder of the current ticks and the subdivision\n            const transportPos = this.getTicksAtTime(now);\n            const remainingTicks = subdivision - transportPos % subdivision;\n            return this._clock.nextTickTime(remainingTicks, now);\n        }\n    }\n    /**\n     * Attaches the signal to the tempo control signal so that\n     * any changes in the tempo will change the signal in the same\n     * ratio.\n     *\n     * @param signal\n     * @param ratio Optionally pass in the ratio between the two signals.\n     * \t\t\tOtherwise it will be computed based on their current values.\n     */\n    syncSignal(signal, ratio) {\n        if (!ratio) {\n            // get the sync ratio\n            const now = this.now();\n            if (signal.getValueAtTime(now) !== 0) {\n                const bpm = this.bpm.getValueAtTime(now);\n                const computedFreq = 1 / (60 / bpm / this.PPQ);\n                ratio = signal.getValueAtTime(now) / computedFreq;\n            }\n            else {\n                ratio = 0;\n            }\n        }\n        const ratioSignal = new Gain(ratio);\n        // @ts-ignore\n        this.bpm.connect(ratioSignal);\n        // @ts-ignore\n        ratioSignal.connect(signal._param);\n        this._syncedSignals.push({\n            initial: signal.value,\n            ratio: ratioSignal,\n            signal,\n        });\n        signal.value = 0;\n        return this;\n    }\n    /**\n     * Unsyncs a previously synced signal from the transport's control.\n     * See Transport.syncSignal.\n     */\n    unsyncSignal(signal) {\n        for (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n            const syncedSignal = this._syncedSignals[i];\n            if (syncedSignal.signal === signal) {\n                syncedSignal.ratio.dispose();\n                syncedSignal.signal.value = syncedSignal.initial;\n                this._syncedSignals.splice(i, 1);\n            }\n        }\n        return this;\n    }\n    /**\n     * Clean up.\n     */\n    dispose() {\n        super.dispose();\n        this._clock.dispose();\n        writable(this, \"bpm\");\n        this._timeline.dispose();\n        this._repeatedEvents.dispose();\n        return this;\n    }\n}\nEmitter.mixin(Transport);\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit(context => {\n    context.transport = new Transport({ context });\n});\nonContextClose(context => {\n    context.transport.dispose();\n});\n//# sourceMappingURL=Transport.js.map"]},"metadata":{},"sourceType":"module"}