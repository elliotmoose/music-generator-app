{"ast":null,"code":"import _regeneratorRuntime from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst pulse = new Tone.PulseOscillator(50, 0.4).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\n\nexport var PulseOscillator = /*#__PURE__*/function (_Source) {\n  _inherits(PulseOscillator, _Source);\n\n  var _super = _createSuper(PulseOscillator);\n\n  function PulseOscillator() {\n    var _this;\n\n    _classCallCheck(this, PulseOscillator);\n\n    _this = _super.call(this, optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n    _this.name = \"PulseOscillator\";\n    /**\n     * gate the width amount\n     */\n\n    _this._widthGate = new Gain({\n      context: _this.context,\n      gain: 0\n    });\n    /**\n     * Threshold the signal to turn it into a square\n     */\n\n    _this._thresh = new WaveShaper({\n      context: _this.context,\n      mapping: function mapping(val) {\n        return val <= 0 ? -1 : 1;\n      }\n    });\n    var options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n    _this.width = new Signal({\n      context: _this.context,\n      units: \"audioRange\",\n      value: options.width\n    });\n    _this._triangle = new Oscillator({\n      context: _this.context,\n      detune: options.detune,\n      frequency: options.frequency,\n      onstop: function onstop() {\n        return _this.onstop(_assertThisInitialized(_this));\n      },\n      phase: options.phase,\n      type: \"triangle\"\n    });\n    _this.frequency = _this._triangle.frequency;\n    _this.detune = _this._triangle.detune; // connections\n\n    _this._triangle.chain(_this._thresh, _this.output);\n\n    _this.width.chain(_this._widthGate, _this._thresh);\n\n    readOnly(_assertThisInitialized(_this), [\"width\", \"frequency\", \"detune\"]);\n    return _this;\n  }\n\n  _createClass(PulseOscillator, [{\n    key: \"_start\",\n\n    /**\n     * start the oscillator\n     */\n    value: function _start(time) {\n      time = this.toSeconds(time);\n\n      this._triangle.start(time);\n\n      this._widthGate.gain.setValueAtTime(1, time);\n    }\n    /**\n     * stop the oscillator\n     */\n\n  }, {\n    key: \"_stop\",\n    value: function _stop(time) {\n      time = this.toSeconds(time);\n\n      this._triangle.stop(time); // the width is still connected to the output.\n      // that needs to be stopped also\n\n\n      this._widthGate.gain.cancelScheduledValues(time);\n\n      this._widthGate.gain.setValueAtTime(0, time);\n    }\n  }, {\n    key: \"_restart\",\n    value: function _restart(time) {\n      this._triangle.restart(time);\n\n      this._widthGate.gain.cancelScheduledValues(time);\n\n      this._widthGate.gain.setValueAtTime(1, time);\n    }\n    /**\n     * The phase of the oscillator in degrees.\n     */\n\n  }, {\n    key: \"asArray\",\n    value: function asArray() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                return _context.abrupt(\"return\", generateWaveform(this, length));\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Clean up method.\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(PulseOscillator.prototype), \"dispose\", this).call(this);\n\n      this._triangle.dispose();\n\n      this.width.dispose();\n\n      this._widthGate.dispose();\n\n      this._thresh.dispose();\n\n      return this;\n    }\n  }, {\n    key: \"phase\",\n    get: function get() {\n      return this._triangle.phase;\n    },\n    set: function set(phase) {\n      this._triangle.phase = phase;\n    }\n    /**\n     * The type of the oscillator. Always returns \"pulse\".\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return \"pulse\";\n    }\n    /**\n     * The baseType of the oscillator. Always returns \"pulse\".\n     */\n\n  }, {\n    key: \"baseType\",\n    get: function get() {\n      return \"pulse\";\n    }\n    /**\n     * The partials of the waveform. Cannot set partials for this waveform type\n     */\n\n  }, {\n    key: \"partials\",\n    get: function get() {\n      return [];\n    }\n    /**\n     * No partials for this waveform type.\n     */\n\n  }, {\n    key: \"partialCount\",\n    get: function get() {\n      return 0;\n    }\n    /**\n     * *Internal use* The carrier oscillator type is fed through the\n     * waveshaper node to create the pulse. Using different carrier oscillators\n     * changes oscillator's behavior.\n     */\n\n  }, {\n    key: \"carrierType\",\n    set: function set(type) {\n      this._triangle.type = type;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Source.getDefaults(), {\n        detune: 0,\n        frequency: 440,\n        phase: 0,\n        type: \"pulse\",\n        width: 0.2\n      });\n    }\n  }]);\n\n  return PulseOscillator;\n}(Source);","map":{"version":3,"sources":["../../../../Tone/source/oscillator/PulseOscillator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst pulse = new Tone.PulseOscillator(50, 0.4).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class PulseOscillator extends Source {\n    constructor() {\n        super(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n        this.name = \"PulseOscillator\";\n        /**\n         * gate the width amount\n         */\n        this._widthGate = new Gain({\n            context: this.context,\n            gain: 0,\n        });\n        /**\n         * Threshold the signal to turn it into a square\n         */\n        this._thresh = new WaveShaper({\n            context: this.context,\n            mapping: val => val <= 0 ? -1 : 1,\n        });\n        const options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n        this.width = new Signal({\n            context: this.context,\n            units: \"audioRange\",\n            value: options.width,\n        });\n        this._triangle = new Oscillator({\n            context: this.context,\n            detune: options.detune,\n            frequency: options.frequency,\n            onstop: () => this.onstop(this),\n            phase: options.phase,\n            type: \"triangle\",\n        });\n        this.frequency = this._triangle.frequency;\n        this.detune = this._triangle.detune;\n        // connections\n        this._triangle.chain(this._thresh, this.output);\n        this.width.chain(this._widthGate, this._thresh);\n        readOnly(this, [\"width\", \"frequency\", \"detune\"]);\n    }\n    static getDefaults() {\n        return Object.assign(Source.getDefaults(), {\n            detune: 0,\n            frequency: 440,\n            phase: 0,\n            type: \"pulse\",\n            width: 0.2,\n        });\n    }\n    /**\n     * start the oscillator\n     */\n    _start(time) {\n        time = this.toSeconds(time);\n        this._triangle.start(time);\n        this._widthGate.gain.setValueAtTime(1, time);\n    }\n    /**\n     * stop the oscillator\n     */\n    _stop(time) {\n        time = this.toSeconds(time);\n        this._triangle.stop(time);\n        // the width is still connected to the output.\n        // that needs to be stopped also\n        this._widthGate.gain.cancelScheduledValues(time);\n        this._widthGate.gain.setValueAtTime(0, time);\n    }\n    _restart(time) {\n        this._triangle.restart(time);\n        this._widthGate.gain.cancelScheduledValues(time);\n        this._widthGate.gain.setValueAtTime(1, time);\n    }\n    /**\n     * The phase of the oscillator in degrees.\n     */\n    get phase() {\n        return this._triangle.phase;\n    }\n    set phase(phase) {\n        this._triangle.phase = phase;\n    }\n    /**\n     * The type of the oscillator. Always returns \"pulse\".\n     */\n    get type() {\n        return \"pulse\";\n    }\n    /**\n     * The baseType of the oscillator. Always returns \"pulse\".\n     */\n    get baseType() {\n        return \"pulse\";\n    }\n    /**\n     * The partials of the waveform. Cannot set partials for this waveform type\n     */\n    get partials() {\n        return [];\n    }\n    /**\n     * No partials for this waveform type.\n     */\n    get partialCount() {\n        return 0;\n    }\n    /**\n     * *Internal use* The carrier oscillator type is fed through the\n     * waveshaper node to create the pulse. Using different carrier oscillators\n     * changes oscillator's behavior.\n     */\n    set carrierType(type) {\n        this._triangle.type = type;\n    }\n    asArray(length = 1024) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return generateWaveform(this, length);\n        });\n    }\n    /**\n     * Clean up method.\n     */\n    dispose() {\n        super.dispose();\n        this._triangle.dispose();\n        this.width.dispose();\n        this._widthGate.dispose();\n        this._thresh.dispose();\n        return this;\n    }\n}\n//# sourceMappingURL=PulseOscillator.js.map"]},"metadata":{},"sourceType":"module"}