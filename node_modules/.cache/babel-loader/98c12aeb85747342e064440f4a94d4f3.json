{"ast":null,"code":"import _objectSpread from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _objectWithoutProperties from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties\";\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport var createNativeConstantSourceNodeFakerFactory = function createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) {\n  return function (nativeContext, _ref) {\n    var offset = _ref.offset,\n        audioNodeOptions = _objectWithoutProperties(_ref, [\"offset\"]);\n\n    var audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n    var audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n      buffer: null,\n      channelCount: 2,\n      channelCountMode: 'max',\n      channelInterpretation: 'speakers',\n      loop: false,\n      loopEnd: 0,\n      loopStart: 0,\n      playbackRate: 1\n    });\n    var gainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      gain: offset\n    })); // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n\n    var channelData = audioBuffer.getChannelData(0); // Bug #95: Safari does not play or loop one sample buffers.\n\n    channelData[0] = 1;\n    channelData[1] = 1;\n    audioBufferSourceNode.buffer = audioBuffer;\n    audioBufferSourceNode.loop = true;\n    var nativeConstantSourceNodeFaker = {\n      get bufferSize() {\n        return undefined;\n      },\n\n      get channelCount() {\n        return gainNode.channelCount;\n      },\n\n      set channelCount(value) {\n        gainNode.channelCount = value;\n      },\n\n      get channelCountMode() {\n        return gainNode.channelCountMode;\n      },\n\n      set channelCountMode(value) {\n        gainNode.channelCountMode = value;\n      },\n\n      get channelInterpretation() {\n        return gainNode.channelInterpretation;\n      },\n\n      set channelInterpretation(value) {\n        gainNode.channelInterpretation = value;\n      },\n\n      get context() {\n        return gainNode.context;\n      },\n\n      get inputs() {\n        return [];\n      },\n\n      get numberOfInputs() {\n        return audioBufferSourceNode.numberOfInputs;\n      },\n\n      get numberOfOutputs() {\n        return gainNode.numberOfOutputs;\n      },\n\n      get offset() {\n        return gainNode.gain;\n      },\n\n      get onended() {\n        return audioBufferSourceNode.onended;\n      },\n\n      set onended(value) {\n        audioBufferSourceNode.onended = value;\n      },\n\n      addEventListener: function addEventListener() {\n        return audioBufferSourceNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n      dispatchEvent: function dispatchEvent() {\n        return audioBufferSourceNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n      removeEventListener: function removeEventListener() {\n        return audioBufferSourceNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n      start: function start() {\n        var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n      },\n      stop: function stop() {\n        var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n      }\n    };\n\n    var whenConnected = function whenConnected() {\n      return audioBufferSourceNode.connect(gainNode);\n    };\n\n    var whenDisconnected = function whenDisconnected() {\n      return audioBufferSourceNode.disconnect(gainNode);\n    }; // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n\n\n    addSilentConnection(nativeContext, audioBufferSourceNode);\n    return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"sources":["../../../src/factories/native-constant-source-node-faker-factory.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { interceptConnections } from '../helpers/intercept-connections';\nexport const createNativeConstantSourceNodeFakerFactory = (addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize() {\n                return undefined;\n            },\n            get channelCount() {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode() {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation() {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context() {\n                return gainNode.context;\n            },\n            get inputs() {\n                return [];\n            },\n            get numberOfInputs() {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs() {\n                return gainNode.numberOfOutputs;\n            },\n            get offset() {\n                return gainNode.gain;\n            },\n            get onended() {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = value;\n            },\n            addEventListener(...args) {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args) {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args) {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0) {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0) {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n//# sourceMappingURL=native-constant-source-node-faker-factory.js.map"]},"metadata":{},"sourceType":"module"}