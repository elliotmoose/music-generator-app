{"ast":null,"code":"var BaseTexture = require('./BaseTexture'),\n    Texture = require('./Texture'),\n    RenderTarget = require('../renderers/webgl/utils/RenderTarget'),\n    FilterManager = require('../renderers/webgl/managers/FilterManager'),\n    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),\n    math = require('../math'),\n    CONST = require('../const'),\n    tempMatrix = new math.Matrix();\n/**\n * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded\n * otherwise black rectangles will be drawn instead.\n *\n * A RenderTexture takes a snapshot of any Display Object given to its render method. The position\n * and rotation of the given Display Objects is ignored. For example:\n *\n * ```js\n * var renderTexture = new PIXI.RenderTexture(800, 600);\n * var sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *\n * sprite.position.x = 800/2;\n * sprite.position.y = 600/2;\n * sprite.anchor.x = 0.5;\n * sprite.anchor.y = 0.5;\n *\n * renderTexture.render(sprite);\n * ```\n *\n * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual\n * position a Container should be used:\n *\n * ```js\n * var doc = new Container();\n *\n * doc.addChild(sprite);\n *\n * renderTexture.render(doc);  // Renders to center of renderTexture\n * ```\n *\n * @class\n * @extends PIXI.Texture\n * @memberof PIXI\n * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used for this RenderTexture\n * @param [width=100] {number} The width of the render texture\n * @param [height=100] {number} The height of the render texture\n * @param [scaleMode] {number} See {@link SCALE_MODES} for possible values\n * @param [resolution=1] {number} The resolution of the texture being generated\n */\n\n\nfunction RenderTexture(renderer, width, height, scaleMode, resolution) {\n  if (!renderer) {\n    throw new Error('Unable to create RenderTexture, you must pass a renderer into the constructor.');\n  }\n\n  width = width || 100;\n  height = height || 100;\n  resolution = resolution || CONST.RESOLUTION;\n  /**\n   * The base texture object that this texture uses\n   *\n   * @member {BaseTexture}\n   */\n\n  var baseTexture = new BaseTexture();\n  baseTexture.width = width;\n  baseTexture.height = height;\n  baseTexture.resolution = resolution;\n  baseTexture.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;\n  baseTexture.hasLoaded = true;\n  Texture.call(this, baseTexture, new math.Rectangle(0, 0, width, height));\n  /**\n   * The with of the render texture\n   *\n   * @member {number}\n   */\n\n  this.width = width;\n  /**\n   * The height of the render texture\n   *\n   * @member {number}\n   */\n\n  this.height = height;\n  /**\n   * The Resolution of the texture.\n   *\n   * @member {number}\n   */\n\n  this.resolution = resolution;\n  /**\n   * The framing rectangle of the render texture\n   *\n   * @member {Rectangle}\n   */\n  //this._frame = new math.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);\n\n  /**\n   * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n   * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n   *\n   * @member {Rectangle}\n   */\n  //this.crop = new math.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);\n\n  /**\n   * Draw/render the given DisplayObject onto the texture.\n   *\n   * The displayObject and descendents are transformed during this operation.\n   * If `updateTransform` is true then the transformations will be restored before the\n   * method returns. Otherwise it is up to the calling code to correctly use or reset\n   * the transformed display objects.\n   *\n   * The display object is always rendered with a worldAlpha value of 1.\n   *\n   * @method\n   * @param displayObject {DisplayObject} The display object to render this texture on\n   * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n   * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn\n   * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children\n   *  transformations will be restored. Not restoring this information will be a little faster.\n   */\n\n  this.render = null;\n  /**\n   * The renderer this RenderTexture uses. A RenderTexture can only belong to one renderer at the moment if its webGL.\n   *\n   * @member {CanvasRenderer|WebGLRenderer}\n   */\n\n  this.renderer = renderer;\n\n  if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL) {\n    var gl = this.renderer.gl;\n    this.textureBuffer = new RenderTarget(gl, this.width, this.height, baseTexture.scaleMode, this.resolution); //, this.baseTexture.scaleMode);\n\n    this.baseTexture._glTextures[gl.id] = this.textureBuffer.texture; //TODO refactor filter manager.. as really its no longer a manager if we use it here..\n\n    this.filterManager = new FilterManager(this.renderer);\n    this.filterManager.onContextChange();\n    this.filterManager.resize(width, height);\n    this.render = this.renderWebGL; // the creation of a filter manager unbinds the buffers..\n\n    this.renderer.currentRenderer.start();\n    this.renderer.currentRenderTarget.activate();\n  } else {\n    this.render = this.renderCanvas;\n    this.textureBuffer = new CanvasBuffer(this.width * this.resolution, this.height * this.resolution);\n    this.baseTexture.source = this.textureBuffer.canvas;\n  }\n  /**\n   * @member {boolean}\n   */\n\n\n  this.valid = true;\n\n  this._updateUvs();\n}\n\nRenderTexture.prototype = Object.create(Texture.prototype);\nRenderTexture.prototype.constructor = RenderTexture;\nmodule.exports = RenderTexture;\n/**\n * Resizes the RenderTexture.\n *\n * @param width {number} The width to resize to.\n * @param height {number} The height to resize to.\n * @param updateBase {boolean} Should the baseTexture.width and height values be resized as well?\n */\n\nRenderTexture.prototype.resize = function (width, height, updateBase) {\n  if (width === this.width && height === this.height) {\n    return;\n  }\n\n  this.valid = width > 0 && height > 0;\n  this.width = this._frame.width = this.crop.width = width;\n  this.height = this._frame.height = this.crop.height = height;\n\n  if (updateBase) {\n    this.baseTexture.width = this.width;\n    this.baseTexture.height = this.height;\n  }\n\n  if (!this.valid) {\n    return;\n  }\n\n  this.textureBuffer.resize(this.width, this.height);\n\n  if (this.filterManager) {\n    this.filterManager.resize(this.width, this.height);\n  }\n};\n/**\n * Clears the RenderTexture.\n *\n */\n\n\nRenderTexture.prototype.clear = function () {\n  if (!this.valid) {\n    return;\n  }\n\n  if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL) {\n    this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n  }\n\n  this.textureBuffer.clear();\n};\n/**\n * Internal method assigned to the `render` property if using a CanvasRenderer.\n *\n * @private\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn\n * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children\n *  transformations will be restored. Not restoring this information will be a little faster.\n */\n\n\nRenderTexture.prototype.renderWebGL = function (displayObject, matrix, clear, updateTransform) {\n  if (!this.valid) {\n    return;\n  }\n\n  updateTransform = updateTransform !== undefined ? updateTransform : true; //!updateTransform;\n\n  this.textureBuffer.transform = matrix; //TODO not a fan that this is here... it will move!\n\n  this.textureBuffer.activate(); // setWorld Alpha to ensure that the object is renderer at full opacity\n\n  displayObject.worldAlpha = 1;\n\n  if (updateTransform) {\n    // reset the matrix of the displatyObject..\n    displayObject.worldTransform.identity();\n    displayObject.currentBounds = null; // Time to update all the children of the displayObject with the new matrix..\n\n    var children = displayObject.children;\n    var i, j;\n\n    for (i = 0, j = children.length; i < j; ++i) {\n      children[i].updateTransform();\n    }\n  } //TODO rename textureBuffer to renderTarget..\n\n\n  var temp = this.renderer.filterManager;\n  this.renderer.filterManager = this.filterManager;\n  this.renderer.renderDisplayObject(displayObject, this.textureBuffer, clear);\n  this.renderer.filterManager = temp;\n};\n/**\n * Internal method assigned to the `render` property if using a CanvasRenderer.\n *\n * @private\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n * @param [clear] {boolean} If true the texture will be cleared before the displayObject is drawn\n */\n\n\nRenderTexture.prototype.renderCanvas = function (displayObject, matrix, clear, updateTransform) {\n  if (!this.valid) {\n    return;\n  }\n\n  updateTransform = !!updateTransform;\n  var cachedWt = displayObject.worldTransform;\n  var wt = tempMatrix;\n  wt.identity();\n\n  if (matrix) {\n    wt.append(matrix);\n  }\n\n  displayObject.worldTransform = wt; // setWorld Alpha to ensure that the object is renderer at full opacity\n\n  displayObject.worldAlpha = 1; // Time to update all the children of the displayObject with the new matrix..\n\n  var children = displayObject.children;\n  var i, j;\n\n  for (i = 0, j = children.length; i < j; ++i) {\n    children[i].updateTransform();\n  }\n\n  if (clear) {\n    this.textureBuffer.clear();\n  }\n\n  displayObject.worldTransform = cachedWt; //    this.textureBuffer.\n\n  var context = this.textureBuffer.context;\n  var realResolution = this.renderer.resolution;\n  this.renderer.resolution = this.resolution;\n  this.renderer.renderDisplayObject(displayObject, context);\n  this.renderer.resolution = realResolution; //   context.setTransform(1, 0, 0, 1, 0, 0);\n  // context.fillStyle =\"#FF0000\"\n  //    context.fillRect(0, 0, 800, 600);\n};\n/**\n * Destroys this texture\n *\n * @param destroyBase {boolean} Whether to destroy the base texture as well\n */\n\n\nRenderTexture.prototype.destroy = function () {\n  Texture.prototype.destroy.call(this, true);\n  this.textureBuffer.destroy(); // destroy the filtermanager..\n\n  if (this.filterManager) {\n    this.filterManager.destroy();\n  }\n\n  this.renderer = null;\n};\n/**\n * Will return a HTML Image of the texture\n *\n * @return {Image}\n */\n\n\nRenderTexture.prototype.getImage = function () {\n  var image = new Image();\n  image.src = this.getBase64();\n  return image;\n};\n/**\n * Will return a a base64 encoded string of this texture. It works by calling RenderTexture.getCanvas and then running toDataURL on that.\n *\n * @return {string} A base64 encoded string of the texture.\n */\n\n\nRenderTexture.prototype.getBase64 = function () {\n  return this.getCanvas().toDataURL();\n};\n/**\n * Creates a Canvas element, renders this RenderTexture to it and then returns it.\n *\n * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n */\n\n\nRenderTexture.prototype.getCanvas = function () {\n  if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL) {\n    var gl = this.renderer.gl;\n    var width = this.textureBuffer.size.width;\n    var height = this.textureBuffer.size.height;\n    var webGLPixels = new Uint8Array(4 * width * height);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    var tempCanvas = new CanvasBuffer(width, height);\n    var canvasData = tempCanvas.context.getImageData(0, 0, width, height);\n    canvasData.data.set(webGLPixels);\n    tempCanvas.context.putImageData(canvasData, 0, 0);\n    return tempCanvas.canvas;\n  } else {\n    return this.textureBuffer.canvas;\n  }\n};\n/**\n * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA order, with integer values between 0 and 255 (included).\n *\n * @return {Uint8ClampedArray}\n */\n\n\nRenderTexture.prototype.getPixels = function () {\n  var width, height;\n\n  if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL) {\n    var gl = this.renderer.gl;\n    width = this.textureBuffer.size.width;\n    height = this.textureBuffer.size.height;\n    var webGLPixels = new Uint8Array(4 * width * height);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n    gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return webGLPixels;\n  } else {\n    width = this.textureBuffer.canvas.width;\n    height = this.textureBuffer.canvas.height;\n    return this.textureBuffer.canvas.getContext('2d').getImageData(0, 0, width, height).data;\n  }\n};\n/**\n * Will return a one-dimensional array containing the pixel data of a pixel within the texture in RGBA order, with integer values between 0 and 255 (included).\n *\n * @param x {number} The x coordinate of the pixel to retrieve.\n * @param y {number} The y coordinate of the pixel to retrieve.\n * @return {Uint8ClampedArray}\n */\n\n\nRenderTexture.prototype.getPixel = function (x, y) {\n  if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL) {\n    var gl = this.renderer.gl;\n    var webGLPixels = new Uint8Array(4);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    return webGLPixels;\n  } else {\n    return this.textureBuffer.canvas.getContext('2d').getImageData(x, y, 1, 1).data;\n  }\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/textures/RenderTexture.js"],"names":["BaseTexture","require","Texture","RenderTarget","FilterManager","CanvasBuffer","math","CONST","tempMatrix","Matrix","RenderTexture","renderer","width","height","scaleMode","resolution","Error","RESOLUTION","baseTexture","SCALE_MODES","DEFAULT","hasLoaded","call","Rectangle","render","type","RENDERER_TYPE","WEBGL","gl","textureBuffer","_glTextures","id","texture","filterManager","onContextChange","resize","renderWebGL","currentRenderer","start","currentRenderTarget","activate","renderCanvas","source","canvas","valid","_updateUvs","prototype","Object","create","constructor","module","exports","updateBase","_frame","crop","clear","bindFramebuffer","FRAMEBUFFER","frameBuffer","displayObject","matrix","updateTransform","undefined","transform","worldAlpha","worldTransform","identity","currentBounds","children","i","j","length","temp","renderDisplayObject","cachedWt","wt","append","context","realResolution","destroy","getImage","image","Image","src","getBase64","getCanvas","toDataURL","size","webGLPixels","Uint8Array","readPixels","RGBA","UNSIGNED_BYTE","tempCanvas","canvasData","getImageData","data","set","putImageData","getPixels","getContext","getPixel","x","y"],"mappings":"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","sourcesContent":["var BaseTexture = require('./BaseTexture'),\n    Texture = require('./Texture'),\n    RenderTarget = require('../renderers/webgl/utils/RenderTarget'),\n    FilterManager = require('../renderers/webgl/managers/FilterManager'),\n    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),\n    math = require('../math'),\n    CONST = require('../const'),\n    tempMatrix = new math.Matrix();\n\n/**\n * A RenderTexture is a special texture that allows any Pixi display object to be rendered to it.\n *\n * __Hint__: All DisplayObjects (i.e. Sprites) that render to a RenderTexture should be preloaded\n * otherwise black rectangles will be drawn instead.\n *\n * A RenderTexture takes a snapshot of any Display Object given to its render method. The position\n * and rotation of the given Display Objects is ignored. For example:\n *\n * ```js\n * var renderTexture = new PIXI.RenderTexture(800, 600);\n * var sprite = PIXI.Sprite.fromImage(\"spinObj_01.png\");\n *\n * sprite.position.x = 800/2;\n * sprite.position.y = 600/2;\n * sprite.anchor.x = 0.5;\n * sprite.anchor.y = 0.5;\n *\n * renderTexture.render(sprite);\n * ```\n *\n * The Sprite in this case will be rendered to a position of 0,0. To render this sprite at its actual\n * position a Container should be used:\n *\n * ```js\n * var doc = new Container();\n *\n * doc.addChild(sprite);\n *\n * renderTexture.render(doc);  // Renders to center of renderTexture\n * ```\n *\n * @class\n * @extends PIXI.Texture\n * @memberof PIXI\n * @param renderer {CanvasRenderer|WebGLRenderer} The renderer used for this RenderTexture\n * @param [width=100] {number} The width of the render texture\n * @param [height=100] {number} The height of the render texture\n * @param [scaleMode] {number} See {@link SCALE_MODES} for possible values\n * @param [resolution=1] {number} The resolution of the texture being generated\n */\nfunction RenderTexture(renderer, width, height, scaleMode, resolution)\n{\n    if (!renderer)\n    {\n        throw new Error('Unable to create RenderTexture, you must pass a renderer into the constructor.');\n    }\n\n    width = width || 100;\n    height = height || 100;\n    resolution = resolution || CONST.RESOLUTION;\n\n    /**\n     * The base texture object that this texture uses\n     *\n     * @member {BaseTexture}\n     */\n    var baseTexture = new BaseTexture();\n    baseTexture.width = width;\n    baseTexture.height = height;\n    baseTexture.resolution = resolution;\n    baseTexture.scaleMode = scaleMode || CONST.SCALE_MODES.DEFAULT;\n    baseTexture.hasLoaded = true;\n\n\n    Texture.call(this,\n        baseTexture,\n        new math.Rectangle(0, 0, width, height)\n    );\n\n\n    /**\n     * The with of the render texture\n     *\n     * @member {number}\n     */\n    this.width = width;\n\n    /**\n     * The height of the render texture\n     *\n     * @member {number}\n     */\n    this.height = height;\n\n    /**\n     * The Resolution of the texture.\n     *\n     * @member {number}\n     */\n    this.resolution = resolution;\n\n    /**\n     * The framing rectangle of the render texture\n     *\n     * @member {Rectangle}\n     */\n    //this._frame = new math.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);\n\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     *\n     * @member {Rectangle}\n     */\n    //this.crop = new math.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution);\n\n    /**\n     * Draw/render the given DisplayObject onto the texture.\n     *\n     * The displayObject and descendents are transformed during this operation.\n     * If `updateTransform` is true then the transformations will be restored before the\n     * method returns. Otherwise it is up to the calling code to correctly use or reset\n     * the transformed display objects.\n     *\n     * The display object is always rendered with a worldAlpha value of 1.\n     *\n     * @method\n     * @param displayObject {DisplayObject} The display object to render this texture on\n     * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n     * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn\n     * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children\n     *  transformations will be restored. Not restoring this information will be a little faster.\n     */\n    this.render = null;\n\n    /**\n     * The renderer this RenderTexture uses. A RenderTexture can only belong to one renderer at the moment if its webGL.\n     *\n     * @member {CanvasRenderer|WebGLRenderer}\n     */\n    this.renderer = renderer;\n\n    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)\n    {\n        var gl = this.renderer.gl;\n\n        this.textureBuffer = new RenderTarget(gl, this.width, this.height, baseTexture.scaleMode, this.resolution);//, this.baseTexture.scaleMode);\n        this.baseTexture._glTextures[gl.id] =  this.textureBuffer.texture;\n\n        //TODO refactor filter manager.. as really its no longer a manager if we use it here..\n        this.filterManager = new FilterManager(this.renderer);\n        this.filterManager.onContextChange();\n        this.filterManager.resize(width, height);\n        this.render = this.renderWebGL;\n\n        // the creation of a filter manager unbinds the buffers..\n        this.renderer.currentRenderer.start();\n        this.renderer.currentRenderTarget.activate();\n    }\n    else\n    {\n\n        this.render = this.renderCanvas;\n        this.textureBuffer = new CanvasBuffer(this.width* this.resolution, this.height* this.resolution);\n        this.baseTexture.source = this.textureBuffer.canvas;\n    }\n\n    /**\n     * @member {boolean}\n     */\n    this.valid = true;\n\n    this._updateUvs();\n}\n\nRenderTexture.prototype = Object.create(Texture.prototype);\nRenderTexture.prototype.constructor = RenderTexture;\nmodule.exports = RenderTexture;\n\n/**\n * Resizes the RenderTexture.\n *\n * @param width {number} The width to resize to.\n * @param height {number} The height to resize to.\n * @param updateBase {boolean} Should the baseTexture.width and height values be resized as well?\n */\nRenderTexture.prototype.resize = function (width, height, updateBase)\n{\n    if (width === this.width && height === this.height)\n    {\n        return;\n    }\n\n    this.valid = (width > 0 && height > 0);\n\n    this.width = this._frame.width = this.crop.width = width;\n    this.height =  this._frame.height = this.crop.height = height;\n\n    if (updateBase)\n    {\n        this.baseTexture.width = this.width;\n        this.baseTexture.height = this.height;\n    }\n\n    if (!this.valid)\n    {\n        return;\n    }\n\n    this.textureBuffer.resize(this.width, this.height);\n\n    if(this.filterManager)\n    {\n        this.filterManager.resize(this.width, this.height);\n    }\n};\n\n/**\n * Clears the RenderTexture.\n *\n */\nRenderTexture.prototype.clear = function ()\n{\n    if (!this.valid)\n    {\n        return;\n    }\n\n    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)\n    {\n        this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n    }\n\n    this.textureBuffer.clear();\n};\n\n/**\n * Internal method assigned to the `render` property if using a CanvasRenderer.\n *\n * @private\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n * @param [clear=false] {boolean} If true the texture will be cleared before the displayObject is drawn\n * @param [updateTransform=true] {boolean} If true the displayObject's worldTransform/worldAlpha and all children\n *  transformations will be restored. Not restoring this information will be a little faster.\n */\nRenderTexture.prototype.renderWebGL = function (displayObject, matrix, clear, updateTransform)\n{\n    if (!this.valid)\n    {\n        return;\n    }\n\n\n    updateTransform = (updateTransform !== undefined) ? updateTransform : true;//!updateTransform;\n\n    this.textureBuffer.transform = matrix;\n\n    //TODO not a fan that this is here... it will move!\n    this.textureBuffer.activate();\n    \n    // setWorld Alpha to ensure that the object is renderer at full opacity\n    displayObject.worldAlpha = 1;\n\n    if (updateTransform)\n    {\n\n        // reset the matrix of the displatyObject..\n        displayObject.worldTransform.identity();\n\n        displayObject.currentBounds = null;\n\n        // Time to update all the children of the displayObject with the new matrix..\n        var children = displayObject.children;\n        var i, j;\n\n        for (i = 0, j = children.length; i < j; ++i)\n        {\n            children[i].updateTransform();\n        }\n    }\n\n    //TODO rename textureBuffer to renderTarget..\n    var temp =  this.renderer.filterManager;\n\n    this.renderer.filterManager = this.filterManager;\n    this.renderer.renderDisplayObject(displayObject, this.textureBuffer, clear);\n\n    this.renderer.filterManager = temp;\n};\n\n\n/**\n * Internal method assigned to the `render` property if using a CanvasRenderer.\n *\n * @private\n * @param displayObject {DisplayObject} The display object to render this texture on\n * @param [matrix] {Matrix} Optional matrix to apply to the display object before rendering.\n * @param [clear] {boolean} If true the texture will be cleared before the displayObject is drawn\n */\nRenderTexture.prototype.renderCanvas = function (displayObject, matrix, clear, updateTransform)\n{\n    if (!this.valid)\n    {\n        return;\n    }\n\n    updateTransform = !!updateTransform;\n    var cachedWt = displayObject.worldTransform;\n\n    var wt = tempMatrix;\n\n    wt.identity();\n\n    if (matrix)\n    {\n        wt.append(matrix);\n    }\n\n    displayObject.worldTransform = wt;\n\n    // setWorld Alpha to ensure that the object is renderer at full opacity\n    displayObject.worldAlpha = 1;\n\n    // Time to update all the children of the displayObject with the new matrix..\n    var children = displayObject.children;\n    var i, j;\n\n    for (i = 0, j = children.length; i < j; ++i)\n    {\n        children[i].updateTransform();\n    }\n\n    if (clear)\n    {\n        this.textureBuffer.clear();\n    }\n\n    displayObject.worldTransform = cachedWt;\n\n//    this.textureBuffer.\n    var context = this.textureBuffer.context;\n\n    var realResolution = this.renderer.resolution;\n\n    this.renderer.resolution = this.resolution;\n\n    this.renderer.renderDisplayObject(displayObject, context);\n\n    this.renderer.resolution = realResolution;\n //   context.setTransform(1, 0, 0, 1, 0, 0);\n   // context.fillStyle =\"#FF0000\"\n//    context.fillRect(0, 0, 800, 600);\n\n};\n\n/**\n * Destroys this texture\n *\n * @param destroyBase {boolean} Whether to destroy the base texture as well\n */\nRenderTexture.prototype.destroy = function ()\n{\n    Texture.prototype.destroy.call(this, true);\n\n    this.textureBuffer.destroy();\n\n    // destroy the filtermanager..\n    if(this.filterManager)\n    {\n        this.filterManager.destroy();\n    }\n\n    this.renderer = null;\n};\n\n/**\n * Will return a HTML Image of the texture\n *\n * @return {Image}\n */\nRenderTexture.prototype.getImage = function ()\n{\n    var image = new Image();\n    image.src = this.getBase64();\n    return image;\n};\n\n/**\n * Will return a a base64 encoded string of this texture. It works by calling RenderTexture.getCanvas and then running toDataURL on that.\n *\n * @return {string} A base64 encoded string of the texture.\n */\nRenderTexture.prototype.getBase64 = function ()\n{\n    return this.getCanvas().toDataURL();\n};\n\n/**\n * Creates a Canvas element, renders this RenderTexture to it and then returns it.\n *\n * @return {HTMLCanvasElement} A Canvas element with the texture rendered on.\n */\nRenderTexture.prototype.getCanvas = function ()\n{\n    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)\n    {\n        var gl = this.renderer.gl;\n        var width = this.textureBuffer.size.width;\n        var height = this.textureBuffer.size.height;\n\n        var webGLPixels = new Uint8Array(4 * width * height);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        var tempCanvas = new CanvasBuffer(width, height);\n        var canvasData = tempCanvas.context.getImageData(0, 0, width, height);\n        canvasData.data.set(webGLPixels);\n\n        tempCanvas.context.putImageData(canvasData, 0, 0);\n\n        return tempCanvas.canvas;\n    }\n    else\n    {\n        return this.textureBuffer.canvas;\n    }\n};\n\n/**\n * Will return a one-dimensional array containing the pixel data of the entire texture in RGBA order, with integer values between 0 and 255 (included).\n *\n * @return {Uint8ClampedArray}\n */\nRenderTexture.prototype.getPixels = function ()\n{\n    var width, height;\n\n    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)\n    {\n        var gl = this.renderer.gl;\n        width = this.textureBuffer.size.width;\n        height = this.textureBuffer.size.height;\n\n        var webGLPixels = new Uint8Array(4 * width * height);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n        gl.readPixels(0, 0, width, height, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return webGLPixels;\n    }\n    else\n    {\n        width = this.textureBuffer.canvas.width;\n        height = this.textureBuffer.canvas.height;\n\n        return this.textureBuffer.canvas.getContext('2d').getImageData(0, 0, width, height).data;\n    }\n};\n\n/**\n * Will return a one-dimensional array containing the pixel data of a pixel within the texture in RGBA order, with integer values between 0 and 255 (included).\n *\n * @param x {number} The x coordinate of the pixel to retrieve.\n * @param y {number} The y coordinate of the pixel to retrieve.\n * @return {Uint8ClampedArray}\n */\nRenderTexture.prototype.getPixel = function (x, y)\n{\n    if (this.renderer.type === CONST.RENDERER_TYPE.WEBGL)\n    {\n        var gl = this.renderer.gl;\n\n        var webGLPixels = new Uint8Array(4);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.textureBuffer.frameBuffer);\n        gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, webGLPixels);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n\n        return webGLPixels;\n    }\n    else\n    {\n        return this.textureBuffer.canvas.getContext('2d').getImageData(x, y, 1, 1).data;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}