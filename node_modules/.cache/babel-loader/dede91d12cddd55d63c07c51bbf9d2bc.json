{"ast":null,"code":"var AbstractFilter = require('./AbstractFilter'),\n    math = require('../../../math'); // @see https://github.com/substack/brfs/issues/25\n\n\nvar fs = require('fs');\n/**\n * The SpriteMaskFilter class\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI\n * @param sprite {Sprite} the target sprite\n */\n\n\nfunction SpriteMaskFilter(sprite) {\n  var maskMatrix = new math.Matrix();\n  AbstractFilter.call(this, fs.readFileSync(__dirname + '/spriteMaskFilter.vert', 'utf8'), fs.readFileSync(__dirname + '/spriteMaskFilter.frag', 'utf8'), {\n    mask: {\n      type: 'sampler2D',\n      value: sprite._texture\n    },\n    alpha: {\n      type: 'f',\n      value: 1\n    },\n    otherMatrix: {\n      type: 'mat3',\n      value: maskMatrix.toArray(true)\n    }\n  });\n  this.maskSprite = sprite;\n  this.maskMatrix = maskMatrix;\n}\n\nSpriteMaskFilter.prototype = Object.create(AbstractFilter.prototype);\nSpriteMaskFilter.prototype.constructor = SpriteMaskFilter;\nmodule.exports = SpriteMaskFilter;\n/**\n * Applies the filter ? @alvin\n *\n * @param renderer {WebGLRenderer} A reference to the WebGL renderer\n * @param input {RenderTarget}\n * @param output {RenderTarget}\n */\n\nSpriteMaskFilter.prototype.applyFilter = function (renderer, input, output) {\n  var filterManager = renderer.filterManager;\n  this.uniforms.mask.value = this.maskSprite._texture;\n  filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);\n  this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);\n  this.uniforms.alpha.value = this.maskSprite.worldAlpha;\n  var shader = this.getShader(renderer); // draw the filter...\n\n  filterManager.applyFilter(shader, input, output);\n};\n\nObject.defineProperties(SpriteMaskFilter.prototype, {\n  /**\n   * The texture used for the displacement map. Must be power of 2 sized texture.\n   *\n   * @member {Texture}\n   * @memberof SpriteMaskFilter#\n   */\n  map: {\n    get: function () {\n      return this.uniforms.mask.value;\n    },\n    set: function (value) {\n      this.uniforms.mask.value = value;\n    }\n  },\n\n  /**\n   * The offset used to move the displacement map.\n   *\n   * @member {Point}\n   * @memberof SpriteMaskFilter#\n   */\n  offset: {\n    get: function () {\n      return this.uniforms.offset.value;\n    },\n    set: function (value) {\n      this.uniforms.offset.value = value;\n    }\n  }\n});","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/renderers/webgl/filters/SpriteMaskFilter.js"],"names":["AbstractFilter","require","math","fs","SpriteMaskFilter","sprite","maskMatrix","Matrix","call","readFileSync","__dirname","mask","type","value","_texture","alpha","otherMatrix","toArray","maskSprite","prototype","Object","create","constructor","module","exports","applyFilter","renderer","input","output","filterManager","uniforms","calculateMappedMatrix","frame","worldAlpha","shader","getShader","defineProperties","map","get","set","offset"],"mappings":"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","sourcesContent":["var AbstractFilter = require('./AbstractFilter'),\n    math =  require('../../../math');\n\n// @see https://github.com/substack/brfs/issues/25\nvar fs = require('fs');\n\n/**\n * The SpriteMaskFilter class\n *\n * @class\n * @extends PIXI.AbstractFilter\n * @memberof PIXI\n * @param sprite {Sprite} the target sprite\n */\nfunction SpriteMaskFilter(sprite)\n{\n    var maskMatrix = new math.Matrix();\n\n    AbstractFilter.call(this,\n        fs.readFileSync(__dirname + '/spriteMaskFilter.vert', 'utf8'),\n        fs.readFileSync(__dirname + '/spriteMaskFilter.frag', 'utf8'),\n        {\n            mask:           { type: 'sampler2D', value: sprite._texture },\n            alpha:          { type: 'f', value: 1},\n            otherMatrix:    { type: 'mat3', value: maskMatrix.toArray(true) }\n        }\n    );\n\n    this.maskSprite = sprite;\n    this.maskMatrix = maskMatrix;\n}\n\nSpriteMaskFilter.prototype = Object.create(AbstractFilter.prototype);\nSpriteMaskFilter.prototype.constructor = SpriteMaskFilter;\nmodule.exports = SpriteMaskFilter;\n\n/**\n * Applies the filter ? @alvin\n *\n * @param renderer {WebGLRenderer} A reference to the WebGL renderer\n * @param input {RenderTarget}\n * @param output {RenderTarget}\n */\nSpriteMaskFilter.prototype.applyFilter = function (renderer, input, output)\n{\n    var filterManager = renderer.filterManager;\n\n    this.uniforms.mask.value = this.maskSprite._texture;\n\n    filterManager.calculateMappedMatrix(input.frame, this.maskSprite, this.maskMatrix);\n\n    this.uniforms.otherMatrix.value = this.maskMatrix.toArray(true);\n    this.uniforms.alpha.value = this.maskSprite.worldAlpha;\n\n    var shader = this.getShader(renderer);\n     // draw the filter...\n    filterManager.applyFilter(shader, input, output);\n};\n\n\nObject.defineProperties(SpriteMaskFilter.prototype, {\n    /**\n     * The texture used for the displacement map. Must be power of 2 sized texture.\n     *\n     * @member {Texture}\n     * @memberof SpriteMaskFilter#\n     */\n    map: {\n        get: function ()\n        {\n            return this.uniforms.mask.value;\n        },\n        set: function (value)\n        {\n            this.uniforms.mask.value = value;\n        }\n    },\n\n    /**\n     * The offset used to move the displacement map.\n     *\n     * @member {Point}\n     * @memberof SpriteMaskFilter#\n     */\n    offset: {\n        get: function()\n        {\n            return this.uniforms.offset.value;\n        },\n        set: function(value)\n        {\n            this.uniforms.offset.value = value;\n        }\n    }\n});\n"]},"metadata":{},"sourceType":"script"}