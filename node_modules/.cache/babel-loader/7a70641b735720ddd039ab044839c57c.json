{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { MidiClass } from \"../core/type/Midi\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"./Instrument\";\nimport { Synth } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\n\nexport var PolySynth = /*#__PURE__*/function (_Instrument) {\n  _inherits(PolySynth, _Instrument);\n\n  var _super = _createSuper(PolySynth);\n\n  function PolySynth() {\n    var _this;\n\n    _classCallCheck(this, PolySynth);\n\n    _this = _super.call(this, optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n    _this.name = \"PolySynth\";\n    /**\n     * The voices which are not currently in use\n     */\n\n    _this._availableVoices = [];\n    /**\n     * The currently active voices\n     */\n\n    _this._activeVoices = [];\n    /**\n     * All of the allocated voices for this synth.\n     */\n\n    _this._voices = [];\n    /**\n     * The GC timeout. Held so that it could be cancelled when the node is disposed.\n     */\n\n    _this._gcTimeout = -1;\n    /**\n     * A moving average of the number of active voices\n     */\n\n    _this._averageActiveVoices = 0;\n    var options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]); // check against the old API (pre 14.3.0)\n\n    assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n    var defaults = options.voice.getDefaults();\n    _this.options = Object.assign(defaults, options.options);\n    _this.voice = options.voice;\n    _this.maxPolyphony = options.maxPolyphony; // create the first voice\n\n    _this._dummyVoice = _this._getNextAvailableVoice(); // remove it from the voices list\n\n    var index = _this._voices.indexOf(_this._dummyVoice);\n\n    _this._voices.splice(index, 1); // kick off the GC interval\n\n\n    _this._gcTimeout = _this.context.setInterval(_this._collectGarbage.bind(_assertThisInitialized(_this)), 1);\n    return _this;\n  }\n\n  _createClass(PolySynth, [{\n    key: \"_makeVoiceAvailable\",\n\n    /**\n     * Invoked when the source is done making sound, so that it can be\n     * readded to the pool of available voices\n     */\n    value: function _makeVoiceAvailable(voice) {\n      this._availableVoices.push(voice); // remove the midi note from 'active voices'\n\n\n      var activeVoiceIndex = this._activeVoices.findIndex(function (e) {\n        return e.voice === voice;\n      });\n\n      this._activeVoices.splice(activeVoiceIndex, 1);\n    }\n    /**\n     * Get an available voice from the pool of available voices.\n     * If one is not available and the maxPolyphony limit is reached,\n     * steal a voice, otherwise return null.\n     */\n\n  }, {\n    key: \"_getNextAvailableVoice\",\n    value: function _getNextAvailableVoice() {\n      // if there are available voices, return the first one\n      if (this._availableVoices.length) {\n        return this._availableVoices.shift();\n      } else if (this._voices.length < this.maxPolyphony) {\n        // otherwise if there is still more maxPolyphony, make a new voice\n        var voice = new this.voice(Object.assign(this.options, {\n          context: this.context,\n          onsilence: this._makeVoiceAvailable.bind(this)\n        }));\n        voice.connect(this.output);\n\n        this._voices.push(voice);\n\n        return voice;\n      } else {\n        warn(\"Max polyphony exceeded. Note dropped.\");\n      }\n    }\n    /**\n     * Occasionally check if there are any allocated voices which can be cleaned up.\n     */\n\n  }, {\n    key: \"_collectGarbage\",\n    value: function _collectGarbage() {\n      this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\n      if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n        // take off an available note\n        var firstAvail = this._availableVoices.shift();\n\n        var index = this._voices.indexOf(firstAvail);\n\n        this._voices.splice(index, 1);\n\n        if (!this.context.isOffline) {\n          firstAvail.dispose();\n        }\n      }\n    }\n    /**\n     * Internal method which triggers the attack\n     */\n\n  }, {\n    key: \"_triggerAttack\",\n    value: function _triggerAttack(notes, time, velocity) {\n      var _this2 = this;\n\n      notes.forEach(function (note) {\n        var midiNote = new MidiClass(_this2.context, note).toMidi();\n\n        var voice = _this2._getNextAvailableVoice();\n\n        if (voice) {\n          voice.triggerAttack(note, time, velocity);\n\n          _this2._activeVoices.push({\n            midi: midiNote,\n            voice: voice,\n            released: false\n          });\n\n          _this2.log(\"triggerAttack\", note, time);\n        }\n      });\n    }\n    /**\n     * Internal method which triggers the release\n     */\n\n  }, {\n    key: \"_triggerRelease\",\n    value: function _triggerRelease(notes, time) {\n      var _this3 = this;\n\n      notes.forEach(function (note) {\n        var midiNote = new MidiClass(_this3.context, note).toMidi();\n\n        var event = _this3._activeVoices.find(function (_ref) {\n          var midi = _ref.midi,\n              released = _ref.released;\n          return midi === midiNote && !released;\n        });\n\n        if (event) {\n          // trigger release on that note\n          event.voice.triggerRelease(time); // mark it as released\n\n          event.released = true;\n\n          _this3.log(\"triggerRelease\", note, time);\n        }\n      });\n    }\n    /**\n     * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n     * to wait for just-in-time scheduling\n     */\n\n  }, {\n    key: \"_scheduleEvent\",\n    value: function _scheduleEvent(type, notes, time, velocity) {\n      var _this4 = this;\n\n      assert(!this.disposed, \"Synth was already disposed\"); // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\n      if (time <= this.now()) {\n        // do it immediately\n        if (type === \"attack\") {\n          this._triggerAttack(notes, time, velocity);\n        } else {\n          this._triggerRelease(notes, time);\n        }\n      } else {\n        // schedule it to start in the future\n        this.context.setTimeout(function () {\n          _this4._scheduleEvent(type, notes, time, velocity);\n        }, time - this.now());\n      }\n    }\n    /**\n     * Trigger the attack portion of the note\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  The start time of the note.\n     * @param velocity The velocity of the note.\n     * @example\n     * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n     * // trigger a chord immediately with a velocity of 0.2\n     * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n     */\n\n  }, {\n    key: \"triggerAttack\",\n    value: function triggerAttack(notes, time, velocity) {\n      if (!Array.isArray(notes)) {\n        notes = [notes];\n      }\n\n      var computedTime = this.toSeconds(time);\n\n      this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\n      return this;\n    }\n    /**\n     * Trigger the release of the note. Unlike monophonic instruments,\n     * a note (or array of notes) needs to be passed in as the first argument.\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  When the release will be triggered.\n     * @example\n     * @example\n     * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n     * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n     * // trigger the release of the given notes.\n     * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n     * poly.triggerRelease(\"F5\", \"+3\");\n     */\n\n  }, {\n    key: \"triggerRelease\",\n    value: function triggerRelease(notes, time) {\n      if (!Array.isArray(notes)) {\n        notes = [notes];\n      }\n\n      var computedTime = this.toSeconds(time);\n\n      this._scheduleEvent(\"release\", notes, computedTime);\n\n      return this;\n    }\n    /**\n     * Trigger the attack and release after the specified duration\n     * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n     * @param  duration the duration of the note\n     * @param  time  if no time is given, defaults to now\n     * @param  velocity the velocity of the attack (0-1)\n     * @example\n     * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n     * // can pass in an array of durations as well\n     * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n     */\n\n  }, {\n    key: \"triggerAttackRelease\",\n    value: function triggerAttackRelease(notes, duration, time, velocity) {\n      var computedTime = this.toSeconds(time);\n      this.triggerAttack(notes, computedTime, velocity);\n\n      if (isArray(duration)) {\n        assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n        notes = notes;\n\n        for (var i = 0; i < notes.length; i++) {\n          var d = duration[Math.min(i, duration.length - 1)];\n          var durationSeconds = this.toSeconds(d);\n          assert(durationSeconds > 0, \"The duration must be greater than 0\");\n          this.triggerRelease(notes[i], computedTime + durationSeconds);\n        }\n      } else {\n        var _durationSeconds = this.toSeconds(duration);\n\n        assert(_durationSeconds > 0, \"The duration must be greater than 0\");\n        this.triggerRelease(notes, computedTime + _durationSeconds);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      if (this._syncState()) {\n        this._syncMethod(\"triggerAttack\", 1);\n\n        this._syncMethod(\"triggerRelease\", 1);\n      }\n\n      return this;\n    }\n    /**\n     * Set a member/attribute of the voices\n     * @example\n     * const poly = new Tone.PolySynth().toDestination();\n     * // set all of the voices using an options object for the synth type\n     * poly.set({\n     * \tenvelope: {\n     * \t\tattack: 0.25\n     * \t}\n     * });\n     * poly.triggerAttackRelease(\"Bb3\", 0.2);\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(options) {\n      // remove options which are controlled by the PolySynth\n      var sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]); // store all of the options\n\n      this.options = deepMerge(this.options, sanitizedOptions);\n\n      this._voices.forEach(function (voice) {\n        return voice.set(sanitizedOptions);\n      });\n\n      this._dummyVoice.set(sanitizedOptions);\n\n      return this;\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._dummyVoice.get();\n    }\n    /**\n     * Trigger the release portion of all the currently active voices immediately.\n     * Useful for silencing the synth.\n     */\n\n  }, {\n    key: \"releaseAll\",\n    value: function releaseAll(time) {\n      var computedTime = this.toSeconds(time);\n\n      this._activeVoices.forEach(function (_ref2) {\n        var voice = _ref2.voice;\n        voice.triggerRelease(computedTime);\n      });\n\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(PolySynth.prototype), \"dispose\", this).call(this);\n\n      this._dummyVoice.dispose();\n\n      this._voices.forEach(function (v) {\n        return v.dispose();\n      });\n\n      this._activeVoices = [];\n      this._availableVoices = [];\n      this.context.clearInterval(this._gcTimeout);\n      return this;\n    }\n  }, {\n    key: \"activeVoices\",\n\n    /**\n     * The number of active voices.\n     */\n    get: function get() {\n      return this._activeVoices.length;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Instrument.getDefaults(), {\n        maxPolyphony: 32,\n        options: {},\n        voice: Synth\n      });\n    }\n  }]);\n\n  return PolySynth;\n}(Instrument);","map":{"version":3,"sources":["../../../Tone/instrument/PolySynth.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { MidiClass } from \"../core/type/Midi\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"./Instrument\";\nimport { Synth } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth extends Instrument {\n    constructor() {\n        super(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n        this.name = \"PolySynth\";\n        /**\n         * The voices which are not currently in use\n         */\n        this._availableVoices = [];\n        /**\n         * The currently active voices\n         */\n        this._activeVoices = [];\n        /**\n         * All of the allocated voices for this synth.\n         */\n        this._voices = [];\n        /**\n         * The GC timeout. Held so that it could be cancelled when the node is disposed.\n         */\n        this._gcTimeout = -1;\n        /**\n         * A moving average of the number of active voices\n         */\n        this._averageActiveVoices = 0;\n        const options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n        // check against the old API (pre 14.3.0)\n        assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n        const defaults = options.voice.getDefaults();\n        this.options = Object.assign(defaults, options.options);\n        this.voice = options.voice;\n        this.maxPolyphony = options.maxPolyphony;\n        // create the first voice\n        this._dummyVoice = this._getNextAvailableVoice();\n        // remove it from the voices list\n        const index = this._voices.indexOf(this._dummyVoice);\n        this._voices.splice(index, 1);\n        // kick off the GC interval\n        this._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n    }\n    static getDefaults() {\n        return Object.assign(Instrument.getDefaults(), {\n            maxPolyphony: 32,\n            options: {},\n            voice: Synth,\n        });\n    }\n    /**\n     * The number of active voices.\n     */\n    get activeVoices() {\n        return this._activeVoices.length;\n    }\n    /**\n     * Invoked when the source is done making sound, so that it can be\n     * readded to the pool of available voices\n     */\n    _makeVoiceAvailable(voice) {\n        this._availableVoices.push(voice);\n        // remove the midi note from 'active voices'\n        const activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n        this._activeVoices.splice(activeVoiceIndex, 1);\n    }\n    /**\n     * Get an available voice from the pool of available voices.\n     * If one is not available and the maxPolyphony limit is reached,\n     * steal a voice, otherwise return null.\n     */\n    _getNextAvailableVoice() {\n        // if there are available voices, return the first one\n        if (this._availableVoices.length) {\n            return this._availableVoices.shift();\n        }\n        else if (this._voices.length < this.maxPolyphony) {\n            // otherwise if there is still more maxPolyphony, make a new voice\n            const voice = new this.voice(Object.assign(this.options, {\n                context: this.context,\n                onsilence: this._makeVoiceAvailable.bind(this),\n            }));\n            voice.connect(this.output);\n            this._voices.push(voice);\n            return voice;\n        }\n        else {\n            warn(\"Max polyphony exceeded. Note dropped.\");\n        }\n    }\n    /**\n     * Occasionally check if there are any allocated voices which can be cleaned up.\n     */\n    _collectGarbage() {\n        this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n        if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n            // take off an available note\n            const firstAvail = this._availableVoices.shift();\n            const index = this._voices.indexOf(firstAvail);\n            this._voices.splice(index, 1);\n            if (!this.context.isOffline) {\n                firstAvail.dispose();\n            }\n        }\n    }\n    /**\n     * Internal method which triggers the attack\n     */\n    _triggerAttack(notes, time, velocity) {\n        notes.forEach(note => {\n            const midiNote = new MidiClass(this.context, note).toMidi();\n            const voice = this._getNextAvailableVoice();\n            if (voice) {\n                voice.triggerAttack(note, time, velocity);\n                this._activeVoices.push({\n                    midi: midiNote, voice, released: false,\n                });\n                this.log(\"triggerAttack\", note, time);\n            }\n        });\n    }\n    /**\n     * Internal method which triggers the release\n     */\n    _triggerRelease(notes, time) {\n        notes.forEach(note => {\n            const midiNote = new MidiClass(this.context, note).toMidi();\n            const event = this._activeVoices.find(({ midi, released }) => midi === midiNote && !released);\n            if (event) {\n                // trigger release on that note\n                event.voice.triggerRelease(time);\n                // mark it as released\n                event.released = true;\n                this.log(\"triggerRelease\", note, time);\n            }\n        });\n    }\n    /**\n     * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n     * to wait for just-in-time scheduling\n     */\n    _scheduleEvent(type, notes, time, velocity) {\n        assert(!this.disposed, \"Synth was already disposed\");\n        // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n        if (time <= this.now()) {\n            // do it immediately\n            if (type === \"attack\") {\n                this._triggerAttack(notes, time, velocity);\n            }\n            else {\n                this._triggerRelease(notes, time);\n            }\n        }\n        else {\n            // schedule it to start in the future\n            this.context.setTimeout(() => {\n                this._scheduleEvent(type, notes, time, velocity);\n            }, time - this.now());\n        }\n    }\n    /**\n     * Trigger the attack portion of the note\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  The start time of the note.\n     * @param velocity The velocity of the note.\n     * @example\n     * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n     * // trigger a chord immediately with a velocity of 0.2\n     * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n     */\n    triggerAttack(notes, time, velocity) {\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        const computedTime = this.toSeconds(time);\n        this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n        return this;\n    }\n    /**\n     * Trigger the release of the note. Unlike monophonic instruments,\n     * a note (or array of notes) needs to be passed in as the first argument.\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  When the release will be triggered.\n     * @example\n     * @example\n     * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n     * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n     * // trigger the release of the given notes.\n     * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n     * poly.triggerRelease(\"F5\", \"+3\");\n     */\n    triggerRelease(notes, time) {\n        if (!Array.isArray(notes)) {\n            notes = [notes];\n        }\n        const computedTime = this.toSeconds(time);\n        this._scheduleEvent(\"release\", notes, computedTime);\n        return this;\n    }\n    /**\n     * Trigger the attack and release after the specified duration\n     * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n     * @param  duration the duration of the note\n     * @param  time  if no time is given, defaults to now\n     * @param  velocity the velocity of the attack (0-1)\n     * @example\n     * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n     * // can pass in an array of durations as well\n     * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n     */\n    triggerAttackRelease(notes, duration, time, velocity) {\n        const computedTime = this.toSeconds(time);\n        this.triggerAttack(notes, computedTime, velocity);\n        if (isArray(duration)) {\n            assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n            notes = notes;\n            for (let i = 0; i < notes.length; i++) {\n                const d = duration[Math.min(i, duration.length - 1)];\n                const durationSeconds = this.toSeconds(d);\n                assert(durationSeconds > 0, \"The duration must be greater than 0\");\n                this.triggerRelease(notes[i], computedTime + durationSeconds);\n            }\n        }\n        else {\n            const durationSeconds = this.toSeconds(duration);\n            assert(durationSeconds > 0, \"The duration must be greater than 0\");\n            this.triggerRelease(notes, computedTime + durationSeconds);\n        }\n        return this;\n    }\n    sync() {\n        if (this._syncState()) {\n            this._syncMethod(\"triggerAttack\", 1);\n            this._syncMethod(\"triggerRelease\", 1);\n        }\n        return this;\n    }\n    /**\n     * Set a member/attribute of the voices\n     * @example\n     * const poly = new Tone.PolySynth().toDestination();\n     * // set all of the voices using an options object for the synth type\n     * poly.set({\n     * \tenvelope: {\n     * \t\tattack: 0.25\n     * \t}\n     * });\n     * poly.triggerAttackRelease(\"Bb3\", 0.2);\n     */\n    set(options) {\n        // remove options which are controlled by the PolySynth\n        const sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n        // store all of the options\n        this.options = deepMerge(this.options, sanitizedOptions);\n        this._voices.forEach(voice => voice.set(sanitizedOptions));\n        this._dummyVoice.set(sanitizedOptions);\n        return this;\n    }\n    get() {\n        return this._dummyVoice.get();\n    }\n    /**\n     * Trigger the release portion of all the currently active voices immediately.\n     * Useful for silencing the synth.\n     */\n    releaseAll(time) {\n        const computedTime = this.toSeconds(time);\n        this._activeVoices.forEach(({ voice }) => {\n            voice.triggerRelease(computedTime);\n        });\n        return this;\n    }\n    dispose() {\n        super.dispose();\n        this._dummyVoice.dispose();\n        this._voices.forEach(v => v.dispose());\n        this._activeVoices = [];\n        this._availableVoices = [];\n        this.context.clearInterval(this._gcTimeout);\n        return this;\n    }\n}\n//# sourceMappingURL=PolySynth.js.map"]},"metadata":{},"sourceType":"module"}