{"ast":null,"code":"import { interceptConnections } from './intercept-connections';\nexport var wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = function wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioScheduledSourceNode, nativeContext) {\n  var nativeGainNode = nativeContext.createGain();\n  nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n  var disconnectGainNode = function (disconnect) {\n    return function () {\n      // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n      disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n      nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n    };\n  }(nativeAudioScheduledSourceNode.disconnect);\n\n  nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n  interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n  nativeAudioScheduledSourceNode.stop = function (stop) {\n    var isStopped = false;\n    return function () {\n      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (isStopped) {\n        try {\n          stop.call(nativeAudioScheduledSourceNode, when);\n        } catch (_unused) {\n          nativeGainNode.gain.setValueAtTime(0, when);\n        }\n      } else {\n        stop.call(nativeAudioScheduledSourceNode, when);\n        isStopped = true;\n      }\n    };\n  }(nativeAudioScheduledSourceNode.stop);\n};","map":{"version":3,"sources":["../../../src/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.ts"],"names":[],"mappings":"AACA,SAAS,oBAAT,QAAqC,yBAArC;AAEA,OAAO,IAAM,sDAAsD,GAAoE,SAA1H,sDAA0H,CACnI,8BADmI,EAEnI,aAFmI,EAGnI;AACA,MAAM,cAAc,GAAG,aAAa,CAAC,UAAd,EAAvB;AAEA,EAAA,8BAA8B,CAAC,OAA/B,CAAuC,cAAvC;;AAEA,MAAM,kBAAkB,GAAI,UAAC,UAAD,EAAe;AACvC,WAAO,YAAK;AACR;AACyC,MAAA,UAAW,CAAC,IAAZ,CAAiB,8BAAjB,EAAiD,cAAjD;AACzC,MAAA,8BAA8B,CAAC,mBAA/B,CAAmD,OAAnD,EAA4D,kBAA5D;AACH,KAJD;AAKH,GAN0B,CAMxB,8BAA8B,CAAC,UANP,CAA3B;;AAQA,EAAA,8BAA8B,CAAC,gBAA/B,CAAgD,OAAhD,EAAyD,kBAAzD;AAEA,EAAA,oBAAoB,CAAC,8BAAD,EAAiC,cAAjC,CAApB;;AAEA,EAAA,8BAA8B,CAAC,IAA/B,GAAuC,UAAC,IAAD,EAAS;AAC5C,QAAI,SAAS,GAAG,KAAhB;AAEA,WAAO,YAAa;AAAA,UAAZ,IAAY,uEAAL,CAAK;;AAChB,UAAI,SAAJ,EAAe;AACX,YAAI;AACA,UAAA,IAAI,CAAC,IAAL,CAAU,8BAAV,EAA0C,IAA1C;AACH,SAFD,CAEE,gBAAM;AACJ,UAAA,cAAc,CAAC,IAAf,CAAoB,cAApB,CAAmC,CAAnC,EAAsC,IAAtC;AACH;AACJ,OAND,MAMO;AACH,QAAA,IAAI,CAAC,IAAL,CAAU,8BAAV,EAA0C,IAA1C;AAEA,QAAA,SAAS,GAAG,IAAZ;AACH;AACJ,KAZD;AAaH,GAhBqC,CAgBnC,8BAA8B,CAAC,IAhBI,CAAtC;AAiBH,CArCM","sourceRoot":"","sourcesContent":["import { interceptConnections } from './intercept-connections';\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {\n    const nativeGainNode = nativeContext.createGain();\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n    const disconnectGainNode = ((disconnect) => {\n        return () => {\n            // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n            disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n    })(nativeAudioScheduledSourceNode.disconnect);\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        let isStopped = false;\n        return (when = 0) => {\n            if (isStopped) {\n                try {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                }\n                catch {\n                    nativeGainNode.gain.setValueAtTime(0, when);\n                }\n            }\n            else {\n                stop.call(nativeAudioScheduledSourceNode, when);\n                isStopped = true;\n            }\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n//# sourceMappingURL=wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js.map"]},"metadata":{},"sourceType":"module"}