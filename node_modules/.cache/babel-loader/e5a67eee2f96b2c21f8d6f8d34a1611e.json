{"ast":null,"code":"var core = require('../core');\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font. To\n * split a line you can use '\\n', '\\r' or '\\r\\n' in your string. You can generate the fnt files using:\n *\n * A BitmapText can only be created when the font is loaded\n *\n * ```js\n * // in this case the font is in a file called 'desyrel.fnt'\n * var bitmapText = new PIXI.BitmapText(\"text using a fancy font!\", {font: \"35px Desyrel\", align: \"right\"});\n * ```\n *\n *\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.extras\n * @param text {string} The copy that you would like the text to display\n * @param style {object} The style parameters\n * @param style.font {string|object} The font descriptor for the object, can be passed as a string of form\n *      \"24px FontName\" or \"FontName\" or as an object with explicit name/size properties.\n * @param [style.font.name] {string} The bitmap font id\n * @param [style.font.size] {number} The size of the font in pixels, e.g. 24\n * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect\n *      single line text\n * @param [style.tint=0xFFFFFF] {number} The tint color\n */\n\n\nfunction BitmapText(text, style) {\n  core.Container.call(this);\n  style = style || {};\n  /**\n   * The width of the overall text, different from fontSize,\n   * which is defined in the style object\n   *\n   * @member {number}\n   * @readOnly\n   */\n\n  this.textWidth = 0;\n  /**\n   * The height of the overall text, different from fontSize,\n   * which is defined in the style object\n   *\n   * @member {number}\n   * @readOnly\n   */\n\n  this.textHeight = 0;\n  /**\n   * Private tracker for the letter sprite pool.\n   *\n   * @member {Sprite[]}\n   * @private\n   */\n\n  this._glyphs = [];\n  /**\n   * Private tracker for the current style.\n   *\n   * @member {object}\n   * @private\n   */\n\n  this._font = {\n    tint: style.tint !== undefined ? style.tint : 0xFFFFFF,\n    align: style.align || 'left',\n    name: null,\n    size: 0\n  };\n  /**\n   * Private tracker for the current font.\n   *\n   * @member {object}\n   * @private\n   */\n\n  this.font = style.font; // run font setter\n\n  /**\n   * Private tracker for the current text.\n   *\n   * @member {string}\n   * @private\n   */\n\n  this._text = text;\n  /**\n   * The max width of this bitmap text in pixels. If the text provided is longer than the value provided, line breaks will be automatically inserted in the last whitespace.\n   * Disable by setting value to 0\n   *\n   * @member {number}\n   */\n\n  this.maxWidth = 0;\n  /**\n   * The dirty state of this object.\n   *\n   * @member {boolean}\n   */\n\n  this.dirty = false;\n  this.updateText();\n} // constructor\n\n\nBitmapText.prototype = Object.create(core.Container.prototype);\nBitmapText.prototype.constructor = BitmapText;\nmodule.exports = BitmapText;\nObject.defineProperties(BitmapText.prototype, {\n  /**\n   * The tint of the BitmapText object\n   *\n   * @member {number}\n   * @memberof BitmapText#\n   */\n  tint: {\n    get: function () {\n      return this._font.tint;\n    },\n    set: function (value) {\n      this._font.tint = typeof value === 'number' && value >= 0 ? value : 0xFFFFFF;\n      this.dirty = true;\n    }\n  },\n\n  /**\n   * The alignment of the BitmapText object\n   *\n   * @member {string}\n   * @default 'left'\n   * @memberof BitmapText#\n   */\n  align: {\n    get: function () {\n      return this._font.align;\n    },\n    set: function (value) {\n      this._font.align = value || 'left';\n      this.dirty = true;\n    }\n  },\n\n  /**\n   * The font descriptor of the BitmapText object\n   *\n   * @member {Font}\n   * @memberof BitmapText#\n   */\n  font: {\n    get: function () {\n      return this._font;\n    },\n    set: function (value) {\n      if (!value) {\n        return;\n      }\n\n      if (typeof value === 'string') {\n        value = value.split(' ');\n        this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');\n        this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;\n      } else {\n        this._font.name = value.name;\n        this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);\n      }\n\n      this.dirty = true;\n    }\n  },\n\n  /**\n   * The text of the BitmapText object\n   *\n   * @member {string}\n   * @memberof BitmapText#\n   */\n  text: {\n    get: function () {\n      return this._text;\n    },\n    set: function (value) {\n      value = value.toString() || ' ';\n\n      if (this._text === value) {\n        return;\n      }\n\n      this._text = value;\n      this.dirty = true;\n    }\n  }\n});\n/**\n * Renders text and updates it when needed\n *\n * @private\n */\n\nBitmapText.prototype.updateText = function () {\n  var data = BitmapText.fonts[this._font.name];\n  var pos = new core.Point();\n  var prevCharCode = null;\n  var chars = [];\n  var lastLineWidth = 0;\n  var maxLineWidth = 0;\n  var lineWidths = [];\n  var line = 0;\n  var scale = this._font.size / data.size;\n  var lastSpace = -1;\n\n  for (var i = 0; i < this.text.length; i++) {\n    var charCode = this.text.charCodeAt(i);\n    lastSpace = /(\\s)/.test(this.text.charAt(i)) ? i : lastSpace;\n\n    if (/(?:\\r\\n|\\r|\\n)/.test(this.text.charAt(i))) {\n      lineWidths.push(lastLineWidth);\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n      line++;\n      pos.x = 0;\n      pos.y += data.lineHeight;\n      prevCharCode = null;\n      continue;\n    }\n\n    if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth) {\n      chars.splice(lastSpace, i - lastSpace);\n      i = lastSpace;\n      lastSpace = -1;\n      lineWidths.push(lastLineWidth);\n      maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n      line++;\n      pos.x = 0;\n      pos.y += data.lineHeight;\n      prevCharCode = null;\n      continue;\n    }\n\n    var charData = data.chars[charCode];\n\n    if (!charData) {\n      continue;\n    }\n\n    if (prevCharCode && charData.kerning[prevCharCode]) {\n      pos.x += charData.kerning[prevCharCode];\n    }\n\n    chars.push({\n      texture: charData.texture,\n      line: line,\n      charCode: charCode,\n      position: new core.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)\n    });\n    lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);\n    pos.x += charData.xAdvance;\n    prevCharCode = charCode;\n  }\n\n  lineWidths.push(lastLineWidth);\n  maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n  var lineAlignOffsets = [];\n\n  for (i = 0; i <= line; i++) {\n    var alignOffset = 0;\n\n    if (this._font.align === 'right') {\n      alignOffset = maxLineWidth - lineWidths[i];\n    } else if (this._font.align === 'center') {\n      alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n    }\n\n    lineAlignOffsets.push(alignOffset);\n  }\n\n  var lenChars = chars.length;\n  var tint = this.tint;\n\n  for (i = 0; i < lenChars; i++) {\n    var c = this._glyphs[i]; // get the next glyph sprite\n\n    if (c) {\n      c.texture = chars[i].texture;\n    } else {\n      c = new core.Sprite(chars[i].texture);\n\n      this._glyphs.push(c);\n    }\n\n    c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n    c.position.y = chars[i].position.y * scale;\n    c.scale.x = c.scale.y = scale;\n    c.tint = tint;\n\n    if (!c.parent) {\n      this.addChild(c);\n    }\n  } // remove unnecessary children.\n\n\n  for (i = lenChars; i < this._glyphs.length; ++i) {\n    this.removeChild(this._glyphs[i]);\n  }\n\n  this.textWidth = maxLineWidth * scale;\n  this.textHeight = (pos.y + data.lineHeight) * scale;\n};\n/**\n * Updates the transform of this object\n *\n * @private\n */\n\n\nBitmapText.prototype.updateTransform = function () {\n  this.validate();\n  this.containerUpdateTransform();\n};\n/**\n * Validates text before calling parent's getLocalBounds\n *\n * @return {Rectangle} The rectangular bounding area\n */\n\n\nBitmapText.prototype.getLocalBounds = function () {\n  this.validate();\n  return core.Container.prototype.getLocalBounds.call(this);\n};\n/**\n * Updates text when needed\n *\n * @private\n */\n\n\nBitmapText.prototype.validate = function () {\n  if (this.dirty) {\n    this.updateText();\n    this.dirty = false;\n  }\n};\n\nBitmapText.fonts = {};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/extras/BitmapText.js"],"names":["core","require","BitmapText","text","style","Container","call","textWidth","textHeight","_glyphs","_font","tint","undefined","align","name","size","font","_text","maxWidth","dirty","updateText","prototype","Object","create","constructor","module","exports","defineProperties","get","set","value","split","length","slice","join","parseInt","fonts","toString","data","pos","Point","prevCharCode","chars","lastLineWidth","maxLineWidth","lineWidths","line","scale","lastSpace","i","charCode","charCodeAt","test","charAt","push","Math","max","x","y","lineHeight","splice","charData","kerning","texture","position","xOffset","yOffset","width","xAdvance","lineAlignOffsets","alignOffset","lenChars","c","Sprite","parent","addChild","removeChild","updateTransform","validate","containerUpdateTransform","getLocalBounds"],"mappings":"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","sourcesContent":["var core = require('../core');\n\n/**\n * A BitmapText object will create a line or multiple lines of text using bitmap font. To\n * split a line you can use '\\n', '\\r' or '\\r\\n' in your string. You can generate the fnt files using:\n *\n * A BitmapText can only be created when the font is loaded\n *\n * ```js\n * // in this case the font is in a file called 'desyrel.fnt'\n * var bitmapText = new PIXI.BitmapText(\"text using a fancy font!\", {font: \"35px Desyrel\", align: \"right\"});\n * ```\n *\n *\n * http://www.angelcode.com/products/bmfont/ for windows or\n * http://www.bmglyph.com/ for mac.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI.extras\n * @param text {string} The copy that you would like the text to display\n * @param style {object} The style parameters\n * @param style.font {string|object} The font descriptor for the object, can be passed as a string of form\n *      \"24px FontName\" or \"FontName\" or as an object with explicit name/size properties.\n * @param [style.font.name] {string} The bitmap font id\n * @param [style.font.size] {number} The size of the font in pixels, e.g. 24\n * @param [style.align='left'] {string} Alignment for multiline text ('left', 'center' or 'right'), does not affect\n *      single line text\n * @param [style.tint=0xFFFFFF] {number} The tint color\n */\nfunction BitmapText(text, style)\n{\n    core.Container.call(this);\n\n    style = style || {};\n\n    /**\n     * The width of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.textWidth = 0;\n\n    /**\n     * The height of the overall text, different from fontSize,\n     * which is defined in the style object\n     *\n     * @member {number}\n     * @readOnly\n     */\n    this.textHeight = 0;\n\n    /**\n     * Private tracker for the letter sprite pool.\n     *\n     * @member {Sprite[]}\n     * @private\n     */\n    this._glyphs = [];\n\n    /**\n     * Private tracker for the current style.\n     *\n     * @member {object}\n     * @private\n     */\n    this._font = {\n        tint: style.tint !== undefined ? style.tint : 0xFFFFFF,\n        align: style.align || 'left',\n        name: null,\n        size: 0\n    };\n\n    /**\n     * Private tracker for the current font.\n     *\n     * @member {object}\n     * @private\n     */\n    this.font = style.font; // run font setter\n\n    /**\n     * Private tracker for the current text.\n     *\n     * @member {string}\n     * @private\n     */\n    this._text = text;\n\n    /**\n     * The max width of this bitmap text in pixels. If the text provided is longer than the value provided, line breaks will be automatically inserted in the last whitespace.\n     * Disable by setting value to 0\n     *\n     * @member {number}\n     */\n    this.maxWidth = 0;\n\n    /**\n     * The dirty state of this object.\n     *\n     * @member {boolean}\n     */\n    this.dirty = false;\n\n    this.updateText();\n}\n\n// constructor\nBitmapText.prototype = Object.create(core.Container.prototype);\nBitmapText.prototype.constructor = BitmapText;\nmodule.exports = BitmapText;\n\nObject.defineProperties(BitmapText.prototype, {\n    /**\n     * The tint of the BitmapText object\n     *\n     * @member {number}\n     * @memberof BitmapText#\n     */\n    tint: {\n        get: function ()\n        {\n            return this._font.tint;\n        },\n        set: function (value)\n        {\n            this._font.tint = (typeof value === 'number' && value >= 0) ? value : 0xFFFFFF;\n\n            this.dirty = true;\n        }\n    },\n\n    /**\n     * The alignment of the BitmapText object\n     *\n     * @member {string}\n     * @default 'left'\n     * @memberof BitmapText#\n     */\n    align: {\n        get: function ()\n        {\n            return this._font.align;\n        },\n        set: function (value)\n        {\n            this._font.align = value || 'left';\n\n            this.dirty = true;\n        }\n    },\n\n    /**\n     * The font descriptor of the BitmapText object\n     *\n     * @member {Font}\n     * @memberof BitmapText#\n     */\n    font: {\n        get: function ()\n        {\n            return this._font;\n        },\n        set: function (value)\n        {\n            if (!value) {\n                return;\n            }\n\n            if (typeof value === 'string') {\n                value = value.split(' ');\n\n                this._font.name = value.length === 1 ? value[0] : value.slice(1).join(' ');\n                this._font.size = value.length >= 2 ? parseInt(value[0], 10) : BitmapText.fonts[this._font.name].size;\n            }\n            else {\n                this._font.name = value.name;\n                this._font.size = typeof value.size === 'number' ? value.size : parseInt(value.size, 10);\n            }\n\n            this.dirty = true;\n        }\n    },\n\n    /**\n     * The text of the BitmapText object\n     *\n     * @member {string}\n     * @memberof BitmapText#\n     */\n    text: {\n        get: function ()\n        {\n            return this._text;\n        },\n        set: function (value)\n        {\n            value = value.toString() || ' ';\n            if (this._text === value)\n            {\n                return;\n            }\n            this._text = value;\n            this.dirty = true;\n        }\n    }\n});\n\n/**\n * Renders text and updates it when needed\n *\n * @private\n */\nBitmapText.prototype.updateText = function ()\n{\n    var data = BitmapText.fonts[this._font.name];\n    var pos = new core.Point();\n    var prevCharCode = null;\n    var chars = [];\n    var lastLineWidth = 0;\n    var maxLineWidth = 0;\n    var lineWidths = [];\n    var line = 0;\n    var scale = this._font.size / data.size;\n    var lastSpace = -1;\n\n    for (var i = 0; i < this.text.length; i++)\n    {\n        var charCode = this.text.charCodeAt(i);\n        lastSpace = /(\\s)/.test(this.text.charAt(i)) ? i : lastSpace;\n\n        if (/(?:\\r\\n|\\r|\\n)/.test(this.text.charAt(i)))\n        {\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n            line++;\n\n            pos.x = 0;\n            pos.y += data.lineHeight;\n            prevCharCode = null;\n            continue;\n        }\n\n        if (lastSpace !== -1 && this.maxWidth > 0 && pos.x * scale > this.maxWidth)\n        {\n            chars.splice(lastSpace, i - lastSpace);\n            i = lastSpace;\n            lastSpace = -1;\n\n            lineWidths.push(lastLineWidth);\n            maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n            line++;\n\n            pos.x = 0;\n            pos.y += data.lineHeight;\n            prevCharCode = null;\n            continue;\n        }\n\n        var charData = data.chars[charCode];\n\n        if (!charData)\n        {\n            continue;\n        }\n\n        if (prevCharCode && charData.kerning[prevCharCode])\n        {\n            pos.x += charData.kerning[prevCharCode];\n        }\n\n        chars.push({texture:charData.texture, line: line, charCode: charCode, position: new core.Point(pos.x + charData.xOffset, pos.y + charData.yOffset)});\n        lastLineWidth = pos.x + (charData.texture.width + charData.xOffset);\n        pos.x += charData.xAdvance;\n\n        prevCharCode = charCode;\n    }\n\n    lineWidths.push(lastLineWidth);\n    maxLineWidth = Math.max(maxLineWidth, lastLineWidth);\n\n    var lineAlignOffsets = [];\n\n    for (i = 0; i <= line; i++)\n    {\n        var alignOffset = 0;\n\n        if (this._font.align === 'right')\n        {\n            alignOffset = maxLineWidth - lineWidths[i];\n        }\n        else if (this._font.align === 'center')\n        {\n            alignOffset = (maxLineWidth - lineWidths[i]) / 2;\n        }\n\n        lineAlignOffsets.push(alignOffset);\n    }\n\n    var lenChars = chars.length;\n    var tint = this.tint;\n\n    for (i = 0; i < lenChars; i++)\n    {\n        var c = this._glyphs[i]; // get the next glyph sprite\n\n        if (c)\n        {\n            c.texture = chars[i].texture;\n        }\n        else\n        {\n            c = new core.Sprite(chars[i].texture);\n            this._glyphs.push(c);\n        }\n\n        c.position.x = (chars[i].position.x + lineAlignOffsets[chars[i].line]) * scale;\n        c.position.y = chars[i].position.y * scale;\n        c.scale.x = c.scale.y = scale;\n        c.tint = tint;\n\n        if (!c.parent)\n        {\n            this.addChild(c);\n        }\n    }\n\n    // remove unnecessary children.\n    for (i = lenChars; i < this._glyphs.length; ++i)\n    {\n        this.removeChild(this._glyphs[i]);\n    }\n\n    this.textWidth = maxLineWidth * scale;\n    this.textHeight = (pos.y + data.lineHeight) * scale;\n};\n\n/**\n * Updates the transform of this object\n *\n * @private\n */\nBitmapText.prototype.updateTransform = function ()\n{\n    this.validate();\n    this.containerUpdateTransform();\n};\n\n/**\n * Validates text before calling parent's getLocalBounds\n *\n * @return {Rectangle} The rectangular bounding area\n */\n\nBitmapText.prototype.getLocalBounds = function()\n{\n    this.validate();\n    return core.Container.prototype.getLocalBounds.call(this);\n};\n\n/**\n * Updates text when needed\n *\n * @private\n */\nBitmapText.prototype.validate = function()\n{\n    if (this.dirty)\n    {\n        this.updateText();\n        this.dirty = false;\n    }\n};\n\nBitmapText.fonts = {};\n"]},"metadata":{},"sourceType":"script"}