{"ast":null,"code":"var core = require('../core'),\n    DisplayObject = core.DisplayObject,\n    _tempMatrix = new core.Matrix();\n\nDisplayObject.prototype._cacheAsBitmap = false;\nDisplayObject.prototype._originalRenderWebGL = null;\nDisplayObject.prototype._originalRenderCanvas = null;\nDisplayObject.prototype._originalUpdateTransform = null;\nDisplayObject.prototype._originalHitTest = null;\nDisplayObject.prototype._originalDestroy = null;\nDisplayObject.prototype._cachedSprite = null;\nObject.defineProperties(DisplayObject.prototype, {\n  /**\n   * Set this to true if you want this display object to be cached as a bitmap.\n   * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects.\n   * To remove simply set this property to 'null'\n   *\n   * @member {boolean}\n   * @memberof DisplayObject#\n   */\n  cacheAsBitmap: {\n    get: function () {\n      return this._cacheAsBitmap;\n    },\n    set: function (value) {\n      if (this._cacheAsBitmap === value) {\n        return;\n      }\n\n      this._cacheAsBitmap = value;\n\n      if (value) {\n        this._originalRenderWebGL = this.renderWebGL;\n        this._originalRenderCanvas = this.renderCanvas;\n        this._originalUpdateTransform = this.updateTransform;\n        this._originalGetBounds = this.getBounds;\n        this._originalDestroy = this.destroy;\n        this._originalContainsPoint = this.containsPoint;\n        this.renderWebGL = this._renderCachedWebGL;\n        this.renderCanvas = this._renderCachedCanvas;\n        this.destroy = this._cacheAsBitmapDestroy;\n      } else {\n        if (this._cachedSprite) {\n          this._destroyCachedDisplayObject();\n        }\n\n        this.renderWebGL = this._originalRenderWebGL;\n        this.renderCanvas = this._originalRenderCanvas;\n        this.getBounds = this._originalGetBounds;\n        this.destroy = this._originalDestroy;\n        this.updateTransform = this._originalUpdateTransform;\n        this.containsPoint = this._originalContainsPoint;\n      }\n    }\n  }\n});\n/**\n* Renders a cached version of the sprite with WebGL\n*\n* @param renderer {WebGLRenderer} the WebGL renderer\n* @private\n*/\n\nDisplayObject.prototype._renderCachedWebGL = function (renderer) {\n  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n    return;\n  }\n\n  this._initCachedDisplayObject(renderer);\n\n  this._cachedSprite.worldAlpha = this.worldAlpha;\n  renderer.setObjectRenderer(renderer.plugins.sprite);\n  renderer.plugins.sprite.render(this._cachedSprite);\n};\n/**\n* Prepares the WebGL renderer to cache the sprite\n*\n* @param renderer {WebGLRenderer} the WebGL renderer\n* @private\n*/\n\n\nDisplayObject.prototype._initCachedDisplayObject = function (renderer) {\n  if (this._cachedSprite) {\n    return;\n  } // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)\n\n\n  renderer.currentRenderer.flush(); //this.filters= [];\n  // next we find the dimensions of the untransformed object\n  // this function also calls updatetransform on all its children as part of the measuring. This means we don't need to update the transform again in this function\n  // TODO pass an object to clone too? saves having to create a new one each time!\n\n  var bounds = this.getLocalBounds().clone(); // add some padding!\n\n  if (this._filters) {\n    var padding = this._filters[0].padding;\n    bounds.x -= padding;\n    bounds.y -= padding;\n    bounds.width += padding * 2;\n    bounds.height += padding * 2;\n  } // for now we cache the current renderTarget that the webGL renderer is currently using.\n  // this could be more elegent..\n\n\n  var cachedRenderTarget = renderer.currentRenderTarget; // We also store the filter stack - I will definitely look to change how this works a little later down the line.\n\n  var stack = renderer.filterManager.filterStack; // this renderTexture will be used to store the cached DisplayObject\n\n  var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0); // need to set //\n\n  var m = _tempMatrix;\n  m.tx = -bounds.x;\n  m.ty = -bounds.y; // set all properties to there original so we can render to a texture\n\n  this.renderWebGL = this._originalRenderWebGL;\n  renderTexture.render(this, m, true, true); // now restore the state be setting the new properties\n\n  renderer.setRenderTarget(cachedRenderTarget);\n  renderer.filterManager.filterStack = stack;\n  this.renderWebGL = this._renderCachedWebGL;\n  this.updateTransform = this.displayObjectUpdateTransform;\n  this.getBounds = this._getCachedBounds; // create our cached sprite\n\n  this._cachedSprite = new core.Sprite(renderTexture);\n  this._cachedSprite.worldTransform = this.worldTransform;\n  this._cachedSprite.anchor.x = -(bounds.x / bounds.width);\n  this._cachedSprite.anchor.y = -(bounds.y / bounds.height); // restore the transform of the cached sprite to avoid the nasty flicker..\n\n  this.updateTransform(); // map the hit test..\n\n  this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);\n};\n/**\n* Renders a cached version of the sprite with canvas\n*\n* @param renderer {CanvasRenderer} the Canvas renderer\n* @private\n*/\n\n\nDisplayObject.prototype._renderCachedCanvas = function (renderer) {\n  if (!this.visible || this.worldAlpha <= 0 || !this.renderable) {\n    return;\n  }\n\n  this._initCachedDisplayObjectCanvas(renderer);\n\n  this._cachedSprite.worldAlpha = this.worldAlpha;\n\n  this._cachedSprite.renderCanvas(renderer);\n}; //TODO this can be the same as the webGL verison.. will need to do a little tweaking first though..\n\n/**\n* Prepares the Canvas renderer to cache the sprite\n*\n* @param renderer {CanvasRenderer} the Canvas renderer\n* @private\n*/\n\n\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function (renderer) {\n  if (this._cachedSprite) {\n    return;\n  } //get bounds actually transforms the object for us already!\n\n\n  var bounds = this.getLocalBounds();\n  var cachedRenderTarget = renderer.context;\n  var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0); // need to set //\n\n  var m = _tempMatrix;\n  m.tx = -bounds.x;\n  m.ty = -bounds.y; // set all properties to there original so we can render to a texture\n\n  this.renderCanvas = this._originalRenderCanvas;\n  renderTexture.render(this, m, true); // now restore the state be setting the new properties\n\n  renderer.context = cachedRenderTarget;\n  this.renderCanvas = this._renderCachedCanvas;\n  this.updateTransform = this.displayObjectUpdateTransform;\n  this.getBounds = this._getCachedBounds; // create our cached sprite\n\n  this._cachedSprite = new core.Sprite(renderTexture);\n  this._cachedSprite.worldTransform = this.worldTransform;\n  this._cachedSprite.anchor.x = -(bounds.x / bounds.width);\n  this._cachedSprite.anchor.y = -(bounds.y / bounds.height);\n  this.updateTransform();\n  this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);\n};\n/**\n* Calculates the bounds of the cached sprite\n*\n* @private\n*/\n\n\nDisplayObject.prototype._getCachedBounds = function () {\n  this._cachedSprite._currentBounds = null;\n  return this._cachedSprite.getBounds();\n};\n/**\n* Destroys the cached sprite.\n*\n* @private\n*/\n\n\nDisplayObject.prototype._destroyCachedDisplayObject = function () {\n  this._cachedSprite._texture.destroy();\n\n  this._cachedSprite = null;\n};\n\nDisplayObject.prototype._cacheAsBitmapDestroy = function () {\n  this.cacheAsBitmap = false;\n\n  this._originalDestroy();\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/extras/cacheAsBitmap.js"],"names":["core","require","DisplayObject","_tempMatrix","Matrix","prototype","_cacheAsBitmap","_originalRenderWebGL","_originalRenderCanvas","_originalUpdateTransform","_originalHitTest","_originalDestroy","_cachedSprite","Object","defineProperties","cacheAsBitmap","get","set","value","renderWebGL","renderCanvas","updateTransform","_originalGetBounds","getBounds","destroy","_originalContainsPoint","containsPoint","_renderCachedWebGL","_renderCachedCanvas","_cacheAsBitmapDestroy","_destroyCachedDisplayObject","renderer","visible","worldAlpha","renderable","_initCachedDisplayObject","setObjectRenderer","plugins","sprite","render","currentRenderer","flush","bounds","getLocalBounds","clone","_filters","padding","x","y","width","height","cachedRenderTarget","currentRenderTarget","stack","filterManager","filterStack","renderTexture","RenderTexture","m","tx","ty","setRenderTarget","displayObjectUpdateTransform","_getCachedBounds","Sprite","worldTransform","anchor","bind","_initCachedDisplayObjectCanvas","context","_currentBounds","_texture"],"mappings":"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","sourcesContent":["var core = require('../core'),\n    DisplayObject = core.DisplayObject,\n    _tempMatrix = new core.Matrix();\n\nDisplayObject.prototype._cacheAsBitmap = false;\nDisplayObject.prototype._originalRenderWebGL = null;\nDisplayObject.prototype._originalRenderCanvas = null;\n\nDisplayObject.prototype._originalUpdateTransform = null;\nDisplayObject.prototype._originalHitTest = null;\nDisplayObject.prototype._originalDestroy = null;\nDisplayObject.prototype._cachedSprite = null;\n\nObject.defineProperties(DisplayObject.prototype, {\n\n    /**\n     * Set this to true if you want this display object to be cached as a bitmap.\n     * This basically takes a snap shot of the display object as it is at that moment. It can provide a performance benefit for complex static displayObjects.\n     * To remove simply set this property to 'null'\n     *\n     * @member {boolean}\n     * @memberof DisplayObject#\n     */\n    cacheAsBitmap: {\n        get: function ()\n        {\n            return this._cacheAsBitmap;\n        },\n        set: function (value)\n        {\n            if (this._cacheAsBitmap === value)\n            {\n                return;\n            }\n\n            this._cacheAsBitmap = value;\n\n            if (value)\n            {\n                this._originalRenderWebGL = this.renderWebGL;\n                this._originalRenderCanvas = this.renderCanvas;\n\n                this._originalUpdateTransform = this.updateTransform;\n                this._originalGetBounds = this.getBounds;\n\n                this._originalDestroy = this.destroy;\n\n                this._originalContainsPoint = this.containsPoint;\n\n                this.renderWebGL = this._renderCachedWebGL;\n                this.renderCanvas = this._renderCachedCanvas;\n\n                this.destroy = this._cacheAsBitmapDestroy;\n\n            }\n            else\n            {\n                if (this._cachedSprite)\n                {\n                    this._destroyCachedDisplayObject();\n                }\n\n                this.renderWebGL = this._originalRenderWebGL;\n                this.renderCanvas = this._originalRenderCanvas;\n                this.getBounds = this._originalGetBounds;\n\n                this.destroy = this._originalDestroy;\n\n                this.updateTransform = this._originalUpdateTransform;\n                this.containsPoint = this._originalContainsPoint;\n            }\n        }\n    }\n});\n/**\n* Renders a cached version of the sprite with WebGL\n*\n* @param renderer {WebGLRenderer} the WebGL renderer\n* @private\n*/\nDisplayObject.prototype._renderCachedWebGL = function (renderer)\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n    {\n        return;\n    }\n\n    this._initCachedDisplayObject( renderer );\n\n    this._cachedSprite.worldAlpha = this.worldAlpha;\n\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    renderer.plugins.sprite.render( this._cachedSprite );\n};\n\n/**\n* Prepares the WebGL renderer to cache the sprite\n*\n* @param renderer {WebGLRenderer} the WebGL renderer\n* @private\n*/\nDisplayObject.prototype._initCachedDisplayObject = function (renderer)\n{\n    if(this._cachedSprite)\n    {\n        return;\n    }\n\n    // first we flush anything left in the renderer (otherwise it would get rendered to the cached texture)\n    renderer.currentRenderer.flush();\n    //this.filters= [];\n    // next we find the dimensions of the untransformed object\n    // this function also calls updatetransform on all its children as part of the measuring. This means we don't need to update the transform again in this function\n    // TODO pass an object to clone too? saves having to create a new one each time!\n    var bounds = this.getLocalBounds().clone();\n\n    // add some padding!\n    if(this._filters)\n    {\n        var padding = this._filters[0].padding;\n        bounds.x -= padding;\n        bounds.y -= padding;\n\n        bounds.width += padding * 2;\n        bounds.height += padding * 2;\n    }\n\n    // for now we cache the current renderTarget that the webGL renderer is currently using.\n    // this could be more elegent..\n    var cachedRenderTarget = renderer.currentRenderTarget;\n    // We also store the filter stack - I will definitely look to change how this works a little later down the line.\n    var stack = renderer.filterManager.filterStack;\n\n    // this renderTexture will be used to store the cached DisplayObject\n    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);\n\n    // need to set //\n    var m = _tempMatrix;\n\n    m.tx = -bounds.x;\n    m.ty = -bounds.y;\n\n\n\n    // set all properties to there original so we can render to a texture\n    this.renderWebGL = this._originalRenderWebGL;\n\n    renderTexture.render(this, m, true, true);\n\n    // now restore the state be setting the new properties\n    renderer.setRenderTarget(cachedRenderTarget);\n    renderer.filterManager.filterStack = stack;\n\n    this.renderWebGL     = this._renderCachedWebGL;\n    this.updateTransform = this.displayObjectUpdateTransform;\n    this.getBounds       = this._getCachedBounds;\n\n\n    // create our cached sprite\n    this._cachedSprite = new core.Sprite(renderTexture);\n    this._cachedSprite.worldTransform = this.worldTransform;\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n    // restore the transform of the cached sprite to avoid the nasty flicker..\n    this.updateTransform();\n\n    // map the hit test..\n    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);\n};\n\n/**\n* Renders a cached version of the sprite with canvas\n*\n* @param renderer {CanvasRenderer} the Canvas renderer\n* @private\n*/\nDisplayObject.prototype._renderCachedCanvas = function (renderer)\n{\n    if (!this.visible || this.worldAlpha <= 0 || !this.renderable)\n    {\n        return;\n    }\n    \n    this._initCachedDisplayObjectCanvas( renderer );\n\n    this._cachedSprite.worldAlpha = this.worldAlpha;\n\n    this._cachedSprite.renderCanvas(renderer);\n};\n\n//TODO this can be the same as the webGL verison.. will need to do a little tweaking first though..\n/**\n* Prepares the Canvas renderer to cache the sprite\n*\n* @param renderer {CanvasRenderer} the Canvas renderer\n* @private\n*/\nDisplayObject.prototype._initCachedDisplayObjectCanvas = function (renderer)\n{\n    if(this._cachedSprite)\n    {\n        return;\n    }\n\n    //get bounds actually transforms the object for us already!\n    var bounds = this.getLocalBounds();\n\n    var cachedRenderTarget = renderer.context;\n\n    var renderTexture = new core.RenderTexture(renderer, bounds.width | 0, bounds.height | 0);\n\n    // need to set //\n    var m = _tempMatrix;\n\n    m.tx = -bounds.x;\n    m.ty = -bounds.y;\n\n    // set all properties to there original so we can render to a texture\n    this.renderCanvas = this._originalRenderCanvas;\n\n    renderTexture.render(this, m, true);\n\n    // now restore the state be setting the new properties\n    renderer.context = cachedRenderTarget;\n\n    this.renderCanvas = this._renderCachedCanvas;\n    this.updateTransform = this.displayObjectUpdateTransform;\n    this.getBounds  = this._getCachedBounds;\n\n\n    // create our cached sprite\n    this._cachedSprite = new core.Sprite(renderTexture);\n    this._cachedSprite.worldTransform = this.worldTransform;\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n    this.updateTransform();\n\n    this.containsPoint = this._cachedSprite.containsPoint.bind(this._cachedSprite);\n};\n\n/**\n* Calculates the bounds of the cached sprite\n*\n* @private\n*/\nDisplayObject.prototype._getCachedBounds = function ()\n{\n    this._cachedSprite._currentBounds = null;\n\n    return this._cachedSprite.getBounds();\n};\n\n/**\n* Destroys the cached sprite.\n*\n* @private\n*/\nDisplayObject.prototype._destroyCachedDisplayObject = function ()\n{\n    this._cachedSprite._texture.destroy();\n    this._cachedSprite = null;\n};\n\nDisplayObject.prototype._cacheAsBitmapDestroy = function ()\n{\n    this.cacheAsBitmap = false;\n    this._originalDestroy();\n};\n"]},"metadata":{},"sourceType":"script"}