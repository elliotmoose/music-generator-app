{"ast":null,"code":"var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),\n    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),\n    ParticleShader = require('./ParticleShader'),\n    ParticleBuffer = require('./ParticleBuffer'),\n    math = require('../../math');\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\n */\n\n\nfunction ParticleRenderer(renderer) {\n  ObjectRenderer.call(this, renderer);\n  /**\n   * The number of images in the Particle before it flushes.\n   *\n   * @member {number}\n   */\n\n  this.size = 15000; //CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n\n  var numIndices = this.size * 6;\n  /**\n   * Holds the indices\n   *\n   * @member {Uint16Array}\n   */\n\n  this.indices = new Uint16Array(numIndices);\n\n  for (var i = 0, j = 0; i < numIndices; i += 6, j += 4) {\n    this.indices[i + 0] = j + 0;\n    this.indices[i + 1] = j + 1;\n    this.indices[i + 2] = j + 2;\n    this.indices[i + 3] = j + 0;\n    this.indices[i + 4] = j + 2;\n    this.indices[i + 5] = j + 3;\n  }\n  /**\n   * The default shader that is used if a sprite doesn't have a more specific one.\n   *\n   * @member {Shader}\n   */\n\n\n  this.shader = null;\n  this.indexBuffer = null;\n  this.properties = null;\n  this.tempMatrix = new math.Matrix();\n}\n\nParticleRenderer.prototype = Object.create(ObjectRenderer.prototype);\nParticleRenderer.prototype.constructor = ParticleRenderer;\nmodule.exports = ParticleRenderer;\nWebGLRenderer.registerPlugin('particle', ParticleRenderer);\n/**\n * When there is a WebGL context change\n *\n * @private\n *\n */\n\nParticleRenderer.prototype.onContextChange = function () {\n  var gl = this.renderer.gl; // setup default shader\n\n  this.shader = new ParticleShader(this.renderer.shaderManager);\n  this.indexBuffer = gl.createBuffer(); // 65535 is max index, so 65535 / 6 = 10922.\n  //upload the index data\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n  this.properties = [// verticesData\n  {\n    attribute: this.shader.attributes.aVertexPosition,\n    dynamic: false,\n    size: 2,\n    uploadFunction: this.uploadVertices,\n    offset: 0\n  }, // positionData\n  {\n    attribute: this.shader.attributes.aPositionCoord,\n    dynamic: true,\n    size: 2,\n    uploadFunction: this.uploadPosition,\n    offset: 0\n  }, // rotationData\n  {\n    attribute: this.shader.attributes.aRotation,\n    dynamic: false,\n    size: 1,\n    uploadFunction: this.uploadRotation,\n    offset: 0\n  }, // uvsData\n  {\n    attribute: this.shader.attributes.aTextureCoord,\n    dynamic: false,\n    size: 2,\n    uploadFunction: this.uploadUvs,\n    offset: 0\n  }, // alphaData\n  {\n    attribute: this.shader.attributes.aColor,\n    dynamic: false,\n    size: 1,\n    uploadFunction: this.uploadAlpha,\n    offset: 0\n  }];\n};\n/**\n * Starts a new sprite batch.\n *\n */\n\n\nParticleRenderer.prototype.start = function () {\n  var gl = this.renderer.gl; // bind the main texture\n\n  gl.activeTexture(gl.TEXTURE0); // bind the buffers\n\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n  var shader = this.shader;\n  this.renderer.shaderManager.setShader(shader);\n};\n/**\n * Renders the sprite object.\n *\n * @param container {Container|Sprite} the sprite to render using this ParticleRenderer\n */\n\n\nParticleRenderer.prototype.render = function (container) {\n  var children = container.children,\n      totalChildren = children.length,\n      maxSize = container._size;\n\n  if (totalChildren === 0) {\n    return;\n  } else if (totalChildren > maxSize) {\n    totalChildren = maxSize;\n  }\n\n  if (!container._buffers) {\n    container._buffers = this.generateBuffers(container);\n  } // if the uvs have not updated then no point rendering just yet!\n\n\n  this.renderer.blendModeManager.setBlendMode(container.blendMode);\n  var gl = this.renderer.gl;\n  var m = container.worldTransform.copy(this.tempMatrix);\n  m.prepend(this.renderer.currentRenderTarget.projectionMatrix);\n  gl.uniformMatrix3fv(this.shader.uniforms.projectionMatrix._location, false, m.toArray(true));\n  gl.uniform1f(this.shader.uniforms.uAlpha._location, container.worldAlpha); // if this variable is true then we will upload the static contents as well as the dynamic contens\n\n  var uploadStatic = container._updateStatic; // make sure the texture is bound..\n\n  var baseTexture = children[0]._texture.baseTexture;\n\n  if (!baseTexture._glTextures[gl.id]) {\n    // if the texture has not updated then lets not upload any static properties\n    if (!this.renderer.updateTexture(baseTexture)) {\n      return;\n    }\n\n    if (!this.properties[0].dynamic || !this.properties[3].dynamic) {\n      uploadStatic = true;\n    }\n  } else {\n    gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);\n  } // now lets upload and render the buffers..\n\n\n  var j = 0;\n\n  for (var i = 0; i < totalChildren; i += this.size) {\n    var amount = totalChildren - i;\n\n    if (amount > this.size) {\n      amount = this.size;\n    }\n\n    var buffer = container._buffers[j++]; // we always upload the dynamic\n\n    buffer.uploadDynamic(children, i, amount); // we only upload the static content when we have to!\n\n    if (uploadStatic) {\n      buffer.uploadStatic(children, i, amount);\n    } // bind the buffer\n\n\n    buffer.bind(this.shader); // now draw those suckas!\n\n    gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n    this.renderer.drawCount++;\n  }\n\n  container._updateStatic = false;\n};\n/**\n * Creates one particle buffer for each child in the container we want to render and updates internal properties\n *\n * @param container {Container|Sprite} the sprite to render using this ParticleRenderer\n */\n\n\nParticleRenderer.prototype.generateBuffers = function (container) {\n  var gl = this.renderer.gl,\n      buffers = [],\n      size = container._size,\n      i; // update the properties to match the state of the container..\n\n  for (i = 0; i < container._properties.length; i++) {\n    this.properties[i].dynamic = container._properties[i];\n  }\n\n  for (i = 0; i < size; i += this.size) {\n    buffers.push(new ParticleBuffer(gl, this.properties, this.size, this.shader));\n  }\n\n  return buffers;\n};\n/**\n *\n * @param children {Array} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their vertices uploaded\n * @param array {Array}\n * @param stride {number}\n * @param offset {number}\n */\n\n\nParticleRenderer.prototype.uploadVertices = function (children, startIndex, amount, array, stride, offset) {\n  var sprite, texture, trim, sx, sy, w0, w1, h0, h1;\n\n  for (var i = 0; i < amount; i++) {\n    sprite = children[startIndex + i];\n    texture = sprite._texture;\n    sx = sprite.scale.x;\n    sy = sprite.scale.y;\n\n    if (texture.trim) {\n      // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n      trim = texture.trim;\n      w1 = trim.x - sprite.anchor.x * trim.width;\n      w0 = w1 + texture.crop.width;\n      h1 = trim.y - sprite.anchor.y * trim.height;\n      h0 = h1 + texture.crop.height;\n    } else {\n      w0 = texture._frame.width * (1 - sprite.anchor.x);\n      w1 = texture._frame.width * -sprite.anchor.x;\n      h0 = texture._frame.height * (1 - sprite.anchor.y);\n      h1 = texture._frame.height * -sprite.anchor.y;\n    }\n\n    array[offset] = w1 * sx;\n    array[offset + 1] = h1 * sy;\n    array[offset + stride] = w0 * sx;\n    array[offset + stride + 1] = h1 * sy;\n    array[offset + stride * 2] = w0 * sx;\n    array[offset + stride * 2 + 1] = h0 * sy;\n    array[offset + stride * 3] = w1 * sx;\n    array[offset + stride * 3 + 1] = h0 * sy;\n    offset += stride * 4;\n  }\n};\n/**\n *\n * @param children {Array} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their positions uploaded\n * @param array {Array}\n * @param stride {number}\n * @param offset {number}\n */\n\n\nParticleRenderer.prototype.uploadPosition = function (children, startIndex, amount, array, stride, offset) {\n  for (var i = 0; i < amount; i++) {\n    var spritePosition = children[startIndex + i].position;\n    array[offset] = spritePosition.x;\n    array[offset + 1] = spritePosition.y;\n    array[offset + stride] = spritePosition.x;\n    array[offset + stride + 1] = spritePosition.y;\n    array[offset + stride * 2] = spritePosition.x;\n    array[offset + stride * 2 + 1] = spritePosition.y;\n    array[offset + stride * 3] = spritePosition.x;\n    array[offset + stride * 3 + 1] = spritePosition.y;\n    offset += stride * 4;\n  }\n};\n/**\n *\n * @param children {Array} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their rotation uploaded\n * @param array {Array}\n * @param stride {number}\n * @param offset {number}\n */\n\n\nParticleRenderer.prototype.uploadRotation = function (children, startIndex, amount, array, stride, offset) {\n  for (var i = 0; i < amount; i++) {\n    var spriteRotation = children[startIndex + i].rotation;\n    array[offset] = spriteRotation;\n    array[offset + stride] = spriteRotation;\n    array[offset + stride * 2] = spriteRotation;\n    array[offset + stride * 3] = spriteRotation;\n    offset += stride * 4;\n  }\n};\n/**\n *\n * @param children {Array} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their Uvs uploaded\n * @param array {Array}\n * @param stride {number}\n * @param offset {number}\n */\n\n\nParticleRenderer.prototype.uploadUvs = function (children, startIndex, amount, array, stride, offset) {\n  for (var i = 0; i < amount; i++) {\n    var textureUvs = children[startIndex + i]._texture._uvs;\n\n    if (textureUvs) {\n      array[offset] = textureUvs.x0;\n      array[offset + 1] = textureUvs.y0;\n      array[offset + stride] = textureUvs.x1;\n      array[offset + stride + 1] = textureUvs.y1;\n      array[offset + stride * 2] = textureUvs.x2;\n      array[offset + stride * 2 + 1] = textureUvs.y2;\n      array[offset + stride * 3] = textureUvs.x3;\n      array[offset + stride * 3 + 1] = textureUvs.y3;\n      offset += stride * 4;\n    } else {\n      //TODO you know this can be easier!\n      array[offset] = 0;\n      array[offset + 1] = 0;\n      array[offset + stride] = 0;\n      array[offset + stride + 1] = 0;\n      array[offset + stride * 2] = 0;\n      array[offset + stride * 2 + 1] = 0;\n      array[offset + stride * 3] = 0;\n      array[offset + stride * 3 + 1] = 0;\n      offset += stride * 4;\n    }\n  }\n};\n/**\n *\n * @param children {Array} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their alpha uploaded\n * @param array {Array}\n * @param stride {number}\n * @param offset {number}\n */\n\n\nParticleRenderer.prototype.uploadAlpha = function (children, startIndex, amount, array, stride, offset) {\n  for (var i = 0; i < amount; i++) {\n    var spriteAlpha = children[startIndex + i].alpha;\n    array[offset] = spriteAlpha;\n    array[offset + stride] = spriteAlpha;\n    array[offset + stride * 2] = spriteAlpha;\n    array[offset + stride * 3] = spriteAlpha;\n    offset += stride * 4;\n  }\n};\n/**\n * Destroys the Particle.\n *\n */\n\n\nParticleRenderer.prototype.destroy = function () {\n  if (this.renderer.gl) {\n    this.renderer.gl.deleteBuffer(this.indexBuffer);\n  }\n\n  ObjectRenderer.prototype.destroy.apply(this, arguments);\n  this.shader.destroy();\n  this.indices = null;\n  this.tempMatrix = null;\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/particles/webgl/ParticleRenderer.js"],"names":["ObjectRenderer","require","WebGLRenderer","ParticleShader","ParticleBuffer","math","ParticleRenderer","renderer","call","size","numIndices","indices","Uint16Array","i","j","shader","indexBuffer","properties","tempMatrix","Matrix","prototype","Object","create","constructor","module","exports","registerPlugin","onContextChange","gl","shaderManager","createBuffer","bindBuffer","ELEMENT_ARRAY_BUFFER","bufferData","STATIC_DRAW","attribute","attributes","aVertexPosition","dynamic","uploadFunction","uploadVertices","offset","aPositionCoord","uploadPosition","aRotation","uploadRotation","aTextureCoord","uploadUvs","aColor","uploadAlpha","start","activeTexture","TEXTURE0","setShader","render","container","children","totalChildren","length","maxSize","_size","_buffers","generateBuffers","blendModeManager","setBlendMode","blendMode","m","worldTransform","copy","prepend","currentRenderTarget","projectionMatrix","uniformMatrix3fv","uniforms","_location","toArray","uniform1f","uAlpha","worldAlpha","uploadStatic","_updateStatic","baseTexture","_texture","_glTextures","id","updateTexture","bindTexture","TEXTURE_2D","amount","buffer","uploadDynamic","bind","drawElements","TRIANGLES","UNSIGNED_SHORT","drawCount","buffers","_properties","push","startIndex","array","stride","sprite","texture","trim","sx","sy","w0","w1","h0","h1","scale","x","y","anchor","width","crop","height","_frame","spritePosition","position","spriteRotation","rotation","textureUvs","_uvs","x0","y0","x1","y1","x2","y2","x3","y3","spriteAlpha","alpha","destroy","deleteBuffer","apply","arguments"],"mappings":"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","sourcesContent":["var ObjectRenderer = require('../../renderers/webgl/utils/ObjectRenderer'),\n    WebGLRenderer = require('../../renderers/webgl/WebGLRenderer'),\n    ParticleShader = require('./ParticleShader'),\n    ParticleBuffer = require('./ParticleBuffer'),\n    math            = require('../../math');\n\n/**\n * @author Mat Groves\n *\n * Big thanks to the very clever Matt DesLauriers <mattdesl> https://github.com/mattdesl/\n * for creating the original pixi version!\n * Also a thanks to https://github.com/bchevalier for tweaking the tint and alpha so that they now share 4 bytes on the vertex buffer\n *\n * Heavily inspired by LibGDX's ParticleRenderer:\n * https://github.com/libgdx/libgdx/blob/master/gdx/src/com/badlogic/gdx/graphics/g2d/ParticleRenderer.java\n */\n\n/**\n *\n * @class\n * @private\n * @memberof PIXI\n * @param renderer {WebGLRenderer} The renderer this sprite batch works for.\n */\nfunction ParticleRenderer(renderer)\n{\n    ObjectRenderer.call(this, renderer);\n\n    /**\n     * The number of images in the Particle before it flushes.\n     *\n     * @member {number}\n     */\n    this.size = 15000;//CONST.SPRITE_BATCH_SIZE; // 2000 is a nice balance between mobile / desktop\n\n    var numIndices = this.size * 6;\n\n    /**\n     * Holds the indices\n     *\n     * @member {Uint16Array}\n     */\n    this.indices = new Uint16Array(numIndices);\n\n    for (var i=0, j=0; i < numIndices; i += 6, j += 4)\n    {\n        this.indices[i + 0] = j + 0;\n        this.indices[i + 1] = j + 1;\n        this.indices[i + 2] = j + 2;\n        this.indices[i + 3] = j + 0;\n        this.indices[i + 4] = j + 2;\n        this.indices[i + 5] = j + 3;\n    }\n\n    /**\n     * The default shader that is used if a sprite doesn't have a more specific one.\n     *\n     * @member {Shader}\n     */\n    this.shader = null;\n\n    this.indexBuffer = null;\n\n    this.properties = null;\n\n    this.tempMatrix = new math.Matrix();\n}\n\nParticleRenderer.prototype = Object.create(ObjectRenderer.prototype);\nParticleRenderer.prototype.constructor = ParticleRenderer;\nmodule.exports = ParticleRenderer;\n\nWebGLRenderer.registerPlugin('particle', ParticleRenderer);\n\n/**\n * When there is a WebGL context change\n *\n * @private\n *\n */\nParticleRenderer.prototype.onContextChange = function ()\n{\n    var gl = this.renderer.gl;\n\n    // setup default shader\n    this.shader = new ParticleShader(this.renderer.shaderManager);\n\n    this.indexBuffer = gl.createBuffer();\n\n    // 65535 is max index, so 65535 / 6 = 10922.\n\n    //upload the index data\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, this.indices, gl.STATIC_DRAW);\n\n    this.properties = [\n        // verticesData\n        {\n            attribute:this.shader.attributes.aVertexPosition,\n            dynamic:false,\n            size:2,\n            uploadFunction:this.uploadVertices,\n            offset:0\n        },\n        // positionData\n        {\n            attribute:this.shader.attributes.aPositionCoord,\n            dynamic:true,\n            size:2,\n            uploadFunction:this.uploadPosition,\n            offset:0\n        },\n        // rotationData\n        {\n            attribute:this.shader.attributes.aRotation,\n            dynamic:false,\n            size:1,\n            uploadFunction:this.uploadRotation,\n            offset:0\n        },\n        // uvsData\n        {\n            attribute:this.shader.attributes.aTextureCoord,\n            dynamic:false,\n            size:2,\n            uploadFunction:this.uploadUvs,\n            offset:0\n        },\n        // alphaData\n        {\n            attribute:this.shader.attributes.aColor,\n            dynamic:false,\n            size:1,\n            uploadFunction:this.uploadAlpha,\n            offset:0\n        }\n    ];\n};\n\n/**\n * Starts a new sprite batch.\n *\n */\nParticleRenderer.prototype.start = function ()\n{\n    var gl = this.renderer.gl;\n\n    // bind the main texture\n    gl.activeTexture(gl.TEXTURE0);\n\n    // bind the buffers\n\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);\n\n    var shader = this.shader;\n\n    this.renderer.shaderManager.setShader(shader);\n};\n\n\n/**\n * Renders the sprite object.\n *\n * @param container {Container|Sprite} the sprite to render using this ParticleRenderer\n */\nParticleRenderer.prototype.render = function ( container )\n{\n    var children = container.children,\n        totalChildren = children.length,\n        maxSize = container._size;\n\n    if(totalChildren === 0)\n    {\n        return;\n    }\n    else if(totalChildren > maxSize)\n    {\n        totalChildren = maxSize;\n    }\n\n    if(!container._buffers)\n    {\n        container._buffers = this.generateBuffers( container );\n    }\n\n\n\n    // if the uvs have not updated then no point rendering just yet!\n    this.renderer.blendModeManager.setBlendMode(container.blendMode);\n\n    var gl = this.renderer.gl;\n\n    var m =  container.worldTransform.copy( this.tempMatrix );\n    m.prepend( this.renderer.currentRenderTarget.projectionMatrix );\n    gl.uniformMatrix3fv(this.shader.uniforms.projectionMatrix._location, false, m.toArray(true));\n    gl.uniform1f(this.shader.uniforms.uAlpha._location, container.worldAlpha);\n\n\n    // if this variable is true then we will upload the static contents as well as the dynamic contens\n    var uploadStatic = container._updateStatic;\n\n    // make sure the texture is bound..\n    var baseTexture = children[0]._texture.baseTexture;\n\n    if (!baseTexture._glTextures[gl.id])\n    {\n        // if the texture has not updated then lets not upload any static properties\n        if(!this.renderer.updateTexture(baseTexture))\n        {\n            return;\n        }\n\n        if(!this.properties[0].dynamic || !this.properties[3].dynamic)\n        {\n            uploadStatic = true;\n        }\n    }\n    else\n    {\n        gl.bindTexture(gl.TEXTURE_2D, baseTexture._glTextures[gl.id]);\n    }\n\n    // now lets upload and render the buffers..\n    var j = 0;\n    for (var i = 0; i < totalChildren; i+=this.size)\n    {\n         var amount = ( totalChildren - i);\n        if(amount > this.size)\n        {\n            amount = this.size;\n        }\n\n        var buffer = container._buffers[j++];\n\n        // we always upload the dynamic\n        buffer.uploadDynamic(children, i, amount);\n\n        // we only upload the static content when we have to!\n        if(uploadStatic)\n        {\n            buffer.uploadStatic(children, i, amount);\n        }\n\n        // bind the buffer\n        buffer.bind( this.shader );\n\n         // now draw those suckas!\n        gl.drawElements(gl.TRIANGLES, amount * 6, gl.UNSIGNED_SHORT, 0);\n        this.renderer.drawCount++;\n    }\n\n    container._updateStatic = false;\n};\n\n/**\n * Creates one particle buffer for each child in the container we want to render and updates internal properties\n *\n * @param container {Container|Sprite} the sprite to render using this ParticleRenderer\n */\nParticleRenderer.prototype.generateBuffers = function ( container )\n{\n    var gl = this.renderer.gl,\n        buffers = [],\n        size = container._size,\n        i;\n\n    // update the properties to match the state of the container..\n    for (i = 0; i < container._properties.length; i++)\n    {\n        this.properties[i].dynamic = container._properties[i];\n    }\n\n    for (i = 0; i < size; i += this.size)\n    {\n        buffers.push( new ParticleBuffer(gl,  this.properties, this.size, this.shader) );\n    }\n\n    return buffers;\n};\n\n\n/**\n *\n * @param children {Array} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their vertices uploaded\n * @param array {Array}\n * @param stride {number}\n * @param offset {number}\n */\nParticleRenderer.prototype.uploadVertices = function (children, startIndex, amount, array, stride, offset)\n{\n    var sprite,\n        texture,\n        trim,\n        sx,\n        sy,\n        w0, w1, h0, h1;\n\n    for (var i = 0; i < amount; i++) {\n\n        sprite = children[startIndex + i];\n        texture = sprite._texture;\n        sx = sprite.scale.x;\n        sy = sprite.scale.y;\n\n        if (texture.trim)\n        {\n            // if the sprite is trimmed then we need to add the extra space before transforming the sprite coords..\n            trim = texture.trim;\n\n            w1 = trim.x - sprite.anchor.x * trim.width;\n            w0 = w1 + texture.crop.width;\n\n            h1 = trim.y - sprite.anchor.y * trim.height;\n            h0 = h1 + texture.crop.height;\n        }\n        else\n        {\n            w0 = (texture._frame.width ) * (1-sprite.anchor.x);\n            w1 = (texture._frame.width ) * -sprite.anchor.x;\n\n            h0 = texture._frame.height * (1-sprite.anchor.y);\n            h1 = texture._frame.height * -sprite.anchor.y;\n        }\n\n        array[offset] = w1 * sx;\n        array[offset + 1] = h1 * sy;\n\n        array[offset + stride] = w0 * sx;\n        array[offset + stride + 1] = h1 * sy;\n\n        array[offset + stride * 2] = w0 * sx;\n        array[offset + stride * 2 + 1] = h0 * sy;\n\n        array[offset + stride * 3] = w1 * sx;\n        array[offset + stride * 3 + 1] = h0 * sy;\n\n        offset += stride * 4;\n    }\n\n};\n\n/**\n *\n * @param children {Array} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their positions uploaded\n * @param array {Array}\n * @param stride {number}\n * @param offset {number}\n */\nParticleRenderer.prototype.uploadPosition = function (children,startIndex, amount, array, stride, offset)\n{\n    for (var i = 0; i < amount; i++)\n    {\n        var spritePosition = children[startIndex + i].position;\n\n        array[offset] = spritePosition.x;\n        array[offset + 1] = spritePosition.y;\n\n        array[offset + stride] = spritePosition.x;\n        array[offset + stride + 1] = spritePosition.y;\n\n        array[offset + stride * 2] = spritePosition.x;\n        array[offset + stride * 2 + 1] = spritePosition.y;\n\n        array[offset + stride * 3] = spritePosition.x;\n        array[offset + stride * 3 + 1] = spritePosition.y;\n\n        offset += stride * 4;\n    }\n\n};\n\n/**\n *\n * @param children {Array} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their rotation uploaded\n * @param array {Array}\n * @param stride {number}\n * @param offset {number}\n */\nParticleRenderer.prototype.uploadRotation = function (children,startIndex, amount, array, stride, offset)\n{\n    for (var i = 0; i < amount; i++)\n    {\n        var spriteRotation = children[startIndex + i].rotation;\n\n\n        array[offset] = spriteRotation;\n        array[offset + stride] = spriteRotation;\n        array[offset + stride * 2] = spriteRotation;\n        array[offset + stride * 3] = spriteRotation;\n\n        offset += stride * 4;\n    }\n};\n\n/**\n *\n * @param children {Array} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their Uvs uploaded\n * @param array {Array}\n * @param stride {number}\n * @param offset {number}\n */\nParticleRenderer.prototype.uploadUvs = function (children,startIndex, amount, array, stride, offset)\n{\n    for (var i = 0; i < amount; i++)\n    {\n        var textureUvs = children[startIndex + i]._texture._uvs;\n\n        if (textureUvs)\n        {\n            array[offset] = textureUvs.x0;\n            array[offset + 1] = textureUvs.y0;\n\n            array[offset + stride] = textureUvs.x1;\n            array[offset + stride + 1] = textureUvs.y1;\n\n            array[offset + stride * 2] = textureUvs.x2;\n            array[offset + stride * 2 + 1] = textureUvs.y2;\n\n            array[offset + stride * 3] = textureUvs.x3;\n            array[offset + stride * 3 + 1] = textureUvs.y3;\n\n            offset += stride * 4;\n        }\n        else\n        {\n            //TODO you know this can be easier!\n            array[offset] = 0;\n            array[offset + 1] = 0;\n\n            array[offset + stride] = 0;\n            array[offset + stride + 1] = 0;\n\n            array[offset + stride * 2] = 0;\n            array[offset + stride * 2 + 1] = 0;\n\n            array[offset + stride * 3] = 0;\n            array[offset + stride * 3 + 1] = 0;\n\n            offset += stride * 4;\n        }\n    }\n};\n\n/**\n *\n * @param children {Array} the array of display objects to render\n * @param startIndex {number} the index to start from in the children array\n * @param amount {number} the amount of children that will have their alpha uploaded\n * @param array {Array}\n * @param stride {number}\n * @param offset {number}\n */\nParticleRenderer.prototype.uploadAlpha = function (children,startIndex, amount, array, stride, offset)\n{\n     for (var i = 0; i < amount; i++)\n     {\n        var spriteAlpha = children[startIndex + i].alpha;\n\n        array[offset] = spriteAlpha;\n        array[offset + stride] = spriteAlpha;\n        array[offset + stride * 2] = spriteAlpha;\n        array[offset + stride * 3] = spriteAlpha;\n\n        offset += stride * 4;\n    }\n};\n\n\n/**\n * Destroys the Particle.\n *\n */\nParticleRenderer.prototype.destroy = function ()\n{\n    if (this.renderer.gl) {\n        this.renderer.gl.deleteBuffer(this.indexBuffer);\n    }\n\n    ObjectRenderer.prototype.destroy.apply(this, arguments);\n\n    this.shader.destroy();\n\n    this.indices = null;\n    this.tempMatrix = null;\n};\n"]},"metadata":{},"sourceType":"script"}