{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\n\nexport var ToneAudioNode = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(ToneAudioNode, _ToneWithContext);\n\n  var _super = _createSuper(ToneAudioNode);\n\n  function ToneAudioNode() {\n    var _this;\n\n    _classCallCheck(this, ToneAudioNode);\n\n    _this = _super.apply(this, arguments);\n    /**\n     * The name of the class\n     */\n\n    _this.name = \"ToneAudioNode\";\n    /**\n     * List all of the node that must be set to match the ChannelProperties\n     */\n\n    _this._internalChannels = [];\n    return _this;\n  }\n  /**\n   * The number of inputs feeding into the AudioNode.\n   * For source nodes, this will be 0.\n   * @example\n   * const node = new Tone.Gain();\n   * console.log(node.numberOfInputs);\n   */\n\n\n  _createClass(ToneAudioNode, [{\n    key: \"_isAudioNode\",\n    //-------------------------------------\n    // AUDIO PROPERTIES\n    //-------------------------------------\n\n    /**\n     * Used to decide which nodes to get/set properties on\n     */\n    value: function _isAudioNode(node) {\n      return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n    }\n    /**\n     * Get all of the audio nodes (either internal or input/output) which together\n     * make up how the class node responds to channel input/output\n     */\n\n  }, {\n    key: \"_getInternalNodes\",\n    value: function _getInternalNodes() {\n      var nodeList = this._internalChannels.slice(0);\n\n      if (this._isAudioNode(this.input)) {\n        nodeList.push(this.input);\n      }\n\n      if (this._isAudioNode(this.output)) {\n        if (this.input !== this.output) {\n          nodeList.push(this.output);\n        }\n      }\n\n      return nodeList;\n    }\n    /**\n     * Set the audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     * @param options\n     */\n\n  }, {\n    key: \"_setChannelProperties\",\n    value: function _setChannelProperties(options) {\n      var nodeList = this._getInternalNodes();\n\n      nodeList.forEach(function (node) {\n        node.channelCount = options.channelCount;\n        node.channelCountMode = options.channelCountMode;\n        node.channelInterpretation = options.channelInterpretation;\n      });\n    }\n    /**\n     * Get the current audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     */\n\n  }, {\n    key: \"_getChannelProperties\",\n    value: function _getChannelProperties() {\n      var nodeList = this._getInternalNodes();\n\n      assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\"); // use the first node to get properties\n      // they should all be the same\n\n      var node = nodeList[0];\n      return {\n        channelCount: node.channelCount,\n        channelCountMode: node.channelCountMode,\n        channelInterpretation: node.channelInterpretation\n      };\n    }\n    /**\n     * channelCount is the number of channels used when up-mixing and down-mixing\n     * connections to any inputs to the node. The default value is 2 except for\n     * specific nodes where its value is specially determined.\n     */\n\n  }, {\n    key: \"connect\",\n    //-------------------------------------\n    // CONNECTIONS\n    //-------------------------------------\n\n    /**\n     * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n     * @param destination The output to connect to\n     * @param outputNum The output to connect from\n     * @param inputNum The input to connect to\n     */\n    value: function connect(destination) {\n      var outputNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var inputNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      _connect(this, destination, outputNum, inputNum);\n\n      return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * @example\n     * const osc = new Tone.Oscillator(\"C2\").start();\n     * osc.toDestination();\n     */\n\n  }, {\n    key: \"toDestination\",\n    value: function toDestination() {\n      this.connect(this.context.destination);\n      return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * See [[toDestination]]\n     * @deprecated\n     */\n\n  }, {\n    key: \"toMaster\",\n    value: function toMaster() {\n      warn(\"toMaster() has been renamed toDestination()\");\n      return this.toDestination();\n    }\n    /**\n     * disconnect the output\n     */\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect(destination) {\n      var outputNum = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var inputNum = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      _disconnect(this, destination, outputNum, inputNum);\n\n      return this;\n    }\n    /**\n     * Connect the output of this node to the rest of the nodes in series.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n     * player.autostart = true;\n     * const filter = new Tone.AutoFilter(4).start();\n     * const distortion = new Tone.Distortion(0.5);\n     * // connect the player to the filter, distortion and then to the master output\n     * player.chain(filter, distortion, Tone.Destination);\n     */\n\n  }, {\n    key: \"chain\",\n    value: function chain() {\n      for (var _len = arguments.length, nodes = new Array(_len), _key = 0; _key < _len; _key++) {\n        nodes[_key] = arguments[_key];\n      }\n\n      connectSeries.apply(void 0, [this].concat(nodes));\n      return this;\n    }\n    /**\n     * connect the output of this node to the rest of the nodes in parallel.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n     * player.autostart = true;\n     * const pitchShift = new Tone.PitchShift(4).toDestination();\n     * const filter = new Tone.Filter(\"G5\").toDestination();\n     * // connect a node to the pitch shift and filter in parallel\n     * player.fan(pitchShift, filter);\n     */\n\n  }, {\n    key: \"fan\",\n    value: function fan() {\n      var _this2 = this;\n\n      for (var _len2 = arguments.length, nodes = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        nodes[_key2] = arguments[_key2];\n      }\n\n      nodes.forEach(function (node) {\n        return _this2.connect(node);\n      });\n      return this;\n    }\n    /**\n     * Dispose and disconnect\n     */\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(ToneAudioNode.prototype), \"dispose\", this).call(this);\n\n      if (isDefined(this.input)) {\n        if (this.input instanceof ToneAudioNode) {\n          this.input.dispose();\n        } else if (isAudioNode(this.input)) {\n          this.input.disconnect();\n        }\n      }\n\n      if (isDefined(this.output)) {\n        if (this.output instanceof ToneAudioNode) {\n          this.output.dispose();\n        } else if (isAudioNode(this.output)) {\n          this.output.disconnect();\n        }\n      }\n\n      this._internalChannels = [];\n      return this;\n    }\n  }, {\n    key: \"numberOfInputs\",\n    get: function get() {\n      if (isDefined(this.input)) {\n        if (isAudioParam(this.input) || this.input instanceof Param) {\n          return 1;\n        } else {\n          return this.input.numberOfInputs;\n        }\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The number of outputs of the AudioNode.\n     * @example\n     * const node = new Tone.Gain();\n     * console.log(node.numberOfOutputs);\n     */\n\n  }, {\n    key: \"numberOfOutputs\",\n    get: function get() {\n      if (isDefined(this.output)) {\n        return this.output.numberOfOutputs;\n      } else {\n        return 0;\n      }\n    }\n  }, {\n    key: \"channelCount\",\n    get: function get() {\n      return this._getChannelProperties().channelCount;\n    },\n    set: function set(channelCount) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelCount: channelCount\n      }));\n    }\n    /**\n     * channelCountMode determines how channels will be counted when up-mixing and\n     * down-mixing connections to any inputs to the node.\n     * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n     * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n     * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n     * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n     */\n\n  }, {\n    key: \"channelCountMode\",\n    get: function get() {\n      return this._getChannelProperties().channelCountMode;\n    },\n    set: function set(channelCountMode) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelCountMode: channelCountMode\n      }));\n    }\n    /**\n     * channelInterpretation determines how individual channels will be treated\n     * when up-mixing and down-mixing connections to any inputs to the node.\n     * The default value is \"speakers\".\n     */\n\n  }, {\n    key: \"channelInterpretation\",\n    get: function get() {\n      return this._getChannelProperties().channelInterpretation;\n    },\n    set: function set(channelInterpretation) {\n      var props = this._getChannelProperties(); // merge it with the other properties\n\n\n      this._setChannelProperties(Object.assign(props, {\n        channelInterpretation: channelInterpretation\n      }));\n    }\n  }]);\n\n  return ToneAudioNode;\n}(ToneWithContext); //-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\n\nexport function connectSeries() {\n  for (var _len3 = arguments.length, nodes = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    nodes[_key3] = arguments[_key3];\n  }\n\n  var first = nodes.shift();\n  nodes.reduce(function (prev, current) {\n    if (prev instanceof ToneAudioNode) {\n      prev.connect(current);\n    } else if (isAudioNode(prev)) {\n      _connect(prev, current);\n    }\n\n    return current;\n  }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\nfunction _connect(srcNode, dstNode) {\n  var outputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var inputNumber = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n  assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n  if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n    assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n  }\n\n  assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\"); // resolve the input of the dstNode\n\n  while (dstNode instanceof ToneAudioNode || dstNode instanceof Param) {\n    if (isDefined(dstNode.input)) {\n      dstNode = dstNode.input;\n    }\n  }\n\n  while (srcNode instanceof ToneAudioNode) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  } // make the connection\n\n\n  if (isAudioParam(dstNode)) {\n    srcNode.connect(dstNode, outputNumber);\n  } else {\n    srcNode.connect(dstNode, outputNumber, inputNumber);\n  }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\n\n\nexport { _connect as connect };\n\nfunction _disconnect(srcNode, dstNode) {\n  var outputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var inputNumber = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n  // resolve the destination node\n  if (isDefined(dstNode)) {\n    while (dstNode instanceof ToneAudioNode) {\n      dstNode = dstNode.input;\n    }\n  } // resolve the src node\n\n\n  while (!isAudioNode(srcNode)) {\n    if (isDefined(srcNode.output)) {\n      srcNode = srcNode.output;\n    }\n  }\n\n  if (isAudioParam(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber);\n  } else if (isAudioNode(dstNode)) {\n    srcNode.disconnect(dstNode, outputNumber, inputNumber);\n  } else {\n    srcNode.disconnect();\n  }\n}\n\nexport { _disconnect as disconnect };","map":{"version":3,"sources":["../../../../Tone/core/context/ToneAudioNode.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\nexport class ToneAudioNode extends ToneWithContext {\n    constructor() {\n        super(...arguments);\n        /**\n         * The name of the class\n         */\n        this.name = \"ToneAudioNode\";\n        /**\n         * List all of the node that must be set to match the ChannelProperties\n         */\n        this._internalChannels = [];\n    }\n    /**\n     * The number of inputs feeding into the AudioNode.\n     * For source nodes, this will be 0.\n     * @example\n     * const node = new Tone.Gain();\n     * console.log(node.numberOfInputs);\n     */\n    get numberOfInputs() {\n        if (isDefined(this.input)) {\n            if (isAudioParam(this.input) || this.input instanceof Param) {\n                return 1;\n            }\n            else {\n                return this.input.numberOfInputs;\n            }\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * The number of outputs of the AudioNode.\n     * @example\n     * const node = new Tone.Gain();\n     * console.log(node.numberOfOutputs);\n     */\n    get numberOfOutputs() {\n        if (isDefined(this.output)) {\n            return this.output.numberOfOutputs;\n        }\n        else {\n            return 0;\n        }\n    }\n    //-------------------------------------\n    // AUDIO PROPERTIES\n    //-------------------------------------\n    /**\n     * Used to decide which nodes to get/set properties on\n     */\n    _isAudioNode(node) {\n        return isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n    }\n    /**\n     * Get all of the audio nodes (either internal or input/output) which together\n     * make up how the class node responds to channel input/output\n     */\n    _getInternalNodes() {\n        const nodeList = this._internalChannels.slice(0);\n        if (this._isAudioNode(this.input)) {\n            nodeList.push(this.input);\n        }\n        if (this._isAudioNode(this.output)) {\n            if (this.input !== this.output) {\n                nodeList.push(this.output);\n            }\n        }\n        return nodeList;\n    }\n    /**\n     * Set the audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     * @param options\n     */\n    _setChannelProperties(options) {\n        const nodeList = this._getInternalNodes();\n        nodeList.forEach(node => {\n            node.channelCount = options.channelCount;\n            node.channelCountMode = options.channelCountMode;\n            node.channelInterpretation = options.channelInterpretation;\n        });\n    }\n    /**\n     * Get the current audio options for this node such as channelInterpretation\n     * channelCount, etc.\n     */\n    _getChannelProperties() {\n        const nodeList = this._getInternalNodes();\n        assert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\");\n        // use the first node to get properties\n        // they should all be the same\n        const node = nodeList[0];\n        return {\n            channelCount: node.channelCount,\n            channelCountMode: node.channelCountMode,\n            channelInterpretation: node.channelInterpretation,\n        };\n    }\n    /**\n     * channelCount is the number of channels used when up-mixing and down-mixing\n     * connections to any inputs to the node. The default value is 2 except for\n     * specific nodes where its value is specially determined.\n     */\n    get channelCount() {\n        return this._getChannelProperties().channelCount;\n    }\n    set channelCount(channelCount) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelCount }));\n    }\n    /**\n     * channelCountMode determines how channels will be counted when up-mixing and\n     * down-mixing connections to any inputs to the node.\n     * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n     * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n     * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n     * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n     */\n    get channelCountMode() {\n        return this._getChannelProperties().channelCountMode;\n    }\n    set channelCountMode(channelCountMode) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelCountMode }));\n    }\n    /**\n     * channelInterpretation determines how individual channels will be treated\n     * when up-mixing and down-mixing connections to any inputs to the node.\n     * The default value is \"speakers\".\n     */\n    get channelInterpretation() {\n        return this._getChannelProperties().channelInterpretation;\n    }\n    set channelInterpretation(channelInterpretation) {\n        const props = this._getChannelProperties();\n        // merge it with the other properties\n        this._setChannelProperties(Object.assign(props, { channelInterpretation }));\n    }\n    //-------------------------------------\n    // CONNECTIONS\n    //-------------------------------------\n    /**\n     * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n     * @param destination The output to connect to\n     * @param outputNum The output to connect from\n     * @param inputNum The input to connect to\n     */\n    connect(destination, outputNum = 0, inputNum = 0) {\n        connect(this, destination, outputNum, inputNum);\n        return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * @example\n     * const osc = new Tone.Oscillator(\"C2\").start();\n     * osc.toDestination();\n     */\n    toDestination() {\n        this.connect(this.context.destination);\n        return this;\n    }\n    /**\n     * Connect the output to the context's destination node.\n     * See [[toDestination]]\n     * @deprecated\n     */\n    toMaster() {\n        warn(\"toMaster() has been renamed toDestination()\");\n        return this.toDestination();\n    }\n    /**\n     * disconnect the output\n     */\n    disconnect(destination, outputNum = 0, inputNum = 0) {\n        disconnect(this, destination, outputNum, inputNum);\n        return this;\n    }\n    /**\n     * Connect the output of this node to the rest of the nodes in series.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n     * player.autostart = true;\n     * const filter = new Tone.AutoFilter(4).start();\n     * const distortion = new Tone.Distortion(0.5);\n     * // connect the player to the filter, distortion and then to the master output\n     * player.chain(filter, distortion, Tone.Destination);\n     */\n    chain(...nodes) {\n        connectSeries(this, ...nodes);\n        return this;\n    }\n    /**\n     * connect the output of this node to the rest of the nodes in parallel.\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n     * player.autostart = true;\n     * const pitchShift = new Tone.PitchShift(4).toDestination();\n     * const filter = new Tone.Filter(\"G5\").toDestination();\n     * // connect a node to the pitch shift and filter in parallel\n     * player.fan(pitchShift, filter);\n     */\n    fan(...nodes) {\n        nodes.forEach(node => this.connect(node));\n        return this;\n    }\n    /**\n     * Dispose and disconnect\n     */\n    dispose() {\n        super.dispose();\n        if (isDefined(this.input)) {\n            if (this.input instanceof ToneAudioNode) {\n                this.input.dispose();\n            }\n            else if (isAudioNode(this.input)) {\n                this.input.disconnect();\n            }\n        }\n        if (isDefined(this.output)) {\n            if (this.output instanceof ToneAudioNode) {\n                this.output.dispose();\n            }\n            else if (isAudioNode(this.output)) {\n                this.output.disconnect();\n            }\n        }\n        this._internalChannels = [];\n        return this;\n    }\n}\n//-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\nexport function connectSeries(...nodes) {\n    const first = nodes.shift();\n    nodes.reduce((prev, current) => {\n        if (prev instanceof ToneAudioNode) {\n            prev.connect(current);\n        }\n        else if (isAudioNode(prev)) {\n            connect(prev, current);\n        }\n        return current;\n    }, first);\n}\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n    assert(isDefined(srcNode), \"Cannot connect from undefined node\");\n    assert(isDefined(dstNode), \"Cannot connect to undefined node\");\n    if (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n        assert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n    }\n    assert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\");\n    // resolve the input of the dstNode\n    while ((dstNode instanceof ToneAudioNode || dstNode instanceof Param)) {\n        if (isDefined(dstNode.input)) {\n            dstNode = dstNode.input;\n        }\n    }\n    while (srcNode instanceof ToneAudioNode) {\n        if (isDefined(srcNode.output)) {\n            srcNode = srcNode.output;\n        }\n    }\n    // make the connection\n    if (isAudioParam(dstNode)) {\n        srcNode.connect(dstNode, outputNumber);\n    }\n    else {\n        srcNode.connect(dstNode, outputNumber, inputNumber);\n    }\n}\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(srcNode, dstNode, outputNumber = 0, inputNumber = 0) {\n    // resolve the destination node\n    if (isDefined(dstNode)) {\n        while (dstNode instanceof ToneAudioNode) {\n            dstNode = dstNode.input;\n        }\n    }\n    // resolve the src node\n    while (!(isAudioNode(srcNode))) {\n        if (isDefined(srcNode.output)) {\n            srcNode = srcNode.output;\n        }\n    }\n    if (isAudioParam(dstNode)) {\n        srcNode.disconnect(dstNode, outputNumber);\n    }\n    else if (isAudioNode(dstNode)) {\n        srcNode.disconnect(dstNode, outputNumber, inputNumber);\n    }\n    else {\n        srcNode.disconnect();\n    }\n}\n//# sourceMappingURL=ToneAudioNode.js.map"]},"metadata":{},"sourceType":"module"}