{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Return the index of the element at or before the given property\n * @hidden\n */\n\nfunction search(array, value, prop) {\n  if (prop === void 0) {\n    prop = \"ticks\";\n  }\n\n  var beginning = 0;\n  var len = array.length;\n  var end = len;\n\n  if (len > 0 && array[len - 1][prop] <= value) {\n    return len - 1;\n  }\n\n  while (beginning < end) {\n    // calculate the midpoint for roughly equal partition\n    var midPoint = Math.floor(beginning + (end - beginning) / 2);\n    var event_1 = array[midPoint];\n    var nextEvent = array[midPoint + 1];\n\n    if (event_1[prop] === value) {\n      // choose the last one that has the same value\n      for (var i = midPoint; i < array.length; i++) {\n        var testEvent = array[i];\n\n        if (testEvent[prop] === value) {\n          midPoint = i;\n        }\n      }\n\n      return midPoint;\n    } else if (event_1[prop] < value && nextEvent[prop] > value) {\n      return midPoint;\n    } else if (event_1[prop] > value) {\n      // search lower\n      end = midPoint;\n    } else if (event_1[prop] < value) {\n      // search upper\n      beginning = midPoint + 1;\n    }\n  }\n\n  return -1;\n}\n\nexports.search = search;\n/**\n * Does a binary search to insert the note\n * in the correct spot in the array\n * @hidden\n */\n\nfunction insert(array, event, prop) {\n  if (prop === void 0) {\n    prop = \"ticks\";\n  }\n\n  if (array.length) {\n    var index = search(array, event[prop], prop);\n    array.splice(index + 1, 0, event);\n  } else {\n    array.push(event);\n  }\n}\n\nexports.insert = insert;","map":{"version":3,"sources":["../src/BinarySearch.ts"],"names":[],"mappings":";;;;;AAAA;;;AAGG;;AACH,SAAgB,MAAhB,CAAuB,KAAvB,EAAqC,KAArC,EAAiD,IAAjD,EAA8D;AAAb,MAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,IAAA,GAAA,OAAA;AAAa;;AAC7D,MAAI,SAAS,GAAG,CAAhB;AACA,MAAM,GAAG,GAAG,KAAK,CAAC,MAAlB;AACA,MAAI,GAAG,GAAG,GAAV;;AACA,MAAI,GAAG,GAAG,CAAN,IAAW,KAAK,CAAC,GAAG,GAAG,CAAP,CAAL,CAAe,IAAf,KAAwB,KAAvC,EAA8C;AAC7C,WAAO,GAAG,GAAG,CAAb;AACA;;AACD,SAAO,SAAS,GAAG,GAAnB,EAAwB;AACvB;AACA,QAAI,QAAQ,GAAG,IAAI,CAAC,KAAL,CAAW,SAAS,GAAG,CAAC,GAAG,GAAG,SAAP,IAAoB,CAA3C,CAAf;AACA,QAAM,OAAK,GAAG,KAAK,CAAC,QAAD,CAAnB;AACA,QAAM,SAAS,GAAG,KAAK,CAAC,QAAQ,GAAG,CAAZ,CAAvB;;AACA,QAAI,OAAK,CAAC,IAAD,CAAL,KAAgB,KAApB,EAA2B;AAC1B;AACA,WAAK,IAAI,CAAC,GAAG,QAAb,EAAuB,CAAC,GAAG,KAAK,CAAC,MAAjC,EAAyC,CAAC,EAA1C,EAA8C;AAC7C,YAAM,SAAS,GAAG,KAAK,CAAC,CAAD,CAAvB;;AACA,YAAI,SAAS,CAAC,IAAD,CAAT,KAAoB,KAAxB,EAA+B;AAC9B,UAAA,QAAQ,GAAG,CAAX;AACA;AACD;;AACD,aAAO,QAAP;AACA,KATD,MASO,IAAI,OAAK,CAAC,IAAD,CAAL,GAAc,KAAd,IAAuB,SAAS,CAAC,IAAD,CAAT,GAAkB,KAA7C,EAAoD;AAC1D,aAAO,QAAP;AACA,KAFM,MAEA,IAAI,OAAK,CAAC,IAAD,CAAL,GAAc,KAAlB,EAAyB;AAC/B;AACA,MAAA,GAAG,GAAG,QAAN;AACA,KAHM,MAGA,IAAI,OAAK,CAAC,IAAD,CAAL,GAAc,KAAlB,EAAyB;AAC/B;AACA,MAAA,SAAS,GAAG,QAAQ,GAAG,CAAvB;AACA;AACD;;AACD,SAAO,CAAC,CAAR;AACA;;AAhCD,OAAA,CAAA,MAAA,GAAA,MAAA;AAkCA;;;;AAIG;;AACH,SAAgB,MAAhB,CAAuB,KAAvB,EAAqC,KAArC,EAAoD,IAApD,EAAkE;AAAd,MAAA,IAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,IAAA,GAAA,OAAA;AAAc;;AACjE,MAAI,KAAK,CAAC,MAAV,EAAkB;AACjB,QAAM,KAAK,GAAG,MAAM,CAAC,KAAD,EAAQ,KAAK,CAAC,IAAD,CAAb,EAAqB,IAArB,CAApB;AACA,IAAA,KAAK,CAAC,MAAN,CAAa,KAAK,GAAG,CAArB,EAAwB,CAAxB,EAA2B,KAA3B;AACA,GAHD,MAGO;AACN,IAAA,KAAK,CAAC,IAAN,CAAW,KAAX;AACA;AACD;;AAPD,OAAA,CAAA,MAAA,GAAA,MAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Return the index of the element at or before the given property\n * @hidden\n */\nfunction search(array, value, prop) {\n    if (prop === void 0) { prop = \"ticks\"; }\n    var beginning = 0;\n    var len = array.length;\n    var end = len;\n    if (len > 0 && array[len - 1][prop] <= value) {\n        return len - 1;\n    }\n    while (beginning < end) {\n        // calculate the midpoint for roughly equal partition\n        var midPoint = Math.floor(beginning + (end - beginning) / 2);\n        var event_1 = array[midPoint];\n        var nextEvent = array[midPoint + 1];\n        if (event_1[prop] === value) {\n            // choose the last one that has the same value\n            for (var i = midPoint; i < array.length; i++) {\n                var testEvent = array[i];\n                if (testEvent[prop] === value) {\n                    midPoint = i;\n                }\n            }\n            return midPoint;\n        }\n        else if (event_1[prop] < value && nextEvent[prop] > value) {\n            return midPoint;\n        }\n        else if (event_1[prop] > value) {\n            // search lower\n            end = midPoint;\n        }\n        else if (event_1[prop] < value) {\n            // search upper\n            beginning = midPoint + 1;\n        }\n    }\n    return -1;\n}\nexports.search = search;\n/**\n * Does a binary search to insert the note\n * in the correct spot in the array\n * @hidden\n */\nfunction insert(array, event, prop) {\n    if (prop === void 0) { prop = \"ticks\"; }\n    if (array.length) {\n        var index = search(array, event[prop], prop);\n        array.splice(index + 1, 0, event);\n    }\n    else {\n        array.push(event);\n    }\n}\nexports.insert = insert;\n//# sourceMappingURL=BinarySearch.js.map"]},"metadata":{},"sourceType":"script"}