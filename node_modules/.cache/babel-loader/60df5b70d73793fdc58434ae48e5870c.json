{"ast":null,"code":"var core = require('../core'),\n    // a sprite use dfor rendering textures..\ntempPoint = new core.Point();\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n * @param texture {Texture} the texture of the tiling sprite\n * @param width {number}  the width of the tiling sprite\n * @param height {number} the height of the tiling sprite\n */\n\n\nfunction TilingSprite(texture, width, height) {\n  core.Sprite.call(this, texture);\n  /**\n   * The scaling of the image that is being tiled\n   *\n   * @member {Point}\n   */\n\n  this.tileScale = new core.Point(1, 1);\n  /**\n   * The offset position of the image that is being tiled\n   *\n   * @member {Point}\n   */\n\n  this.tilePosition = new core.Point(0, 0); ///// private\n\n  /**\n   * The with of the tiling sprite\n   *\n   * @member {number}\n   * @private\n   */\n\n  this._width = width || 100;\n  /**\n   * The height of the tiling sprite\n   *\n   * @member {number}\n   * @private\n   */\n\n  this._height = height || 100;\n  /**\n   * An internal WebGL UV cache.\n   *\n   * @member {TextureUvs}\n   * @private\n   */\n\n  this._uvs = new core.TextureUvs();\n  this._canvasPattern = null; //TODO move..\n\n  this.shader = new core.AbstractFilter(['precision lowp float;', 'attribute vec2 aVertexPosition;', 'attribute vec2 aTextureCoord;', 'attribute vec4 aColor;', 'uniform mat3 projectionMatrix;', 'uniform vec4 uFrame;', 'uniform vec4 uTransform;', 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'void main(void){', '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);', '   vec2 coord = aTextureCoord;', '   coord -= uTransform.xy;', '   coord /= uTransform.zw;', '   vTextureCoord = coord;', '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);', '}'].join('\\n'), ['precision lowp float;', 'varying vec2 vTextureCoord;', 'varying vec4 vColor;', 'uniform sampler2D uSampler;', 'uniform vec4 uFrame;', 'uniform vec2 uPixelSize;', 'void main(void){', '   vec2 coord = mod(vTextureCoord, uFrame.zw);', '   coord = clamp(coord, uPixelSize, uFrame.zw - uPixelSize);', '   coord += uFrame.xy;', '   gl_FragColor =  texture2D(uSampler, coord) * vColor ;', '}'].join('\\n'), // set the uniforms\n  {\n    uFrame: {\n      type: '4fv',\n      value: [0, 0, 1, 1]\n    },\n    uTransform: {\n      type: '4fv',\n      value: [0, 0, 1, 1]\n    },\n    uPixelSize: {\n      type: '2fv',\n      value: [1, 1]\n    }\n  });\n}\n\nTilingSprite.prototype = Object.create(core.Sprite.prototype);\nTilingSprite.prototype.constructor = TilingSprite;\nmodule.exports = TilingSprite;\nObject.defineProperties(TilingSprite.prototype, {\n  /**\n   * The width of the sprite, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   * @memberof TilingSprite#\n   */\n  width: {\n    get: function () {\n      return this._width;\n    },\n    set: function (value) {\n      this._width = value;\n    }\n  },\n\n  /**\n   * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n   *\n   * @member {number}\n   * @memberof TilingSprite#\n   */\n  height: {\n    get: function () {\n      return this._height;\n    },\n    set: function (value) {\n      this._height = value;\n    }\n  }\n});\n\nTilingSprite.prototype._onTextureUpdate = function () {\n  return;\n};\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n * @private\n */\n\n\nTilingSprite.prototype._renderWebGL = function (renderer) {\n  // tweak our texture temporarily..\n  var texture = this._texture;\n\n  if (!texture || !texture._uvs) {\n    return;\n  }\n\n  var tempUvs = texture._uvs,\n      tempWidth = texture._frame.width,\n      tempHeight = texture._frame.height,\n      tw = texture.baseTexture.width,\n      th = texture.baseTexture.height;\n  texture._uvs = this._uvs;\n  texture._frame.width = this.width;\n  texture._frame.height = this.height;\n  this.shader.uniforms.uPixelSize.value[0] = 1.0 / tw;\n  this.shader.uniforms.uPixelSize.value[1] = 1.0 / th;\n  this.shader.uniforms.uFrame.value[0] = tempUvs.x0;\n  this.shader.uniforms.uFrame.value[1] = tempUvs.y0;\n  this.shader.uniforms.uFrame.value[2] = tempUvs.x1 - tempUvs.x0;\n  this.shader.uniforms.uFrame.value[3] = tempUvs.y2 - tempUvs.y0;\n  this.shader.uniforms.uTransform.value[0] = this.tilePosition.x % (tempWidth * this.tileScale.x) / this._width;\n  this.shader.uniforms.uTransform.value[1] = this.tilePosition.y % (tempHeight * this.tileScale.y) / this._height;\n  this.shader.uniforms.uTransform.value[2] = tw / this._width * this.tileScale.x;\n  this.shader.uniforms.uTransform.value[3] = th / this._height * this.tileScale.y;\n  renderer.setObjectRenderer(renderer.plugins.sprite);\n  renderer.plugins.sprite.render(this);\n  texture._uvs = tempUvs;\n  texture._frame.width = tempWidth;\n  texture._frame.height = tempHeight;\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer} a reference to the canvas renderer\n * @private\n */\n\n\nTilingSprite.prototype._renderCanvas = function (renderer) {\n  var texture = this._texture;\n\n  if (!texture.baseTexture.hasLoaded) {\n    return;\n  }\n\n  var context = renderer.context,\n      transform = this.worldTransform,\n      resolution = renderer.resolution,\n      baseTexture = texture.baseTexture,\n      modX = this.tilePosition.x % (texture._frame.width * this.tileScale.x),\n      modY = this.tilePosition.y % (texture._frame.height * this.tileScale.y); // create a nice shiny pattern!\n  // TODO this needs to be refreshed if texture changes..\n\n  if (!this._canvasPattern) {\n    // cut an object from a spritesheet..\n    var tempCanvas = new core.CanvasBuffer(texture._frame.width, texture._frame.height);\n    tempCanvas.context.drawImage(baseTexture.source, -texture._frame.x, -texture._frame.y);\n    this._canvasPattern = tempCanvas.context.createPattern(tempCanvas.canvas, 'repeat');\n  } // set context state..\n\n\n  context.globalAlpha = this.worldAlpha;\n  context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution); // TODO - this should be rolled into the setTransform above..\n\n  context.scale(this.tileScale.x, this.tileScale.y);\n  context.translate(modX + this.anchor.x * -this._width, modY + this.anchor.y * -this._height); // check blend mode\n\n  if (this.blendMode !== renderer.currentBlendMode) {\n    renderer.currentBlendMode = this.blendMode;\n    context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];\n  } // fill the pattern!\n\n\n  context.fillStyle = this._canvasPattern;\n  context.fillRect(-modX, -modY, this._width / this.tileScale.x, this._height / this.tileScale.y); //TODO - pretty sure this can be deleted...\n  //context.translate(-this.tilePosition.x + (this.anchor.x * this._width), -this.tilePosition.y + (this.anchor.y * this._height));\n  //context.scale(1 / this.tileScale.x, 1 / this.tileScale.y);\n};\n/**\n * Returns the framing rectangle of the sprite as a Rectangle object\n*\n * @return {Rectangle} the framing rectangle\n */\n\n\nTilingSprite.prototype.getBounds = function () {\n  var width = this._width;\n  var height = this._height;\n  var w0 = width * (1 - this.anchor.x);\n  var w1 = width * -this.anchor.x;\n  var h0 = height * (1 - this.anchor.y);\n  var h1 = height * -this.anchor.y;\n  var worldTransform = this.worldTransform;\n  var a = worldTransform.a;\n  var b = worldTransform.b;\n  var c = worldTransform.c;\n  var d = worldTransform.d;\n  var tx = worldTransform.tx;\n  var ty = worldTransform.ty;\n  var x1 = a * w1 + c * h1 + tx;\n  var y1 = d * h1 + b * w1 + ty;\n  var x2 = a * w0 + c * h1 + tx;\n  var y2 = d * h1 + b * w0 + ty;\n  var x3 = a * w0 + c * h0 + tx;\n  var y3 = d * h0 + b * w0 + ty;\n  var x4 = a * w1 + c * h0 + tx;\n  var y4 = d * h0 + b * w1 + ty;\n  var minX, maxX, minY, maxY;\n  minX = x1;\n  minX = x2 < minX ? x2 : minX;\n  minX = x3 < minX ? x3 : minX;\n  minX = x4 < minX ? x4 : minX;\n  minY = y1;\n  minY = y2 < minY ? y2 : minY;\n  minY = y3 < minY ? y3 : minY;\n  minY = y4 < minY ? y4 : minY;\n  maxX = x1;\n  maxX = x2 > maxX ? x2 : maxX;\n  maxX = x3 > maxX ? x3 : maxX;\n  maxX = x4 > maxX ? x4 : maxX;\n  maxY = y1;\n  maxY = y2 > maxY ? y2 : maxY;\n  maxY = y3 > maxY ? y3 : maxY;\n  maxY = y4 > maxY ? y4 : maxY;\n  var bounds = this._bounds;\n  bounds.x = minX;\n  bounds.width = maxX - minX;\n  bounds.y = minY;\n  bounds.height = maxY - minY; // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n\n  this._currentBounds = bounds;\n  return bounds;\n};\n/**\n * Checks if a point is inside this tiling sprite\n * @param point {Point} the point to check\n */\n\n\nTilingSprite.prototype.containsPoint = function (point) {\n  this.worldTransform.applyInverse(point, tempPoint);\n  var width = this._width;\n  var height = this._height;\n  var x1 = -width * this.anchor.x;\n  var y1;\n\n  if (tempPoint.x > x1 && tempPoint.x < x1 + width) {\n    y1 = -height * this.anchor.y;\n\n    if (tempPoint.y > y1 && tempPoint.y < y1 + height) {\n      return true;\n    }\n  }\n\n  return false;\n};\n/**\n * Destroys this tiling sprite\n *\n */\n\n\nTilingSprite.prototype.destroy = function () {\n  core.Sprite.prototype.destroy.call(this);\n  this.tileScale = null;\n  this._tileScaleOffset = null;\n  this.tilePosition = null;\n  this._uvs = null;\n};\n/**\n * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @static\n * @param frameId {String} The frame Id of the texture in the cache\n * @return {TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n * @param width {number}  the width of the tiling sprite\n * @param height {number} the height of the tiling sprite\n */\n\n\nTilingSprite.fromFrame = function (frameId, width, height) {\n  var texture = core.utils.TextureCache[frameId];\n\n  if (!texture) {\n    throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache ' + this);\n  }\n\n  return new TilingSprite(texture, width, height);\n};\n/**\n * Helper function that creates a sprite that will contain a texture based on an image url\n * If the image is not in the texture cache it will be loaded\n *\n * @static\n * @param imageId {String} The image url of the texture\n * @param width {number}  the width of the tiling sprite\n * @param height {number} the height of the tiling sprite\n * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter\n * @param [scaleMode=scaleModes.DEFAULT] {number} if you want to specify the scale mode, see {@link SCALE_MODES} for possible values\n * @return {TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n */\n\n\nTilingSprite.fromImage = function (imageId, width, height, crossorigin, scaleMode) {\n  return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode), width, height);\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/extras/TilingSprite.js"],"names":["core","require","tempPoint","Point","TilingSprite","texture","width","height","Sprite","call","tileScale","tilePosition","_width","_height","_uvs","TextureUvs","_canvasPattern","shader","AbstractFilter","join","uFrame","type","value","uTransform","uPixelSize","prototype","Object","create","constructor","module","exports","defineProperties","get","set","_onTextureUpdate","_renderWebGL","renderer","_texture","tempUvs","tempWidth","_frame","tempHeight","tw","baseTexture","th","uniforms","x0","y0","x1","y2","x","y","setObjectRenderer","plugins","sprite","render","_renderCanvas","hasLoaded","context","transform","worldTransform","resolution","modX","modY","tempCanvas","CanvasBuffer","drawImage","source","createPattern","canvas","globalAlpha","worldAlpha","setTransform","a","b","c","d","tx","ty","scale","translate","anchor","blendMode","currentBlendMode","globalCompositeOperation","blendModes","fillStyle","fillRect","getBounds","w0","w1","h0","h1","y1","x2","x3","y3","x4","y4","minX","maxX","minY","maxY","bounds","_bounds","_currentBounds","containsPoint","point","applyInverse","destroy","_tileScaleOffset","fromFrame","frameId","utils","TextureCache","Error","fromImage","imageId","crossorigin","scaleMode","Texture"],"mappings":"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","sourcesContent":["var core = require('../core'),\n    // a sprite use dfor rendering textures..\n    tempPoint = new core.Point();\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image\n *\n * @class\n * @extends PIXI.Sprite\n * @memberof PIXI.extras\n * @param texture {Texture} the texture of the tiling sprite\n * @param width {number}  the width of the tiling sprite\n * @param height {number} the height of the tiling sprite\n */\nfunction TilingSprite(texture, width, height)\n{\n    core.Sprite.call(this, texture);\n\n    /**\n     * The scaling of the image that is being tiled\n     *\n     * @member {Point}\n     */\n    this.tileScale = new core.Point(1,1);\n\n\n    /**\n     * The offset position of the image that is being tiled\n     *\n     * @member {Point}\n     */\n    this.tilePosition = new core.Point(0,0);\n\n    ///// private\n\n    /**\n     * The with of the tiling sprite\n     *\n     * @member {number}\n     * @private\n     */\n    this._width = width || 100;\n\n    /**\n     * The height of the tiling sprite\n     *\n     * @member {number}\n     * @private\n     */\n    this._height = height || 100;\n\n    /**\n     * An internal WebGL UV cache.\n     *\n     * @member {TextureUvs}\n     * @private\n     */\n    this._uvs = new core.TextureUvs();\n\n    this._canvasPattern = null;\n\n    //TODO move..\n    this.shader = new core.AbstractFilter(\n\n      [\n        'precision lowp float;',\n        'attribute vec2 aVertexPosition;',\n        'attribute vec2 aTextureCoord;',\n        'attribute vec4 aColor;',\n\n        'uniform mat3 projectionMatrix;',\n\n        'uniform vec4 uFrame;',\n        'uniform vec4 uTransform;',\n\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n\n        'void main(void){',\n        '   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);',\n\n        '   vec2 coord = aTextureCoord;',\n        '   coord -= uTransform.xy;',\n        '   coord /= uTransform.zw;',\n        '   vTextureCoord = coord;',\n\n        '   vColor = vec4(aColor.rgb * aColor.a, aColor.a);',\n        '}'\n      ].join('\\n'),\n      [\n        'precision lowp float;',\n\n        'varying vec2 vTextureCoord;',\n        'varying vec4 vColor;',\n\n        'uniform sampler2D uSampler;',\n        'uniform vec4 uFrame;',\n        'uniform vec2 uPixelSize;',\n\n        'void main(void){',\n\n        '   vec2 coord = mod(vTextureCoord, uFrame.zw);',\n        '   coord = clamp(coord, uPixelSize, uFrame.zw - uPixelSize);',\n        '   coord += uFrame.xy;',\n\n        '   gl_FragColor =  texture2D(uSampler, coord) * vColor ;',\n        '}'\n      ].join('\\n'),\n\n            // set the uniforms\n            {\n                uFrame: { type: '4fv', value: [0,0,1,1] },\n                uTransform: { type: '4fv', value: [0,0,1,1] },\n                uPixelSize : { type : '2fv', value: [1, 1]}\n            }\n      );\n}\n\nTilingSprite.prototype = Object.create(core.Sprite.prototype);\nTilingSprite.prototype.constructor = TilingSprite;\nmodule.exports = TilingSprite;\n\n\nObject.defineProperties(TilingSprite.prototype, {\n    /**\n     * The width of the sprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof TilingSprite#\n     */\n    width: {\n        get: function ()\n        {\n            return this._width;\n        },\n        set: function (value)\n        {\n            this._width = value;\n        }\n    },\n\n    /**\n     * The height of the TilingSprite, setting this will actually modify the scale to achieve the value set\n     *\n     * @member {number}\n     * @memberof TilingSprite#\n     */\n    height: {\n        get: function ()\n        {\n            return this._height;\n        },\n        set: function (value)\n        {\n            this._height = value;\n        }\n    }\n});\n\nTilingSprite.prototype._onTextureUpdate = function ()\n{\n    return;\n};\n\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n * @private\n */\nTilingSprite.prototype._renderWebGL = function (renderer)\n{\n    // tweak our texture temporarily..\n    var texture = this._texture;\n\n    if(!texture || !texture._uvs)\n    {\n        return;\n    }\n\n    var tempUvs = texture._uvs,\n        tempWidth = texture._frame.width,\n        tempHeight = texture._frame.height,\n        tw = texture.baseTexture.width,\n        th = texture.baseTexture.height;\n\n    texture._uvs = this._uvs;\n    texture._frame.width = this.width;\n    texture._frame.height = this.height;\n\n    this.shader.uniforms.uPixelSize.value[0] = 1.0/tw;\n    this.shader.uniforms.uPixelSize.value[1] = 1.0/th;\n\n    this.shader.uniforms.uFrame.value[0] = tempUvs.x0;\n    this.shader.uniforms.uFrame.value[1] = tempUvs.y0;\n    this.shader.uniforms.uFrame.value[2] = tempUvs.x1 - tempUvs.x0;\n    this.shader.uniforms.uFrame.value[3] = tempUvs.y2 - tempUvs.y0;\n\n    this.shader.uniforms.uTransform.value[0] = (this.tilePosition.x % (tempWidth * this.tileScale.x)) / this._width;\n    this.shader.uniforms.uTransform.value[1] = (this.tilePosition.y % (tempHeight * this.tileScale.y)) / this._height;\n    this.shader.uniforms.uTransform.value[2] = ( tw / this._width ) * this.tileScale.x;\n    this.shader.uniforms.uTransform.value[3] = ( th / this._height ) * this.tileScale.y;\n\n    renderer.setObjectRenderer(renderer.plugins.sprite);\n    renderer.plugins.sprite.render(this);\n\n    texture._uvs = tempUvs;\n    texture._frame.width = tempWidth;\n    texture._frame.height = tempHeight;\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer} a reference to the canvas renderer\n * @private\n */\nTilingSprite.prototype._renderCanvas = function (renderer)\n{\n    var texture = this._texture;\n\n    if (!texture.baseTexture.hasLoaded)\n    {\n      return;\n    }\n\n    var context = renderer.context,\n        transform = this.worldTransform,\n        resolution = renderer.resolution,\n        baseTexture = texture.baseTexture,\n        modX = this.tilePosition.x % (texture._frame.width * this.tileScale.x),\n        modY = this.tilePosition.y % (texture._frame.height * this.tileScale.y);\n\n    // create a nice shiny pattern!\n    // TODO this needs to be refreshed if texture changes..\n    if(!this._canvasPattern)\n    {\n        // cut an object from a spritesheet..\n        var tempCanvas = new core.CanvasBuffer(texture._frame.width, texture._frame.height);\n        tempCanvas.context.drawImage(baseTexture.source, -texture._frame.x,-texture._frame.y);\n        this._canvasPattern = tempCanvas.context.createPattern( tempCanvas.canvas, 'repeat' );\n    }\n\n    // set context state..\n    context.globalAlpha = this.worldAlpha;\n    context.setTransform(transform.a * resolution,\n                       transform.b * resolution,\n                       transform.c * resolution,\n                       transform.d * resolution,\n                       transform.tx * resolution,\n                       transform.ty * resolution);\n\n    // TODO - this should be rolled into the setTransform above..\n    context.scale(this.tileScale.x,this.tileScale.y);\n\n\n    context.translate(modX + (this.anchor.x * -this._width ),\n                      modY + (this.anchor.y * -this._height));\n\n    // check blend mode\n    if (this.blendMode !== renderer.currentBlendMode)\n    {\n        renderer.currentBlendMode = this.blendMode;\n        context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];\n    }\n\n    // fill the pattern!\n    context.fillStyle = this._canvasPattern;\n    context.fillRect(-modX,\n                     -modY,\n                     this._width / this.tileScale.x,\n                     this._height / this.tileScale.y);\n\n\n    //TODO - pretty sure this can be deleted...\n    //context.translate(-this.tilePosition.x + (this.anchor.x * this._width), -this.tilePosition.y + (this.anchor.y * this._height));\n    //context.scale(1 / this.tileScale.x, 1 / this.tileScale.y);\n};\n\n\n/**\n * Returns the framing rectangle of the sprite as a Rectangle object\n*\n * @return {Rectangle} the framing rectangle\n */\nTilingSprite.prototype.getBounds = function ()\n{\n    var width = this._width;\n    var height = this._height;\n\n    var w0 = width * (1-this.anchor.x);\n    var w1 = width * -this.anchor.x;\n\n    var h0 = height * (1-this.anchor.y);\n    var h1 = height * -this.anchor.y;\n\n    var worldTransform = this.worldTransform;\n\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n\n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n\n    var x4 =  a * w1 + c * h0 + tx;\n    var y4 =  d * h0 + b * w1 + ty;\n\n    var minX,\n        maxX,\n        minY,\n        maxY;\n\n    minX = x1;\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n\n    minY = y1;\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n\n    maxX = x1;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n\n    maxY = y1;\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n\n    var bounds = this._bounds;\n\n    bounds.x = minX;\n    bounds.width = maxX - minX;\n\n    bounds.y = minY;\n    bounds.height = maxY - minY;\n\n    // store a reference so that if this function gets called again in the render cycle we do not have to recalculate\n    this._currentBounds = bounds;\n\n    return bounds;\n};\n\n/**\n * Checks if a point is inside this tiling sprite\n * @param point {Point} the point to check\n */\nTilingSprite.prototype.containsPoint = function( point )\n{\n    this.worldTransform.applyInverse(point,  tempPoint);\n\n    var width = this._width;\n    var height = this._height;\n    var x1 = -width * this.anchor.x;\n    var y1;\n\n    if ( tempPoint.x > x1 && tempPoint.x < x1 + width )\n    {\n        y1 = -height * this.anchor.y;\n\n        if ( tempPoint.y > y1 && tempPoint.y < y1 + height )\n        {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n/**\n * Destroys this tiling sprite\n *\n */\nTilingSprite.prototype.destroy = function () {\n    core.Sprite.prototype.destroy.call(this);\n\n    this.tileScale = null;\n    this._tileScaleOffset = null;\n    this.tilePosition = null;\n\n    this._uvs = null;\n};\n\n/**\n * Helper function that creates a tiling sprite that will use a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @static\n * @param frameId {String} The frame Id of the texture in the cache\n * @return {TilingSprite} A new TilingSprite using a texture from the texture cache matching the frameId\n * @param width {number}  the width of the tiling sprite\n * @param height {number} the height of the tiling sprite\n */\nTilingSprite.fromFrame = function (frameId,width,height)\n{\n    var texture = core.utils.TextureCache[frameId];\n\n    if (!texture)\n    {\n        throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache ' + this);\n    }\n\n    return new TilingSprite(texture,width,height);\n};\n\n/**\n * Helper function that creates a sprite that will contain a texture based on an image url\n * If the image is not in the texture cache it will be loaded\n *\n * @static\n * @param imageId {String} The image url of the texture\n * @param width {number}  the width of the tiling sprite\n * @param height {number} the height of the tiling sprite\n * @param [crossorigin=(auto)] {boolean} if you want to specify the cross-origin parameter\n * @param [scaleMode=scaleModes.DEFAULT] {number} if you want to specify the scale mode, see {@link SCALE_MODES} for possible values\n * @return {TilingSprite} A new TilingSprite using a texture from the texture cache matching the image id\n */\nTilingSprite.fromImage = function (imageId, width, height, crossorigin, scaleMode)\n{\n    return new TilingSprite(core.Texture.fromImage(imageId, crossorigin, scaleMode),width,height);\n};\n"]},"metadata":{},"sourceType":"script"}