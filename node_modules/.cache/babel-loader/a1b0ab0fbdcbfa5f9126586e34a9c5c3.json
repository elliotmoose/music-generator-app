{"ast":null,"code":"var DefaultShader = require('../shaders/TextureShader');\n/**\n * This is the base class for creating a PIXI filter. Currently only WebGL supports filters.\n * If you want to make a custom filter this should be your base class.\n *\n * @class\n * @memberof PIXI\n * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.\n * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.\n * @param uniforms {object} An object containing the uniforms for this filter.\n */\n\n\nfunction AbstractFilter(vertexSrc, fragmentSrc, uniforms) {\n  /**\n   * An array of shaders\n   * @member {Shader[]}\n   * @private\n   */\n  this.shaders = [];\n  /**\n   * The extra padding that the filter might need\n   * @member {number}\n   */\n\n  this.padding = 0;\n  /**\n   * The uniforms as an object\n   * @member {object}\n   */\n\n  this.uniforms = uniforms || {};\n  /**\n   * The code of the vertex shader\n   * @member {string[]}\n   * @private\n   */\n\n  this.vertexSrc = vertexSrc || DefaultShader.defaultVertexSrc;\n  /**\n   * The code of the frament shader\n   * @member {string[]}\n   * @private\n   */\n\n  this.fragmentSrc = fragmentSrc || DefaultShader.defaultFragmentSrc; //TODO a reminder - would be cool to have lower res filters as this would give better performance.\n  //typeof fragmentSrc === 'string' ? fragmentSrc.split('') : (fragmentSrc || []);\n}\n\nAbstractFilter.prototype.constructor = AbstractFilter;\nmodule.exports = AbstractFilter;\n/*\n * Grabs a shader from the current renderer\n * @param renderer {WebGLRenderer} The renderer to retrieve the shader from\n *\n */\n\nAbstractFilter.prototype.getShader = function (renderer) {\n  var gl = renderer.gl;\n  var shader = this.shaders[gl.id];\n\n  if (!shader) {\n    shader = new DefaultShader(renderer.shaderManager, this.vertexSrc, this.fragmentSrc, this.uniforms, this.attributes);\n    this.shaders[gl.id] = shader;\n  }\n\n  return shader;\n};\n/*\n * Applies the filter\n * @param renderer {WebGLRenderer} The renderer to retrieve the filter from\n * @param input {RenderTarget}\n * @param output {RenderTarget}\n * @param clear {boolean} Whether or not we want to clear the outputTarget\n */\n\n\nAbstractFilter.prototype.applyFilter = function (renderer, input, output, clear) {\n  var shader = this.getShader(renderer);\n  renderer.filterManager.applyFilter(shader, input, output, clear);\n};\n/**\n * Syncs a uniform between the class object and the shaders.\n *\n */\n\n\nAbstractFilter.prototype.syncUniform = function (uniform) {\n  for (var i = 0, j = this.shaders.length; i < j; ++i) {\n    this.shaders[i].syncUniform(uniform);\n  }\n};\n/*\nAbstractFilter.prototype.apply = function (frameBuffer)\n{\n    // TODO :)\n};\n*/","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/renderers/webgl/filters/AbstractFilter.js"],"names":["DefaultShader","require","AbstractFilter","vertexSrc","fragmentSrc","uniforms","shaders","padding","defaultVertexSrc","defaultFragmentSrc","prototype","constructor","module","exports","getShader","renderer","gl","shader","id","shaderManager","attributes","applyFilter","input","output","clear","filterManager","syncUniform","uniform","i","j","length"],"mappings":"AAAA,IAAIA,aAAa,GAAGC,OAAO,CAAC,0BAAD,CAA3B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASC,cAAT,CAAwBC,SAAxB,EAAmCC,WAAnC,EAAgDC,QAAhD,EACA;AAEI;AACJ;AACA;AACA;AACA;AACI,OAAKC,OAAL,GAAe,EAAf;AAEA;AACJ;AACA;AACA;;AACI,OAAKC,OAAL,GAAe,CAAf;AAEA;AACJ;AACA;AACA;;AACI,OAAKF,QAAL,GAAgBA,QAAQ,IAAI,EAA5B;AAGA;AACJ;AACA;AACA;AACA;;AACI,OAAKF,SAAL,GAAiBA,SAAS,IAAIH,aAAa,CAACQ,gBAA5C;AAEA;AACJ;AACA;AACA;AACA;;AACI,OAAKJ,WAAL,GAAmBA,WAAW,IAAIJ,aAAa,CAACS,kBAAhD,CAlCJ,CAoCI;AAEA;AAEH;;AAEDP,cAAc,CAACQ,SAAf,CAAyBC,WAAzB,GAAuCT,cAAvC;AACAU,MAAM,CAACC,OAAP,GAAiBX,cAAjB;AAEA;AACA;AACA;AACA;AACA;;AACAA,cAAc,CAACQ,SAAf,CAAyBI,SAAzB,GAAqC,UAAUC,QAAV,EACrC;AACI,MAAIC,EAAE,GAAGD,QAAQ,CAACC,EAAlB;AAEA,MAAIC,MAAM,GAAG,KAAKX,OAAL,CAAaU,EAAE,CAACE,EAAhB,CAAb;;AAEA,MAAI,CAACD,MAAL,EACA;AACIA,IAAAA,MAAM,GAAG,IAAIjB,aAAJ,CAAkBe,QAAQ,CAACI,aAA3B,EACL,KAAKhB,SADA,EAEL,KAAKC,WAFA,EAGL,KAAKC,QAHA,EAIL,KAAKe,UAJA,CAAT;AAOA,SAAKd,OAAL,CAAaU,EAAE,CAACE,EAAhB,IAAsBD,MAAtB;AACH;;AAED,SAAOA,MAAP;AACH,CAnBD;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAf,cAAc,CAACQ,SAAf,CAAyBW,WAAzB,GAAuC,UAAUN,QAAV,EAAoBO,KAApB,EAA2BC,MAA3B,EAAmCC,KAAnC,EACvC;AACI,MAAIP,MAAM,GAAG,KAAKH,SAAL,CAAeC,QAAf,CAAb;AAEAA,EAAAA,QAAQ,CAACU,aAAT,CAAuBJ,WAAvB,CAAmCJ,MAAnC,EAA2CK,KAA3C,EAAkDC,MAAlD,EAA0DC,KAA1D;AACH,CALD;AAOA;AACA;AACA;AACA;;;AACAtB,cAAc,CAACQ,SAAf,CAAyBgB,WAAzB,GAAuC,UAAUC,OAAV,EACvC;AACI,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,CAAC,GAAG,KAAKvB,OAAL,CAAawB,MAAjC,EAAyCF,CAAC,GAAGC,CAA7C,EAAgD,EAAED,CAAlD,EACA;AACI,SAAKtB,OAAL,CAAasB,CAAb,EAAgBF,WAAhB,CAA4BC,OAA5B;AACH;AACJ,CAND;AAQA;AACA;AACA;AACA;AACA;AACA","sourcesContent":["var DefaultShader = require('../shaders/TextureShader');\n\n/**\n * This is the base class for creating a PIXI filter. Currently only WebGL supports filters.\n * If you want to make a custom filter this should be your base class.\n *\n * @class\n * @memberof PIXI\n * @param vertexSrc {string|string[]} The vertex shader source as an array of strings.\n * @param fragmentSrc {string|string[]} The fragment shader source as an array of strings.\n * @param uniforms {object} An object containing the uniforms for this filter.\n */\nfunction AbstractFilter(vertexSrc, fragmentSrc, uniforms)\n{\n\n    /**\n     * An array of shaders\n     * @member {Shader[]}\n     * @private\n     */\n    this.shaders = [];\n\n    /**\n     * The extra padding that the filter might need\n     * @member {number}\n     */\n    this.padding = 0;\n\n    /**\n     * The uniforms as an object\n     * @member {object}\n     */\n    this.uniforms = uniforms || {};\n\n\n    /**\n     * The code of the vertex shader\n     * @member {string[]}\n     * @private\n     */\n    this.vertexSrc = vertexSrc || DefaultShader.defaultVertexSrc;\n\n    /**\n     * The code of the frament shader\n     * @member {string[]}\n     * @private\n     */\n    this.fragmentSrc = fragmentSrc || DefaultShader.defaultFragmentSrc;\n\n    //TODO a reminder - would be cool to have lower res filters as this would give better performance.\n\n    //typeof fragmentSrc === 'string' ? fragmentSrc.split('') : (fragmentSrc || []);\n\n}\n\nAbstractFilter.prototype.constructor = AbstractFilter;\nmodule.exports = AbstractFilter;\n\n/*\n * Grabs a shader from the current renderer\n * @param renderer {WebGLRenderer} The renderer to retrieve the shader from\n *\n */\nAbstractFilter.prototype.getShader = function (renderer)\n{\n    var gl = renderer.gl;\n\n    var shader = this.shaders[gl.id];\n\n    if (!shader)\n    {\n        shader = new DefaultShader(renderer.shaderManager,\n            this.vertexSrc,\n            this.fragmentSrc,\n            this.uniforms,\n            this.attributes\n        );\n\n        this.shaders[gl.id] = shader;\n    }\n\n    return shader;\n};\n\n/*\n * Applies the filter\n * @param renderer {WebGLRenderer} The renderer to retrieve the filter from\n * @param input {RenderTarget}\n * @param output {RenderTarget}\n * @param clear {boolean} Whether or not we want to clear the outputTarget\n */\nAbstractFilter.prototype.applyFilter = function (renderer, input, output, clear)\n{\n    var shader = this.getShader(renderer);\n\n    renderer.filterManager.applyFilter(shader, input, output, clear);\n};\n\n/**\n * Syncs a uniform between the class object and the shaders.\n *\n */\nAbstractFilter.prototype.syncUniform = function (uniform)\n{\n    for (var i = 0, j = this.shaders.length; i < j; ++i)\n    {\n        this.shaders[i].syncUniform(uniform);\n    }\n};\n\n/*\nAbstractFilter.prototype.apply = function (frameBuffer)\n{\n    // TODO :)\n};\n*/\n"]},"metadata":{},"sourceType":"script"}