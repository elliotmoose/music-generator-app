{"ast":null,"code":"var WebGLManager = require('./WebGLManager'),\n    RenderTarget = require('../utils/RenderTarget'),\n    CONST = require('../../../const'),\n    Quad = require('../utils/Quad'),\n    math = require('../../../math');\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.WebGLManager\n * @param renderer {WebGLRenderer} The renderer this manager works for.\n */\n\n\nfunction FilterManager(renderer) {\n  WebGLManager.call(this, renderer);\n  /**\n   * @member {any[]}\n   */\n\n  this.filterStack = [];\n  this.filterStack.push({\n    renderTarget: renderer.currentRenderTarget,\n    filter: [],\n    bounds: null\n  });\n  /**\n   * @member {any[]}\n   */\n\n  this.texturePool = []; // listen for context and update necessary buffers\n  //TODO make this dynamic!\n  //TODO test this out by forces power of two?\n\n  this.textureSize = new math.Rectangle(0, 0, renderer.width, renderer.height);\n  this.currentFrame = null;\n}\n\nFilterManager.prototype = Object.create(WebGLManager.prototype);\nFilterManager.prototype.constructor = FilterManager;\nmodule.exports = FilterManager;\n/**\n * Called when there is a WebGL context change.\n *\n */\n\nFilterManager.prototype.onContextChange = function () {\n  this.texturePool.length = 0;\n  var gl = this.renderer.gl;\n  this.quad = new Quad(gl);\n};\n/**\n * @param renderer {WebGLRenderer}\n * @param buffer {ArrayBuffer}\n */\n\n\nFilterManager.prototype.setFilterStack = function (filterStack) {\n  this.filterStack = filterStack;\n};\n/**\n * Applies the filter and adds it to the current filter stack.\n *\n * @param filterBlock {object} the filter that will be pushed to the current filter stack\n */\n\n\nFilterManager.prototype.pushFilter = function (target, filters) {\n  // get the bounds of the object..\n  // TODO replace clone with a copy to save object creation\n  var bounds = target.filterArea ? target.filterArea.clone() : target.getBounds(); //bounds = bounds.clone();\n  // round off the rectangle to get a nice smoooooooth filter :)\n\n  bounds.x = bounds.x | 0;\n  bounds.y = bounds.y | 0;\n  bounds.width = bounds.width | 0;\n  bounds.height = bounds.height | 0; // padding!\n\n  var padding = filters[0].padding | 0;\n  bounds.x -= padding;\n  bounds.y -= padding;\n  bounds.width += padding * 2;\n  bounds.height += padding * 2;\n\n  if (this.renderer.currentRenderTarget.transform) {\n    //TODO this will break if the renderTexture transform is anything other than a translation.\n    //Will need to take the full matrix transform into acount..\n    var transform = this.renderer.currentRenderTarget.transform;\n    bounds.x += transform.tx;\n    bounds.y += transform.ty;\n    this.capFilterArea(bounds);\n    bounds.x -= transform.tx;\n    bounds.y -= transform.ty;\n  } else {\n    this.capFilterArea(bounds);\n  }\n\n  if (bounds.width > 0 && bounds.height > 0) {\n    this.currentFrame = bounds;\n    var texture = this.getRenderTarget();\n    this.renderer.setRenderTarget(texture); // clear the texture..\n\n    texture.clear(); // TODO get rid of object creation!\n\n    this.filterStack.push({\n      renderTarget: texture,\n      filter: filters\n    });\n  } else {\n    // push somthing on to the stack that is empty\n    this.filterStack.push({\n      renderTarget: null,\n      filter: filters\n    });\n  }\n};\n/**\n * Removes the last filter from the filter stack and returns it.\n *\n */\n\n\nFilterManager.prototype.popFilter = function () {\n  var filterData = this.filterStack.pop();\n  var previousFilterData = this.filterStack[this.filterStack.length - 1];\n  var input = filterData.renderTarget; // if the renderTarget is null then we don't apply the filter as its offscreen\n\n  if (!filterData.renderTarget) {\n    return;\n  }\n\n  var output = previousFilterData.renderTarget; // use program\n\n  var gl = this.renderer.gl;\n  this.currentFrame = input.frame;\n  this.quad.map(this.textureSize, input.frame); // TODO.. this probably only needs to be done once!\n\n  gl.bindBuffer(gl.ARRAY_BUFFER, this.quad.vertexBuffer);\n  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.quad.indexBuffer);\n  var filters = filterData.filter; // assuming all filters follow the correct format??\n\n  gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n  gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);\n  gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4); // restore the normal blendmode!\n\n  this.renderer.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);\n\n  if (filters.length === 1) {\n    // TODO (cengler) - There has to be a better way then setting this each time?\n    if (filters[0].uniforms.dimensions) {\n      filters[0].uniforms.dimensions.value[0] = this.renderer.width;\n      filters[0].uniforms.dimensions.value[1] = this.renderer.height;\n      filters[0].uniforms.dimensions.value[2] = this.quad.vertices[0];\n      filters[0].uniforms.dimensions.value[3] = this.quad.vertices[5];\n    }\n\n    filters[0].applyFilter(this.renderer, input, output);\n    this.returnRenderTarget(input);\n  } else {\n    var flipTexture = input;\n    var flopTexture = this.getRenderTarget(true);\n\n    for (var i = 0; i < filters.length - 1; i++) {\n      var filter = filters[i]; // TODO (cengler) - There has to be a better way then setting this each time?\n\n      if (filter.uniforms.dimensions) {\n        filter.uniforms.dimensions.value[0] = this.renderer.width;\n        filter.uniforms.dimensions.value[1] = this.renderer.height;\n        filter.uniforms.dimensions.value[2] = this.quad.vertices[0];\n        filter.uniforms.dimensions.value[3] = this.quad.vertices[5];\n      }\n\n      filter.applyFilter(this.renderer, flipTexture, flopTexture);\n      var temp = flipTexture;\n      flipTexture = flopTexture;\n      flopTexture = temp;\n    }\n\n    filters[filters.length - 1].applyFilter(this.renderer, flipTexture, output);\n    this.returnRenderTarget(flipTexture);\n    this.returnRenderTarget(flopTexture);\n  }\n\n  return filterData.filter;\n};\n/**\n * Grabs an render target from the internal pool\n *\n * @param clear {boolean} Whether or not we need to clear the RenderTarget\n * @return {RenderTarget}\n */\n\n\nFilterManager.prototype.getRenderTarget = function (clear) {\n  var renderTarget = this.texturePool.pop() || new RenderTarget(this.renderer.gl, this.textureSize.width, this.textureSize.height, CONST.SCALE_MODES.LINEAR, this.renderer.resolution * CONST.FILTER_RESOLUTION);\n  renderTarget.frame = this.currentFrame;\n\n  if (clear) {\n    renderTarget.clear(true);\n  }\n\n  return renderTarget;\n};\n/*\n * Returns a RenderTarget to the internal pool\n * @param renderTarget {RenderTarget} The RenderTarget we want to return to the pool\n */\n\n\nFilterManager.prototype.returnRenderTarget = function (renderTarget) {\n  this.texturePool.push(renderTarget);\n};\n/*\n * Applies the filter\n * @param shader {Shader} The shader to upload\n * @param inputTarget {RenderTarget}\n * @param outputTarget {RenderTarget}\n * @param clear {boolean} Whether or not we want to clear the outputTarget\n */\n\n\nFilterManager.prototype.applyFilter = function (shader, inputTarget, outputTarget, clear) {\n  var gl = this.renderer.gl;\n  this.renderer.setRenderTarget(outputTarget);\n\n  if (clear) {\n    outputTarget.clear();\n  } // set the shader\n\n\n  this.renderer.shaderManager.setShader(shader); // TODO (cengler) - Can this be cached and not `toArray`ed each frame?\n\n  shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true); //TODO can this be optimised?\n\n  shader.syncUniforms();\n  /*\n      gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n      gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);\n      gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);\n  */\n\n  gl.activeTexture(gl.TEXTURE0);\n  gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);\n  gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n};\n/*\n * Calculates the mapped matrix\n * @param filterArea {Rectangle} The filter area\n * @param sprite {Sprite} the target sprite\n * @param outputMatrix {Matrix} @alvin\n */\n// TODO playing around here.. this is temporary - (will end up in the shader)\n\n\nFilterManager.prototype.calculateMappedMatrix = function (filterArea, sprite, outputMatrix) {\n  var worldTransform = sprite.worldTransform.copy(math.Matrix.TEMP_MATRIX),\n      texture = sprite._texture.baseTexture;\n  var mappedMatrix = outputMatrix.identity(); // scale..\n\n  var ratio = this.textureSize.height / this.textureSize.width;\n  mappedMatrix.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height);\n  mappedMatrix.scale(1, ratio);\n  var translateScaleX = this.textureSize.width / texture.width;\n  var translateScaleY = this.textureSize.height / texture.height;\n  worldTransform.tx /= texture.width * translateScaleX;\n  worldTransform.ty /= texture.width * translateScaleX;\n  worldTransform.invert();\n  mappedMatrix.prepend(worldTransform); // apply inverse scale..\n\n  mappedMatrix.scale(1, 1 / ratio);\n  mappedMatrix.scale(translateScaleX, translateScaleY);\n  mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n  return mappedMatrix; // Keeping the orginal as a reminder to me on how this works!\n  //\n  // var m = new math.Matrix();\n  // // scale..\n  // var ratio = this.textureSize.height / this.textureSize.width;\n  // m.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height);\n  // m.scale(1 , ratio);\n  // var transform = wt.clone();\n  // var translateScaleX = (this.textureSize.width / 620);\n  // var translateScaleY = (this.textureSize.height / 380);\n  // transform.tx /= 620 * translateScaleX;\n  // transform.ty /= 620 * translateScaleX;\n  // transform.invert();\n  // transform.append(m);\n  // // apply inverse scale..\n  // transform.scale(1 , 1/ratio);\n  // transform.scale( translateScaleX , translateScaleY );\n  // return transform;\n};\n/*\n * Constrains the filter area to the texture size\n * @param filterArea {Rectangle} The filter area we want to cap\n */\n\n\nFilterManager.prototype.capFilterArea = function (filterArea) {\n  if (filterArea.x < 0) {\n    filterArea.width += filterArea.x;\n    filterArea.x = 0;\n  }\n\n  if (filterArea.y < 0) {\n    filterArea.height += filterArea.y;\n    filterArea.y = 0;\n  }\n\n  if (filterArea.x + filterArea.width > this.textureSize.width) {\n    filterArea.width = this.textureSize.width - filterArea.x;\n  }\n\n  if (filterArea.y + filterArea.height > this.textureSize.height) {\n    filterArea.height = this.textureSize.height - filterArea.y;\n  }\n};\n/*\n * Resizes all the render targets in the pool\n * @param width {number} the new width\n * @param height {number} the new height\n */\n\n\nFilterManager.prototype.resize = function (width, height) {\n  this.textureSize.width = width;\n  this.textureSize.height = height;\n\n  for (var i = 0; i < this.texturePool.length; i++) {\n    this.texturePool[i].resize(width, height);\n  }\n};\n/**\n * Destroys the filter and removes it from the filter stack.\n *\n */\n\n\nFilterManager.prototype.destroy = function () {\n  this.filterStack = null;\n  this.offsetY = 0; // destroy textures\n\n  for (var i = 0; i < this.texturePool.length; i++) {\n    this.texturePool[i].destroy();\n  }\n\n  this.texturePool = null;\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/renderers/webgl/managers/FilterManager.js"],"names":["WebGLManager","require","RenderTarget","CONST","Quad","math","FilterManager","renderer","call","filterStack","push","renderTarget","currentRenderTarget","filter","bounds","texturePool","textureSize","Rectangle","width","height","currentFrame","prototype","Object","create","constructor","module","exports","onContextChange","length","gl","quad","setFilterStack","pushFilter","target","filters","filterArea","clone","getBounds","x","y","padding","transform","tx","ty","capFilterArea","texture","getRenderTarget","setRenderTarget","clear","popFilter","filterData","pop","previousFilterData","input","output","frame","map","bindBuffer","ARRAY_BUFFER","vertexBuffer","ELEMENT_ARRAY_BUFFER","indexBuffer","vertexAttribPointer","shaderManager","defaultShader","attributes","aVertexPosition","FLOAT","aTextureCoord","aColor","blendModeManager","setBlendMode","BLEND_MODES","NORMAL","uniforms","dimensions","value","vertices","applyFilter","returnRenderTarget","flipTexture","flopTexture","i","temp","SCALE_MODES","LINEAR","resolution","FILTER_RESOLUTION","shader","inputTarget","outputTarget","setShader","projectionMatrix","toArray","syncUniforms","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","drawElements","TRIANGLES","UNSIGNED_SHORT","calculateMappedMatrix","sprite","outputMatrix","worldTransform","copy","Matrix","TEMP_MATRIX","_texture","baseTexture","mappedMatrix","identity","ratio","translate","scale","translateScaleX","translateScaleY","invert","prepend","anchor","resize","destroy","offsetY"],"mappings":"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","sourcesContent":["var WebGLManager = require('./WebGLManager'),\n    RenderTarget = require('../utils/RenderTarget'),\n    CONST = require('../../../const'),\n    Quad = require('../utils/Quad'),\n    math =  require('../../../math');\n\n/**\n * @class\n * @memberof PIXI\n * @extends PIXI.WebGLManager\n * @param renderer {WebGLRenderer} The renderer this manager works for.\n */\nfunction FilterManager(renderer)\n{\n    WebGLManager.call(this, renderer);\n\n    /**\n     * @member {any[]}\n     */\n    this.filterStack = [];\n\n    this.filterStack.push({\n        renderTarget:renderer.currentRenderTarget,\n        filter:[],\n        bounds:null\n    });\n\n    /**\n     * @member {any[]}\n     */\n    this.texturePool = [];\n\n    // listen for context and update necessary buffers\n    //TODO make this dynamic!\n    //TODO test this out by forces power of two?\n    this.textureSize = new math.Rectangle( 0, 0, renderer.width, renderer.height );\n\n    this.currentFrame = null;\n}\n\nFilterManager.prototype = Object.create(WebGLManager.prototype);\nFilterManager.prototype.constructor = FilterManager;\nmodule.exports = FilterManager;\n\n\n/**\n * Called when there is a WebGL context change.\n *\n */\nFilterManager.prototype.onContextChange = function ()\n{\n    this.texturePool.length = 0;\n\n    var gl = this.renderer.gl;\n    this.quad = new Quad(gl);\n};\n\n/**\n * @param renderer {WebGLRenderer}\n * @param buffer {ArrayBuffer}\n */\nFilterManager.prototype.setFilterStack = function ( filterStack )\n{\n    this.filterStack = filterStack;\n};\n\n/**\n * Applies the filter and adds it to the current filter stack.\n *\n * @param filterBlock {object} the filter that will be pushed to the current filter stack\n */\nFilterManager.prototype.pushFilter = function (target, filters)\n{\n    // get the bounds of the object..\n    // TODO replace clone with a copy to save object creation\n    var bounds = target.filterArea ? target.filterArea.clone() : target.getBounds();\n    \n    //bounds = bounds.clone();\n\n    // round off the rectangle to get a nice smoooooooth filter :)\n    bounds.x = bounds.x | 0;\n    bounds.y = bounds.y | 0;\n    bounds.width = bounds.width | 0;\n    bounds.height = bounds.height | 0;\n\n\n    // padding!\n    var padding = filters[0].padding | 0;\n    bounds.x -= padding;\n    bounds.y -= padding;\n    bounds.width += padding * 2;\n    bounds.height += padding * 2;\n\n\n    if(this.renderer.currentRenderTarget.transform)\n    {\n        //TODO this will break if the renderTexture transform is anything other than a translation.\n        //Will need to take the full matrix transform into acount..\n        var transform = this.renderer.currentRenderTarget.transform;\n\n        bounds.x += transform.tx;\n        bounds.y += transform.ty;\n\n        this.capFilterArea( bounds );\n\n        bounds.x -= transform.tx;\n        bounds.y -= transform.ty;\n    }\n    else\n    {\n         this.capFilterArea( bounds );\n    }\n\n    if(bounds.width > 0 && bounds.height > 0)\n    {\n        this.currentFrame = bounds;\n\n        var texture = this.getRenderTarget();\n\n        this.renderer.setRenderTarget(texture);\n\n        // clear the texture..\n        texture.clear();\n\n        // TODO get rid of object creation!\n        this.filterStack.push({\n            renderTarget: texture,\n            filter: filters\n        });\n\n    }\n    else\n    {\n        // push somthing on to the stack that is empty\n        this.filterStack.push({\n            renderTarget: null,\n            filter: filters\n        });\n    }\n};\n\n\n/**\n * Removes the last filter from the filter stack and returns it.\n *\n */\nFilterManager.prototype.popFilter = function ()\n{\n    var filterData = this.filterStack.pop();\n    var previousFilterData = this.filterStack[this.filterStack.length-1];\n\n    var input = filterData.renderTarget;\n\n    // if the renderTarget is null then we don't apply the filter as its offscreen\n    if(!filterData.renderTarget)\n    {\n        return;\n    }\n\n    var output = previousFilterData.renderTarget;\n\n    // use program\n    var gl = this.renderer.gl;\n\n\n    this.currentFrame = input.frame;\n\n    this.quad.map(this.textureSize, input.frame);\n\n\n    // TODO.. this probably only needs to be done once!\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.quad.vertexBuffer);\n    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.quad.indexBuffer);\n\n    var filters = filterData.filter;\n\n    // assuming all filters follow the correct format??\n    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);\n    gl.vertexAttribPointer(this.renderer.shaderManager.defaultShader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);\n\n    // restore the normal blendmode!\n    this.renderer.blendModeManager.setBlendMode(CONST.BLEND_MODES.NORMAL);\n\n    if (filters.length === 1)\n    {\n        // TODO (cengler) - There has to be a better way then setting this each time?\n        if (filters[0].uniforms.dimensions)\n        {\n            filters[0].uniforms.dimensions.value[0] = this.renderer.width;\n            filters[0].uniforms.dimensions.value[1] = this.renderer.height;\n            filters[0].uniforms.dimensions.value[2] = this.quad.vertices[0];\n            filters[0].uniforms.dimensions.value[3] = this.quad.vertices[5];\n        }\n\n        filters[0].applyFilter( this.renderer, input, output );\n        this.returnRenderTarget( input );\n\n    }\n    else\n    {\n        var flipTexture = input;\n        var flopTexture = this.getRenderTarget(true);\n\n        for (var i = 0; i < filters.length-1; i++)\n        {\n            var filter = filters[i];\n\n            // TODO (cengler) - There has to be a better way then setting this each time?\n            if (filter.uniforms.dimensions)\n            {\n                filter.uniforms.dimensions.value[0] = this.renderer.width;\n                filter.uniforms.dimensions.value[1] = this.renderer.height;\n                filter.uniforms.dimensions.value[2] = this.quad.vertices[0];\n                filter.uniforms.dimensions.value[3] = this.quad.vertices[5];\n            }\n\n            filter.applyFilter( this.renderer, flipTexture, flopTexture );\n\n            var temp = flipTexture;\n            flipTexture = flopTexture;\n            flopTexture = temp;\n        }\n\n        filters[filters.length-1].applyFilter( this.renderer, flipTexture, output );\n\n        this.returnRenderTarget( flipTexture );\n        this.returnRenderTarget( flopTexture );\n    }\n\n    return filterData.filter;\n};\n\n/**\n * Grabs an render target from the internal pool\n *\n * @param clear {boolean} Whether or not we need to clear the RenderTarget\n * @return {RenderTarget}\n */\nFilterManager.prototype.getRenderTarget = function ( clear )\n{\n    var renderTarget = this.texturePool.pop() || new RenderTarget(this.renderer.gl, this.textureSize.width, this.textureSize.height, CONST.SCALE_MODES.LINEAR, this.renderer.resolution * CONST.FILTER_RESOLUTION);\n    renderTarget.frame = this.currentFrame;\n\n    if (clear)\n    {\n        renderTarget.clear(true);\n    }\n\n    return renderTarget;\n};\n\n/*\n * Returns a RenderTarget to the internal pool\n * @param renderTarget {RenderTarget} The RenderTarget we want to return to the pool\n */\nFilterManager.prototype.returnRenderTarget = function (renderTarget)\n{\n    this.texturePool.push( renderTarget );\n};\n\n/*\n * Applies the filter\n * @param shader {Shader} The shader to upload\n * @param inputTarget {RenderTarget}\n * @param outputTarget {RenderTarget}\n * @param clear {boolean} Whether or not we want to clear the outputTarget\n */\nFilterManager.prototype.applyFilter = function (shader, inputTarget, outputTarget, clear)\n{\n    var gl = this.renderer.gl;\n\n    this.renderer.setRenderTarget(outputTarget);\n\n    if (clear)\n    {\n        outputTarget.clear();\n    }\n\n    // set the shader\n    this.renderer.shaderManager.setShader(shader);\n\n    // TODO (cengler) - Can this be cached and not `toArray`ed each frame?\n    shader.uniforms.projectionMatrix.value = this.renderer.currentRenderTarget.projectionMatrix.toArray(true);\n\n    //TODO can this be optimised?\n    shader.syncUniforms();\n/*\n    gl.vertexAttribPointer(shader.attributes.aVertexPosition, 2, gl.FLOAT, false, 0, 0);\n    gl.vertexAttribPointer(shader.attributes.aTextureCoord, 2, gl.FLOAT, false, 0, 2 * 4 * 4);\n    gl.vertexAttribPointer(shader.attributes.aColor, 4, gl.FLOAT, false, 0, 4 * 4 * 4);\n*/\n\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, inputTarget.texture);\n\n    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\n};\n\n/*\n * Calculates the mapped matrix\n * @param filterArea {Rectangle} The filter area\n * @param sprite {Sprite} the target sprite\n * @param outputMatrix {Matrix} @alvin\n */\n// TODO playing around here.. this is temporary - (will end up in the shader)\nFilterManager.prototype.calculateMappedMatrix = function (filterArea, sprite, outputMatrix)\n{\n    var worldTransform = sprite.worldTransform.copy(math.Matrix.TEMP_MATRIX),\n    texture = sprite._texture.baseTexture;\n\n    var mappedMatrix = outputMatrix.identity();\n\n    // scale..\n    var ratio = this.textureSize.height / this.textureSize.width;\n\n    mappedMatrix.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height );\n\n    mappedMatrix.scale(1 , ratio);\n\n    var translateScaleX = (this.textureSize.width / texture.width);\n    var translateScaleY = (this.textureSize.height / texture.height);\n\n    worldTransform.tx /= texture.width * translateScaleX;\n    worldTransform.ty /= texture.width * translateScaleX;\n\n    worldTransform.invert();\n\n    mappedMatrix.prepend(worldTransform);\n\n    // apply inverse scale..\n    mappedMatrix.scale(1 , 1/ratio);\n\n    mappedMatrix.scale( translateScaleX , translateScaleY );\n\n    mappedMatrix.translate(sprite.anchor.x, sprite.anchor.y);\n\n    return mappedMatrix;\n\n    // Keeping the orginal as a reminder to me on how this works!\n    //\n    // var m = new math.Matrix();\n\n    // // scale..\n    // var ratio = this.textureSize.height / this.textureSize.width;\n\n    // m.translate(filterArea.x / this.textureSize.width, filterArea.y / this.textureSize.height);\n\n\n    // m.scale(1 , ratio);\n\n\n    // var transform = wt.clone();\n\n    // var translateScaleX = (this.textureSize.width / 620);\n    // var translateScaleY = (this.textureSize.height / 380);\n\n    // transform.tx /= 620 * translateScaleX;\n    // transform.ty /= 620 * translateScaleX;\n\n    // transform.invert();\n\n    // transform.append(m);\n\n    // // apply inverse scale..\n    // transform.scale(1 , 1/ratio);\n\n    // transform.scale( translateScaleX , translateScaleY );\n\n    // return transform;\n};\n\n/*\n * Constrains the filter area to the texture size\n * @param filterArea {Rectangle} The filter area we want to cap\n */\nFilterManager.prototype.capFilterArea = function (filterArea)\n{\n    if (filterArea.x < 0)\n    {\n        filterArea.width += filterArea.x;\n        filterArea.x = 0;\n    }\n\n    if (filterArea.y < 0)\n    {\n        filterArea.height += filterArea.y;\n        filterArea.y = 0;\n    }\n\n    if ( filterArea.x + filterArea.width > this.textureSize.width )\n    {\n        filterArea.width = this.textureSize.width - filterArea.x;\n    }\n\n    if ( filterArea.y + filterArea.height > this.textureSize.height )\n    {\n        filterArea.height = this.textureSize.height - filterArea.y;\n    }\n};\n\n/*\n * Resizes all the render targets in the pool\n * @param width {number} the new width\n * @param height {number} the new height\n */\nFilterManager.prototype.resize = function ( width, height )\n{\n    this.textureSize.width = width;\n    this.textureSize.height = height;\n\n    for (var i = 0; i < this.texturePool.length; i++)\n    {\n        this.texturePool[i].resize( width, height );\n    }\n};\n\n/**\n * Destroys the filter and removes it from the filter stack.\n *\n */\nFilterManager.prototype.destroy = function ()\n{\n    this.filterStack = null;\n    this.offsetY = 0;\n\n    // destroy textures\n    for (var i = 0; i < this.texturePool.length; i++)\n    {\n        this.texturePool[i].destroy();\n    }\n\n    this.texturePool = null;\n};\n"]},"metadata":{},"sourceType":"script"}