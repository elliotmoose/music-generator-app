{"ast":null,"code":"var Container = require('../display/Container'),\n    Texture = require('../textures/Texture'),\n    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),\n    CanvasGraphics = require('../renderers/canvas/utils/CanvasGraphics'),\n    GraphicsData = require('./GraphicsData'),\n    math = require('../math'),\n    CONST = require('../const'),\n    tempPoint = new math.Point();\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\n\n\nfunction Graphics() {\n  Container.call(this);\n  /**\n   * The alpha value used when filling the Graphics object.\n   *\n   * @member {number}\n   * @default 1\n   */\n\n  this.fillAlpha = 1;\n  /**\n   * The width (thickness) of any lines drawn.\n   *\n   * @member {number}\n   * @default 0\n   */\n\n  this.lineWidth = 0;\n  /**\n   * The color of any lines drawn.\n   *\n   * @member {string}\n   * @default 0\n   */\n\n  this.lineColor = 0;\n  /**\n   * Graphics data\n   *\n   * @member {GraphicsData[]}\n   * @private\n   */\n\n  this.graphicsData = [];\n  /**\n   * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.\n   *\n   * @member {number}\n   * @default 0xFFFFFF\n   */\n\n  this.tint = 0xFFFFFF;\n  /**\n   * The previous tint applied to the graphic shape. Used to compare to the current tint and check if theres change.\n   *\n   * @member {number}\n   * @private\n   * @default 0xFFFFFF\n   */\n\n  this._prevTint = 0xFFFFFF;\n  /**\n   * The blend mode to be applied to the graphic shape. Apply a value of blendModes.NORMAL to reset the blend mode.\n   *\n   * @member {number}\n   * @default CONST.BLEND_MODES.NORMAL;\n   */\n\n  this.blendMode = CONST.BLEND_MODES.NORMAL;\n  /**\n   * Current path\n   *\n   * @member {GraphicsData}\n   * @private\n   */\n\n  this.currentPath = null;\n  /**\n   * Array containing some WebGL-related properties used by the WebGL renderer.\n   *\n   * @member {object<number, object>}\n   * @private\n   */\n  // TODO - _webgl should use a prototype object, not a random undocumented object...\n\n  this._webGL = {};\n  /**\n   * Whether this shape is being used as a mask.\n   *\n   * @member {boolean}\n   */\n\n  this.isMask = false;\n  /**\n   * The bounds' padding used for bounds calculation.\n   *\n   * @member {number}\n   */\n\n  this.boundsPadding = 0;\n  /**\n   * A cache of the local bounds to prevent recalculation.\n   *\n   * @member {Rectangle}\n   * @private\n   */\n\n  this._localBounds = new math.Rectangle(0, 0, 1, 1);\n  /**\n   * Used to detect if the graphics object has changed. If this is set to true then the graphics\n   * object will be recalculated.\n   *\n   * @member {boolean}\n   * @private\n   */\n\n  this.dirty = true;\n  /**\n   * Used to detect if the WebGL graphics object has changed. If this is set to true then the\n   * graphics object will be recalculated.\n   *\n   * @member {boolean}\n   * @private\n   */\n\n  this.glDirty = false;\n  this.boundsDirty = true;\n  /**\n   * Used to detect if the cached sprite object needs to be updated.\n   *\n   * @member {boolean}\n   * @private\n   */\n\n  this.cachedSpriteDirty = false;\n} // constructor\n\n\nGraphics.prototype = Object.create(Container.prototype);\nGraphics.prototype.constructor = Graphics;\nmodule.exports = Graphics;\nObject.defineProperties(Graphics.prototype, {\n  /**\n   * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n   * This is useful if your graphics element does not change often, as it will speed up the rendering\n   * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n   * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n   * you are constantly redrawing the graphics element.\n   *\n   * @member {boolean}\n   * @memberof Graphics#\n   * @default false\n   * @private\n   */\n});\n/**\n * Creates a new Graphics object with the same values as this one.\n * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n *\n * @return {Graphics}\n */\n\nGraphics.prototype.clone = function () {\n  var clone = new Graphics();\n  clone.renderable = this.renderable;\n  clone.fillAlpha = this.fillAlpha;\n  clone.lineWidth = this.lineWidth;\n  clone.lineColor = this.lineColor;\n  clone.tint = this.tint;\n  clone.blendMode = this.blendMode;\n  clone.isMask = this.isMask;\n  clone.boundsPadding = this.boundsPadding;\n  clone.dirty = this.dirty;\n  clone.glDirty = this.glDirty;\n  clone.cachedSpriteDirty = this.cachedSpriteDirty; // copy graphics data\n\n  for (var i = 0; i < this.graphicsData.length; ++i) {\n    clone.graphicsData.push(this.graphicsData[i].clone());\n  }\n\n  clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];\n  clone.updateLocalBounds();\n  return clone;\n};\n/**\n * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.\n *\n * @param lineWidth {number} width of the line to draw, will update the objects stored style\n * @param color {number} color of the line to draw, will update the objects stored style\n * @param alpha {number} alpha of the line to draw, will update the objects stored style\n * @return {Graphics}\n */\n\n\nGraphics.prototype.lineStyle = function (lineWidth, color, alpha) {\n  this.lineWidth = lineWidth || 0;\n  this.lineColor = color || 0;\n  this.lineAlpha = alpha === undefined ? 1 : alpha;\n\n  if (this.currentPath) {\n    if (this.currentPath.shape.points.length) {\n      // halfway through a line? start a new one!\n      this.drawShape(new math.Polygon(this.currentPath.shape.points.slice(-2)));\n    } else {\n      // otherwise its empty so lets just set the line properties\n      this.currentPath.lineWidth = this.lineWidth;\n      this.currentPath.lineColor = this.lineColor;\n      this.currentPath.lineAlpha = this.lineAlpha;\n    }\n  }\n\n  return this;\n};\n/**\n * Moves the current drawing position to x, y.\n *\n * @param x {number} the X coordinate to move to\n * @param y {number} the Y coordinate to move to\n * @return {Graphics}\n  */\n\n\nGraphics.prototype.moveTo = function (x, y) {\n  this.drawShape(new math.Polygon([x, y]));\n  return this;\n};\n/**\n * Draws a line using the current line style from the current drawing position to (x, y);\n * The current drawing position is then set to (x, y).\n *\n * @param x {number} the X coordinate to draw to\n * @param y {number} the Y coordinate to draw to\n * @return {Graphics}\n */\n\n\nGraphics.prototype.lineTo = function (x, y) {\n  this.currentPath.shape.points.push(x, y);\n  this.dirty = true;\n  return this;\n};\n/**\n * Calculate the points for a quadratic bezier curve and then draws it.\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * @param cpX {number} Control point x\n * @param cpY {number} Control point y\n * @param toX {number} Destination point x\n * @param toY {number} Destination point y\n * @return {Graphics}\n */\n\n\nGraphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY) {\n  if (this.currentPath) {\n    if (this.currentPath.shape.points.length === 0) {\n      this.currentPath.shape.points = [0, 0];\n    }\n  } else {\n    this.moveTo(0, 0);\n  }\n\n  var xa,\n      ya,\n      n = 20,\n      points = this.currentPath.shape.points;\n\n  if (points.length === 0) {\n    this.moveTo(0, 0);\n  }\n\n  var fromX = points[points.length - 2];\n  var fromY = points[points.length - 1];\n  var j = 0;\n\n  for (var i = 1; i <= n; ++i) {\n    j = i / n;\n    xa = fromX + (cpX - fromX) * j;\n    ya = fromY + (cpY - fromY) * j;\n    points.push(xa + (cpX + (toX - cpX) * j - xa) * j, ya + (cpY + (toY - cpY) * j - ya) * j);\n  }\n\n  this.dirty = this.boundsDirty = true;\n  return this;\n};\n/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * @param cpX {number} Control point x\n * @param cpY {number} Control point y\n * @param cpX2 {number} Second Control point x\n * @param cpY2 {number} Second Control point y\n * @param toX {number} Destination point x\n * @param toY {number} Destination point y\n * @return {Graphics}\n */\n\n\nGraphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY) {\n  if (this.currentPath) {\n    if (this.currentPath.shape.points.length === 0) {\n      this.currentPath.shape.points = [0, 0];\n    }\n  } else {\n    this.moveTo(0, 0);\n  }\n\n  var n = 20,\n      dt,\n      dt2,\n      dt3,\n      t2,\n      t3,\n      points = this.currentPath.shape.points;\n  var fromX = points[points.length - 2];\n  var fromY = points[points.length - 1];\n  var j = 0;\n\n  for (var i = 1; i <= n; ++i) {\n    j = i / n;\n    dt = 1 - j;\n    dt2 = dt * dt;\n    dt3 = dt2 * dt;\n    t2 = j * j;\n    t3 = t2 * j;\n    points.push(dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX, dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n  }\n\n  this.dirty = this.boundsDirty = true;\n  return this;\n};\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n *\n * @param x1 {number} The x-coordinate of the beginning of the arc\n * @param y1 {number} The y-coordinate of the beginning of the arc\n * @param x2 {number} The x-coordinate of the end of the arc\n * @param y2 {number} The y-coordinate of the end of the arc\n * @param radius {number} The radius of the arc\n * @return {Graphics}\n */\n\n\nGraphics.prototype.arcTo = function (x1, y1, x2, y2, radius) {\n  if (this.currentPath) {\n    if (this.currentPath.shape.points.length === 0) {\n      this.currentPath.shape.points.push(x1, y1);\n    }\n  } else {\n    this.moveTo(x1, y1);\n  }\n\n  var points = this.currentPath.shape.points,\n      fromX = points[points.length - 2],\n      fromY = points[points.length - 1],\n      a1 = fromY - y1,\n      b1 = fromX - x1,\n      a2 = y2 - y1,\n      b2 = x2 - x1,\n      mm = Math.abs(a1 * b2 - b1 * a2);\n\n  if (mm < 1.0e-8 || radius === 0) {\n    if (points[points.length - 2] !== x1 || points[points.length - 1] !== y1) {\n      points.push(x1, y1);\n    }\n  } else {\n    var dd = a1 * a1 + b1 * b1,\n        cc = a2 * a2 + b2 * b2,\n        tt = a1 * a2 + b1 * b2,\n        k1 = radius * Math.sqrt(dd) / mm,\n        k2 = radius * Math.sqrt(cc) / mm,\n        j1 = k1 * tt / dd,\n        j2 = k2 * tt / cc,\n        cx = k1 * b2 + k2 * b1,\n        cy = k1 * a2 + k2 * a1,\n        px = b1 * (k2 + j1),\n        py = a1 * (k2 + j1),\n        qx = b2 * (k1 + j2),\n        qy = a2 * (k1 + j2),\n        startAngle = Math.atan2(py - cy, px - cx),\n        endAngle = Math.atan2(qy - cy, qx - cx);\n    this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n  }\n\n  this.dirty = this.boundsDirty = true;\n  return this;\n};\n/**\n * The arc method creates an arc/curve (used to create circles, or parts of circles).\n *\n * @param cx {number} The x-coordinate of the center of the circle\n * @param cy {number} The y-coordinate of the center of the circle\n * @param radius {number} The radius of the circle\n * @param startAngle {number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)\n * @param endAngle {number} The ending angle, in radians\n * @param anticlockwise {boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.\n * @return {Graphics}\n */\n\n\nGraphics.prototype.arc = function (cx, cy, radius, startAngle, endAngle, anticlockwise) {\n  anticlockwise = anticlockwise || false;\n\n  if (startAngle === endAngle) {\n    return this;\n  }\n\n  if (!anticlockwise && endAngle <= startAngle) {\n    endAngle += Math.PI * 2;\n  } else if (anticlockwise && startAngle <= endAngle) {\n    startAngle += Math.PI * 2;\n  }\n\n  var sweep = anticlockwise ? (startAngle - endAngle) * -1 : endAngle - startAngle;\n  var segs = Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;\n\n  if (sweep === 0) {\n    return this;\n  }\n\n  var startX = cx + Math.cos(startAngle) * radius;\n  var startY = cy + Math.sin(startAngle) * radius;\n\n  if (this.currentPath) {\n    if (anticlockwise && this.filling) {\n      this.currentPath.shape.points.push(cx, cy);\n    } else {\n      this.currentPath.shape.points.push(startX, startY);\n    }\n  } else {\n    if (anticlockwise && this.filling) {\n      this.moveTo(cx, cy);\n    } else {\n      this.moveTo(startX, startY);\n    }\n  }\n\n  var points = this.currentPath.shape.points;\n  var theta = sweep / (segs * 2);\n  var theta2 = theta * 2;\n  var cTheta = Math.cos(theta);\n  var sTheta = Math.sin(theta);\n  var segMinus = segs - 1;\n  var remainder = segMinus % 1 / segMinus;\n\n  for (var i = 0; i <= segMinus; i++) {\n    var real = i + remainder * i;\n    var angle = theta + startAngle + theta2 * real;\n    var c = Math.cos(angle);\n    var s = -Math.sin(angle);\n    points.push((cTheta * c + sTheta * s) * radius + cx, (cTheta * -s + sTheta * c) * radius + cy);\n  }\n\n  this.dirty = this.boundsDirty = true;\n  return this;\n};\n/**\n * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n * (such as lineTo() or drawCircle()) use when drawing.\n *\n * @param color {number} the color of the fill\n * @param alpha {number} the alpha of the fill\n * @return {Graphics}\n */\n\n\nGraphics.prototype.beginFill = function (color, alpha) {\n  this.filling = true;\n  this.fillColor = color || 0;\n  this.fillAlpha = alpha === undefined ? 1 : alpha;\n\n  if (this.currentPath) {\n    if (this.currentPath.shape.points.length <= 2) {\n      this.currentPath.fill = this.filling;\n      this.currentPath.fillColor = this.fillColor;\n      this.currentPath.fillAlpha = this.fillAlpha;\n    }\n  }\n\n  return this;\n};\n/**\n * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n *\n * @return {Graphics}\n */\n\n\nGraphics.prototype.endFill = function () {\n  this.filling = false;\n  this.fillColor = null;\n  this.fillAlpha = 1;\n  return this;\n};\n/**\n *\n * @param x {number} The X coord of the top-left of the rectangle\n * @param y {number} The Y coord of the top-left of the rectangle\n * @param width {number} The width of the rectangle\n * @param height {number} The height of the rectangle\n * @return {Graphics}\n */\n\n\nGraphics.prototype.drawRect = function (x, y, width, height) {\n  this.drawShape(new math.Rectangle(x, y, width, height));\n  return this;\n};\n/**\n *\n * @param x {number} The X coord of the top-left of the rectangle\n * @param y {number} The Y coord of the top-left of the rectangle\n * @param width {number} The width of the rectangle\n * @param height {number} The height of the rectangle\n * @param radius {number} Radius of the rectangle corners\n */\n\n\nGraphics.prototype.drawRoundedRect = function (x, y, width, height, radius) {\n  this.drawShape(new math.RoundedRectangle(x, y, width, height, radius));\n  return this;\n};\n/**\n * Draws a circle.\n *\n * @param x {number} The X coordinate of the center of the circle\n * @param y {number} The Y coordinate of the center of the circle\n * @param radius {number} The radius of the circle\n * @return {Graphics}\n */\n\n\nGraphics.prototype.drawCircle = function (x, y, radius) {\n  this.drawShape(new math.Circle(x, y, radius));\n  return this;\n};\n/**\n * Draws an ellipse.\n *\n * @param x {number} The X coordinate of the center of the ellipse\n * @param y {number} The Y coordinate of the center of the ellipse\n * @param width {number} The half width of the ellipse\n * @param height {number} The half height of the ellipse\n * @return {Graphics}\n */\n\n\nGraphics.prototype.drawEllipse = function (x, y, width, height) {\n  this.drawShape(new math.Ellipse(x, y, width, height));\n  return this;\n};\n/**\n * Draws a polygon using the given path.\n *\n * @param path {Array} The path data used to construct the polygon.\n * @return {Graphics}\n */\n\n\nGraphics.prototype.drawPolygon = function (path) {\n  // prevents an argument assignment deopt\n  // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n  var points = path;\n\n  if (!Array.isArray(points)) {\n    // prevents an argument leak deopt\n    // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    points = new Array(arguments.length);\n\n    for (var i = 0; i < points.length; ++i) {\n      points[i] = arguments[i];\n    }\n  }\n\n  this.drawShape(new math.Polygon(points));\n  return this;\n};\n/**\n * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n *\n * @return {Graphics}\n */\n\n\nGraphics.prototype.clear = function () {\n  this.lineWidth = 0;\n  this.filling = false;\n  this.dirty = true;\n  this.clearDirty = true;\n  this.graphicsData = [];\n  return this;\n};\n/**\n * Useful function that returns a texture of the graphics object that can then be used to create sprites\n * This can be quite useful if your geometry is complicated and needs to be reused multiple times.\n *\n * @param resolution {number} The resolution of the texture being generated\n * @param scaleMode {number} Should be one of the scaleMode consts\n * @return {Texture} a texture of the graphics object\n */\n\n\nGraphics.prototype.generateTexture = function (renderer, resolution, scaleMode) {\n  resolution = resolution || 1;\n  var bounds = this.getLocalBounds();\n  var canvasBuffer = new CanvasBuffer(bounds.width * resolution, bounds.height * resolution);\n  var texture = Texture.fromCanvas(canvasBuffer.canvas, scaleMode);\n  texture.baseTexture.resolution = resolution;\n  canvasBuffer.context.scale(resolution, resolution);\n  canvasBuffer.context.translate(-bounds.x, -bounds.y);\n  CanvasGraphics.renderGraphics(this, canvasBuffer.context);\n  return texture;\n};\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n * @private\n */\n\n\nGraphics.prototype._renderWebGL = function (renderer) {\n  // if the sprite is not visible or the alpha is 0 then no need to render this element\n  // this code may still be needed so leaving for now..\n  //\n\n  /*\n  if (this._cacheAsBitmap)\n  {\n      if (this.dirty || this.cachedSpriteDirty)\n      {\n          this._generateCachedSprite();\n           // we will also need to update the texture on the gpu too!\n          this.updateCachedSpriteTexture();\n           this.cachedSpriteDirty = false;\n          this.dirty = false;\n      }\n       this._cachedSprite.worldAlpha = this.worldAlpha;\n       Sprite.prototype.renderWebGL.call(this._cachedSprite, renderer);\n       return;\n  }\n   */\n  if (this.glDirty) {\n    this.dirty = true;\n    this.glDirty = false;\n  }\n\n  renderer.setObjectRenderer(renderer.plugins.graphics);\n  renderer.plugins.graphics.render(this);\n};\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer}\n * @private\n */\n\n\nGraphics.prototype._renderCanvas = function (renderer) {\n  if (this.isMask === true) {\n    return;\n  } // if the tint has changed, set the graphics object to dirty.\n\n\n  if (this._prevTint !== this.tint) {\n    this.dirty = true;\n    this._prevTint = this.tint;\n  } // this code may still be needed so leaving for now..\n  //\n\n  /*\n  if (this._cacheAsBitmap)\n  {\n      if (this.dirty || this.cachedSpriteDirty)\n      {\n          this._generateCachedSprite();\n           // we will also need to update the texture\n          this.updateCachedSpriteTexture();\n           this.cachedSpriteDirty = false;\n          this.dirty = false;\n      }\n       this._cachedSprite.alpha = this.alpha;\n       Sprite.prototype._renderCanvas.call(this._cachedSprite, renderer);\n       return;\n  }\n  */\n\n\n  var context = renderer.context;\n  var transform = this.worldTransform;\n\n  if (this.blendMode !== renderer.currentBlendMode) {\n    renderer.currentBlendMode = this.blendMode;\n    context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];\n  }\n\n  var resolution = renderer.resolution;\n  context.setTransform(transform.a * resolution, transform.b * resolution, transform.c * resolution, transform.d * resolution, transform.tx * resolution, transform.ty * resolution);\n  CanvasGraphics.renderGraphics(this, context);\n};\n/**\n * Retrieves the bounds of the graphic shape as a rectangle object\n *\n * @return {Rectangle} the rectangular bounding area\n */\n\n\nGraphics.prototype.getBounds = function (matrix) {\n  if (!this._currentBounds) {\n    // return an empty object if the item is a mask!\n    if (!this.renderable) {\n      return math.Rectangle.EMPTY;\n    }\n\n    if (this.boundsDirty) {\n      this.updateLocalBounds();\n      this.glDirty = true;\n      this.cachedSpriteDirty = true;\n      this.boundsDirty = false;\n    }\n\n    var bounds = this._localBounds;\n    var w0 = bounds.x;\n    var w1 = bounds.width + bounds.x;\n    var h0 = bounds.y;\n    var h1 = bounds.height + bounds.y;\n    var worldTransform = matrix || this.worldTransform;\n    var a = worldTransform.a;\n    var b = worldTransform.b;\n    var c = worldTransform.c;\n    var d = worldTransform.d;\n    var tx = worldTransform.tx;\n    var ty = worldTransform.ty;\n    var x1 = a * w1 + c * h1 + tx;\n    var y1 = d * h1 + b * w1 + ty;\n    var x2 = a * w0 + c * h1 + tx;\n    var y2 = d * h1 + b * w0 + ty;\n    var x3 = a * w0 + c * h0 + tx;\n    var y3 = d * h0 + b * w0 + ty;\n    var x4 = a * w1 + c * h0 + tx;\n    var y4 = d * h0 + b * w1 + ty;\n    var maxX = x1;\n    var maxY = y1;\n    var minX = x1;\n    var minY = y1;\n    minX = x2 < minX ? x2 : minX;\n    minX = x3 < minX ? x3 : minX;\n    minX = x4 < minX ? x4 : minX;\n    minY = y2 < minY ? y2 : minY;\n    minY = y3 < minY ? y3 : minY;\n    minY = y4 < minY ? y4 : minY;\n    maxX = x2 > maxX ? x2 : maxX;\n    maxX = x3 > maxX ? x3 : maxX;\n    maxX = x4 > maxX ? x4 : maxX;\n    maxY = y2 > maxY ? y2 : maxY;\n    maxY = y3 > maxY ? y3 : maxY;\n    maxY = y4 > maxY ? y4 : maxY;\n    this._bounds.x = minX;\n    this._bounds.width = maxX - minX;\n    this._bounds.y = minY;\n    this._bounds.height = maxY - minY;\n    this._currentBounds = this._bounds;\n  }\n\n  return this._currentBounds;\n};\n/**\n* Tests if a point is inside this graphics object\n*\n* @param point {Point} the point to test\n* @return {boolean} the result of the test\n*/\n\n\nGraphics.prototype.containsPoint = function (point) {\n  this.worldTransform.applyInverse(point, tempPoint);\n  var graphicsData = this.graphicsData;\n\n  for (var i = 0; i < graphicsData.length; i++) {\n    var data = graphicsData[i];\n\n    if (!data.fill) {\n      continue;\n    } // only deal with fills..\n\n\n    if (data.shape) {\n      if (data.shape.contains(tempPoint.x, tempPoint.y)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n/**\n * Update the bounds of the object\n *\n */\n\n\nGraphics.prototype.updateLocalBounds = function () {\n  var minX = Infinity;\n  var maxX = -Infinity;\n  var minY = Infinity;\n  var maxY = -Infinity;\n\n  if (this.graphicsData.length) {\n    var shape, points, x, y, w, h;\n\n    for (var i = 0; i < this.graphicsData.length; i++) {\n      var data = this.graphicsData[i];\n      var type = data.type;\n      var lineWidth = data.lineWidth;\n      shape = data.shape;\n\n      if (type === CONST.SHAPES.RECT || type === CONST.SHAPES.RREC) {\n        x = shape.x - lineWidth / 2;\n        y = shape.y - lineWidth / 2;\n        w = shape.width + lineWidth;\n        h = shape.height + lineWidth;\n        minX = x < minX ? x : minX;\n        maxX = x + w > maxX ? x + w : maxX;\n        minY = y < minY ? y : minY;\n        maxY = y + h > maxY ? y + h : maxY;\n      } else if (type === CONST.SHAPES.CIRC) {\n        x = shape.x;\n        y = shape.y;\n        w = shape.radius + lineWidth / 2;\n        h = shape.radius + lineWidth / 2;\n        minX = x - w < minX ? x - w : minX;\n        maxX = x + w > maxX ? x + w : maxX;\n        minY = y - h < minY ? y - h : minY;\n        maxY = y + h > maxY ? y + h : maxY;\n      } else if (type === CONST.SHAPES.ELIP) {\n        x = shape.x;\n        y = shape.y;\n        w = shape.width + lineWidth / 2;\n        h = shape.height + lineWidth / 2;\n        minX = x - w < minX ? x - w : minX;\n        maxX = x + w > maxX ? x + w : maxX;\n        minY = y - h < minY ? y - h : minY;\n        maxY = y + h > maxY ? y + h : maxY;\n      } else {\n        // POLY\n        points = shape.points;\n\n        for (var j = 0; j < points.length; j += 2) {\n          x = points[j];\n          y = points[j + 1];\n          minX = x - lineWidth < minX ? x - lineWidth : minX;\n          maxX = x + lineWidth > maxX ? x + lineWidth : maxX;\n          minY = y - lineWidth < minY ? y - lineWidth : minY;\n          maxY = y + lineWidth > maxY ? y + lineWidth : maxY;\n        }\n      }\n    }\n  } else {\n    minX = 0;\n    maxX = 0;\n    minY = 0;\n    maxY = 0;\n  }\n\n  var padding = this.boundsPadding;\n  this._localBounds.x = minX - padding;\n  this._localBounds.width = maxX - minX + padding * 2;\n  this._localBounds.y = minY - padding;\n  this._localBounds.height = maxY - minY + padding * 2;\n};\n/**\n * Generates the cached sprite when the sprite has cacheAsBitmap = true\n *\n * @private\n */\n\n/*\nGraphics.prototype._generateCachedSprite = function ()\n{\n    var bounds = this.getLocalBounds();\n\n    if (!this._cachedSprite)\n    {\n        var canvasBuffer = new CanvasBuffer(bounds.width, bounds.height);\n        var texture = Texture.fromCanvas(canvasBuffer.canvas);\n\n        this._cachedSprite = new Sprite(texture);\n        this._cachedSprite.buffer = canvasBuffer;\n\n        this._cachedSprite.worldTransform = this.worldTransform;\n    }\n    else\n    {\n        this._cachedSprite.buffer.resize(bounds.width, bounds.height);\n    }\n\n    // leverage the anchor to account for the offset of the element\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n    // this._cachedSprite.buffer.context.save();\n    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);\n\n    // make sure we set the alpha of the graphics to 1 for the render..\n    this.worldAlpha = 1;\n\n    // now render the graphic..\n    CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);\n\n    this._cachedSprite.alpha = this.alpha;\n};\n*/\n\n/**\n * Updates texture size based on canvas size\n *\n * @private\n */\n\n/*\nGraphics.prototype.updateCachedSpriteTexture = function ()\n{\n    var cachedSprite = this._cachedSprite;\n    var texture = cachedSprite.texture;\n    var canvas = cachedSprite.buffer.canvas;\n\n    texture.baseTexture.width = canvas.width;\n    texture.baseTexture.height = canvas.height;\n    texture.crop.width = texture.frame.width = canvas.width;\n    texture.crop.height = texture.frame.height = canvas.height;\n\n    cachedSprite._width = canvas.width;\n    cachedSprite._height = canvas.height;\n\n    // update the dirty base textures\n    texture.baseTexture.dirty();\n};*/\n\n/**\n * Destroys a previous cached sprite.\n *\n */\n\n/*\nGraphics.prototype.destroyCachedSprite = function ()\n{\n    this._cachedSprite.texture.destroy(true);\n\n    // let the gc collect the unused sprite\n    // TODO could be object pooled!\n    this._cachedSprite = null;\n};*/\n\n/**\n * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n *\n * @param shape {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.\n * @return {GraphicsData} The generated GraphicsData object.\n */\n\n\nGraphics.prototype.drawShape = function (shape) {\n  if (this.currentPath) {\n    // check current path!\n    if (this.currentPath.shape.points.length <= 2) {\n      this.graphicsData.pop();\n    }\n  }\n\n  this.currentPath = null;\n  var data = new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);\n  this.graphicsData.push(data);\n\n  if (data.type === CONST.SHAPES.POLY) {\n    data.shape.closed = data.shape.closed || this.filling;\n    this.currentPath = data;\n  }\n\n  this.dirty = this.boundsDirty = true;\n  return data;\n};\n\nGraphics.prototype.destroy = function () {\n  Container.prototype.destroy.apply(this, arguments); // destroy each of the GraphicsData objects\n\n  for (var i = 0; i < this.graphicsData.length; ++i) {\n    this.graphicsData[i].destroy();\n  } // for each webgl data entry, destroy the WebGLGraphicsData\n\n\n  for (var id in this._webgl) {\n    for (var j = 0; j < this._webgl[id].data.length; ++j) {\n      this._webgl[id].data[j].destroy();\n    }\n  }\n\n  this.graphicsData = null;\n  this.currentPath = null;\n  this._webgl = null;\n  this._localBounds = null;\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/graphics/Graphics.js"],"names":["Container","require","Texture","CanvasBuffer","CanvasGraphics","GraphicsData","math","CONST","tempPoint","Point","Graphics","call","fillAlpha","lineWidth","lineColor","graphicsData","tint","_prevTint","blendMode","BLEND_MODES","NORMAL","currentPath","_webGL","isMask","boundsPadding","_localBounds","Rectangle","dirty","glDirty","boundsDirty","cachedSpriteDirty","prototype","Object","create","constructor","module","exports","defineProperties","clone","renderable","i","length","push","updateLocalBounds","lineStyle","color","alpha","lineAlpha","undefined","shape","points","drawShape","Polygon","slice","moveTo","x","y","lineTo","quadraticCurveTo","cpX","cpY","toX","toY","xa","ya","n","fromX","fromY","j","bezierCurveTo","cpX2","cpY2","dt","dt2","dt3","t2","t3","arcTo","x1","y1","x2","y2","radius","a1","b1","a2","b2","mm","Math","abs","dd","cc","tt","k1","sqrt","k2","j1","j2","cx","cy","px","py","qx","qy","startAngle","atan2","endAngle","arc","anticlockwise","PI","sweep","segs","ceil","startX","cos","startY","sin","filling","theta","theta2","cTheta","sTheta","segMinus","remainder","real","angle","c","s","beginFill","fillColor","fill","endFill","drawRect","width","height","drawRoundedRect","RoundedRectangle","drawCircle","Circle","drawEllipse","Ellipse","drawPolygon","path","Array","isArray","arguments","clear","clearDirty","generateTexture","renderer","resolution","scaleMode","bounds","getLocalBounds","canvasBuffer","texture","fromCanvas","canvas","baseTexture","context","scale","translate","renderGraphics","_renderWebGL","setObjectRenderer","plugins","graphics","render","_renderCanvas","transform","worldTransform","currentBlendMode","globalCompositeOperation","blendModes","setTransform","a","b","d","tx","ty","getBounds","matrix","_currentBounds","EMPTY","w0","w1","h0","h1","x3","y3","x4","y4","maxX","maxY","minX","minY","_bounds","containsPoint","point","applyInverse","data","contains","Infinity","w","h","type","SHAPES","RECT","RREC","CIRC","ELIP","padding","pop","POLY","closed","destroy","apply","id","_webgl"],"mappings":"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","sourcesContent":["var Container = require('../display/Container'),\n    Texture = require('../textures/Texture'),\n    CanvasBuffer = require('../renderers/canvas/utils/CanvasBuffer'),\n    CanvasGraphics = require('../renderers/canvas/utils/CanvasGraphics'),\n    GraphicsData = require('./GraphicsData'),\n    math = require('../math'),\n    CONST = require('../const'),\n    tempPoint = new math.Point();\n\n/**\n * The Graphics class contains methods used to draw primitive shapes such as lines, circles and\n * rectangles to the display, and to color and fill them.\n *\n * @class\n * @extends PIXI.Container\n * @memberof PIXI\n */\nfunction Graphics()\n{\n    Container.call(this);\n\n    /**\n     * The alpha value used when filling the Graphics object.\n     *\n     * @member {number}\n     * @default 1\n     */\n    this.fillAlpha = 1;\n\n    /**\n     * The width (thickness) of any lines drawn.\n     *\n     * @member {number}\n     * @default 0\n     */\n    this.lineWidth = 0;\n\n    /**\n     * The color of any lines drawn.\n     *\n     * @member {string}\n     * @default 0\n     */\n    this.lineColor = 0;\n\n    /**\n     * Graphics data\n     *\n     * @member {GraphicsData[]}\n     * @private\n     */\n    this.graphicsData = [];\n\n    /**\n     * The tint applied to the graphic shape. This is a hex value. Apply a value of 0xFFFFFF to reset the tint.\n     *\n     * @member {number}\n     * @default 0xFFFFFF\n     */\n    this.tint = 0xFFFFFF;\n\n    /**\n     * The previous tint applied to the graphic shape. Used to compare to the current tint and check if theres change.\n     *\n     * @member {number}\n     * @private\n     * @default 0xFFFFFF\n     */\n    this._prevTint = 0xFFFFFF;\n\n    /**\n     * The blend mode to be applied to the graphic shape. Apply a value of blendModes.NORMAL to reset the blend mode.\n     *\n     * @member {number}\n     * @default CONST.BLEND_MODES.NORMAL;\n     */\n    this.blendMode = CONST.BLEND_MODES.NORMAL;\n\n    /**\n     * Current path\n     *\n     * @member {GraphicsData}\n     * @private\n     */\n    this.currentPath = null;\n\n    /**\n     * Array containing some WebGL-related properties used by the WebGL renderer.\n     *\n     * @member {object<number, object>}\n     * @private\n     */\n    // TODO - _webgl should use a prototype object, not a random undocumented object...\n    this._webGL = {};\n\n    /**\n     * Whether this shape is being used as a mask.\n     *\n     * @member {boolean}\n     */\n    this.isMask = false;\n\n    /**\n     * The bounds' padding used for bounds calculation.\n     *\n     * @member {number}\n     */\n    this.boundsPadding = 0;\n\n    /**\n     * A cache of the local bounds to prevent recalculation.\n     *\n     * @member {Rectangle}\n     * @private\n     */\n    this._localBounds = new math.Rectangle(0,0,1,1);\n\n    /**\n     * Used to detect if the graphics object has changed. If this is set to true then the graphics\n     * object will be recalculated.\n     *\n     * @member {boolean}\n     * @private\n     */\n    this.dirty = true;\n\n    /**\n     * Used to detect if the WebGL graphics object has changed. If this is set to true then the\n     * graphics object will be recalculated.\n     *\n     * @member {boolean}\n     * @private\n     */\n    this.glDirty = false;\n\n    this.boundsDirty = true;\n\n    /**\n     * Used to detect if the cached sprite object needs to be updated.\n     *\n     * @member {boolean}\n     * @private\n     */\n    this.cachedSpriteDirty = false;\n}\n\n// constructor\nGraphics.prototype = Object.create(Container.prototype);\nGraphics.prototype.constructor = Graphics;\nmodule.exports = Graphics;\n\nObject.defineProperties(Graphics.prototype, {\n    /**\n     * When cacheAsBitmap is set to true the graphics object will be rendered as if it was a sprite.\n     * This is useful if your graphics element does not change often, as it will speed up the rendering\n     * of the object in exchange for taking up texture memory. It is also useful if you need the graphics\n     * object to be anti-aliased, because it will be rendered using canvas. This is not recommended if\n     * you are constantly redrawing the graphics element.\n     *\n     * @member {boolean}\n     * @memberof Graphics#\n     * @default false\n     * @private\n     */\n\n});\n\n/**\n * Creates a new Graphics object with the same values as this one.\n * Note that the only the properties of the object are cloned, not its transform (position,scale,etc)\n *\n * @return {Graphics}\n */\nGraphics.prototype.clone = function ()\n{\n    var clone = new Graphics();\n\n    clone.renderable    = this.renderable;\n    clone.fillAlpha     = this.fillAlpha;\n    clone.lineWidth     = this.lineWidth;\n    clone.lineColor     = this.lineColor;\n    clone.tint          = this.tint;\n    clone.blendMode     = this.blendMode;\n    clone.isMask        = this.isMask;\n    clone.boundsPadding = this.boundsPadding;\n    clone.dirty         = this.dirty;\n    clone.glDirty       = this.glDirty;\n    clone.cachedSpriteDirty = this.cachedSpriteDirty;\n\n    // copy graphics data\n    for (var i = 0; i < this.graphicsData.length; ++i)\n    {\n        clone.graphicsData.push(this.graphicsData[i].clone());\n    }\n\n    clone.currentPath = clone.graphicsData[clone.graphicsData.length - 1];\n\n    clone.updateLocalBounds();\n\n    return clone;\n};\n\n/**\n * Specifies the line style used for subsequent calls to Graphics methods such as the lineTo() method or the drawCircle() method.\n *\n * @param lineWidth {number} width of the line to draw, will update the objects stored style\n * @param color {number} color of the line to draw, will update the objects stored style\n * @param alpha {number} alpha of the line to draw, will update the objects stored style\n * @return {Graphics}\n */\nGraphics.prototype.lineStyle = function (lineWidth, color, alpha)\n{\n    this.lineWidth = lineWidth || 0;\n    this.lineColor = color || 0;\n    this.lineAlpha = (alpha === undefined) ? 1 : alpha;\n\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length)\n        {\n            // halfway through a line? start a new one!\n            this.drawShape( new math.Polygon( this.currentPath.shape.points.slice(-2) ));\n        }\n        else\n        {\n            // otherwise its empty so lets just set the line properties\n            this.currentPath.lineWidth = this.lineWidth;\n            this.currentPath.lineColor = this.lineColor;\n            this.currentPath.lineAlpha = this.lineAlpha;\n        }\n    }\n\n    return this;\n};\n\n/**\n * Moves the current drawing position to x, y.\n *\n * @param x {number} the X coordinate to move to\n * @param y {number} the Y coordinate to move to\n * @return {Graphics}\n  */\nGraphics.prototype.moveTo = function (x, y)\n{\n    this.drawShape(new math.Polygon([x,y]));\n\n    return this;\n};\n\n/**\n * Draws a line using the current line style from the current drawing position to (x, y);\n * The current drawing position is then set to (x, y).\n *\n * @param x {number} the X coordinate to draw to\n * @param y {number} the Y coordinate to draw to\n * @return {Graphics}\n */\nGraphics.prototype.lineTo = function (x, y)\n{\n    this.currentPath.shape.points.push(x, y);\n    this.dirty = true;\n\n    return this;\n};\n\n/**\n * Calculate the points for a quadratic bezier curve and then draws it.\n * Based on: https://stackoverflow.com/questions/785097/how-do-i-implement-a-bezier-curve-in-c\n *\n * @param cpX {number} Control point x\n * @param cpY {number} Control point y\n * @param toX {number} Destination point x\n * @param toY {number} Destination point y\n * @return {Graphics}\n */\nGraphics.prototype.quadraticCurveTo = function (cpX, cpY, toX, toY)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points = [0, 0];\n        }\n    }\n    else\n    {\n        this.moveTo(0,0);\n    }\n\n    var xa,\n        ya,\n        n = 20,\n        points = this.currentPath.shape.points;\n\n    if (points.length === 0)\n    {\n        this.moveTo(0, 0);\n    }\n\n    var fromX = points[points.length-2];\n    var fromY = points[points.length-1];\n\n    var j = 0;\n    for (var i = 1; i <= n; ++i)\n    {\n        j = i / n;\n\n        xa = fromX + ( (cpX - fromX) * j );\n        ya = fromY + ( (cpY - fromY) * j );\n\n        points.push( xa + ( ((cpX + ( (toX - cpX) * j )) - xa) * j ),\n                     ya + ( ((cpY + ( (toY - cpY) * j )) - ya) * j ) );\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * Calculate the points for a bezier curve and then draws it.\n *\n * @param cpX {number} Control point x\n * @param cpY {number} Control point y\n * @param cpX2 {number} Second Control point x\n * @param cpY2 {number} Second Control point y\n * @param toX {number} Destination point x\n * @param toY {number} Destination point y\n * @return {Graphics}\n */\nGraphics.prototype.bezierCurveTo = function (cpX, cpY, cpX2, cpY2, toX, toY)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points = [0, 0];\n        }\n    }\n    else\n    {\n        this.moveTo(0,0);\n    }\n\n    var n = 20,\n        dt,\n        dt2,\n        dt3,\n        t2,\n        t3,\n        points = this.currentPath.shape.points;\n\n    var fromX = points[points.length-2];\n    var fromY = points[points.length-1];\n\n    var j = 0;\n\n    for (var i = 1; i <= n; ++i)\n    {\n        j = i / n;\n\n        dt = (1 - j);\n        dt2 = dt * dt;\n        dt3 = dt2 * dt;\n\n        t2 = j * j;\n        t3 = t2 * j;\n\n        points.push( dt3 * fromX + 3 * dt2 * j * cpX + 3 * dt * t2 * cpX2 + t3 * toX,\n                     dt3 * fromY + 3 * dt2 * j * cpY + 3 * dt * t2 * cpY2 + t3 * toY);\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * The arcTo() method creates an arc/curve between two tangents on the canvas.\n *\n * \"borrowed\" from https://code.google.com/p/fxcanvas/ - thanks google!\n *\n * @param x1 {number} The x-coordinate of the beginning of the arc\n * @param y1 {number} The y-coordinate of the beginning of the arc\n * @param x2 {number} The x-coordinate of the end of the arc\n * @param y2 {number} The y-coordinate of the end of the arc\n * @param radius {number} The radius of the arc\n * @return {Graphics}\n */\nGraphics.prototype.arcTo = function (x1, y1, x2, y2, radius)\n{\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length === 0)\n        {\n            this.currentPath.shape.points.push(x1, y1);\n        }\n    }\n    else\n    {\n        this.moveTo(x1, y1);\n    }\n\n    var points = this.currentPath.shape.points,\n        fromX = points[points.length-2],\n        fromY = points[points.length-1],\n        a1 = fromY - y1,\n        b1 = fromX - x1,\n        a2 = y2   - y1,\n        b2 = x2   - x1,\n        mm = Math.abs(a1 * b2 - b1 * a2);\n\n    if (mm < 1.0e-8 || radius === 0)\n    {\n        if (points[points.length-2] !== x1 || points[points.length-1] !== y1)\n        {\n            points.push(x1, y1);\n        }\n    }\n    else\n    {\n        var dd = a1 * a1 + b1 * b1,\n            cc = a2 * a2 + b2 * b2,\n            tt = a1 * a2 + b1 * b2,\n            k1 = radius * Math.sqrt(dd) / mm,\n            k2 = radius * Math.sqrt(cc) / mm,\n            j1 = k1 * tt / dd,\n            j2 = k2 * tt / cc,\n            cx = k1 * b2 + k2 * b1,\n            cy = k1 * a2 + k2 * a1,\n            px = b1 * (k2 + j1),\n            py = a1 * (k2 + j1),\n            qx = b2 * (k1 + j2),\n            qy = a2 * (k1 + j2),\n            startAngle = Math.atan2(py - cy, px - cx),\n            endAngle   = Math.atan2(qy - cy, qx - cx);\n\n        this.arc(cx + x1, cy + y1, radius, startAngle, endAngle, b1 * a2 > b2 * a1);\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * The arc method creates an arc/curve (used to create circles, or parts of circles).\n *\n * @param cx {number} The x-coordinate of the center of the circle\n * @param cy {number} The y-coordinate of the center of the circle\n * @param radius {number} The radius of the circle\n * @param startAngle {number} The starting angle, in radians (0 is at the 3 o'clock position of the arc's circle)\n * @param endAngle {number} The ending angle, in radians\n * @param anticlockwise {boolean} Optional. Specifies whether the drawing should be counterclockwise or clockwise. False is default, and indicates clockwise, while true indicates counter-clockwise.\n * @return {Graphics}\n */\nGraphics.prototype.arc = function(cx, cy, radius, startAngle, endAngle, anticlockwise)\n{\n    anticlockwise = anticlockwise || false;\n\n    if (startAngle === endAngle)\n    {\n        return this;\n    }\n\n    if( !anticlockwise && endAngle <= startAngle )\n    {\n        endAngle += Math.PI * 2;\n    }\n    else if( anticlockwise && startAngle <= endAngle )\n    {\n        startAngle += Math.PI * 2;\n    }\n\n    var sweep = anticlockwise ? (startAngle - endAngle) * -1 : (endAngle - startAngle);\n    var segs =  Math.ceil(Math.abs(sweep) / (Math.PI * 2)) * 40;\n\n    if(sweep === 0)\n    {\n        return this;\n    }\n\n    var startX = cx + Math.cos(startAngle) * radius;\n    var startY = cy + Math.sin(startAngle) * radius;\n\n    if (this.currentPath)\n    {\n        if (anticlockwise && this.filling)\n        {\n            this.currentPath.shape.points.push(cx, cy);\n        }\n        else\n        {\n            this.currentPath.shape.points.push(startX, startY);\n        }\n    }\n    else\n    {\n        if (anticlockwise && this.filling)\n        {\n\n            this.moveTo(cx, cy);\n        }\n        else\n        {\n            this.moveTo(startX, startY);\n        }\n    }\n\n    var points = this.currentPath.shape.points;\n\n    var theta = sweep/(segs*2);\n    var theta2 = theta*2;\n\n    var cTheta = Math.cos(theta);\n    var sTheta = Math.sin(theta);\n\n    var segMinus = segs - 1;\n\n    var remainder = ( segMinus % 1 ) / segMinus;\n\n    for(var i=0; i<=segMinus; i++)\n    {\n        var real =  i + remainder * i;\n\n\n        var angle = ((theta) + startAngle + (theta2 * real));\n\n        var c = Math.cos(angle);\n        var s = -Math.sin(angle);\n\n        points.push(( (cTheta *  c) + (sTheta * s) ) * radius + cx,\n                    ( (cTheta * -s) + (sTheta * c) ) * radius + cy);\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return this;\n};\n\n/**\n * Specifies a simple one-color fill that subsequent calls to other Graphics methods\n * (such as lineTo() or drawCircle()) use when drawing.\n *\n * @param color {number} the color of the fill\n * @param alpha {number} the alpha of the fill\n * @return {Graphics}\n */\nGraphics.prototype.beginFill = function (color, alpha)\n{\n    this.filling = true;\n    this.fillColor = color || 0;\n    this.fillAlpha = (alpha === undefined) ? 1 : alpha;\n\n    if (this.currentPath)\n    {\n        if (this.currentPath.shape.points.length <= 2)\n        {\n            this.currentPath.fill = this.filling;\n            this.currentPath.fillColor = this.fillColor;\n            this.currentPath.fillAlpha = this.fillAlpha;\n        }\n    }\n    return this;\n};\n\n/**\n * Applies a fill to the lines and shapes that were added since the last call to the beginFill() method.\n *\n * @return {Graphics}\n */\nGraphics.prototype.endFill = function ()\n{\n    this.filling = false;\n    this.fillColor = null;\n    this.fillAlpha = 1;\n\n    return this;\n};\n\n/**\n *\n * @param x {number} The X coord of the top-left of the rectangle\n * @param y {number} The Y coord of the top-left of the rectangle\n * @param width {number} The width of the rectangle\n * @param height {number} The height of the rectangle\n * @return {Graphics}\n */\nGraphics.prototype.drawRect = function ( x, y, width, height )\n{\n    this.drawShape(new math.Rectangle(x,y, width, height));\n\n    return this;\n};\n\n/**\n *\n * @param x {number} The X coord of the top-left of the rectangle\n * @param y {number} The Y coord of the top-left of the rectangle\n * @param width {number} The width of the rectangle\n * @param height {number} The height of the rectangle\n * @param radius {number} Radius of the rectangle corners\n */\nGraphics.prototype.drawRoundedRect = function ( x, y, width, height, radius )\n{\n    this.drawShape(new math.RoundedRectangle(x, y, width, height, radius));\n\n    return this;\n};\n\n/**\n * Draws a circle.\n *\n * @param x {number} The X coordinate of the center of the circle\n * @param y {number} The Y coordinate of the center of the circle\n * @param radius {number} The radius of the circle\n * @return {Graphics}\n */\nGraphics.prototype.drawCircle = function (x, y, radius)\n{\n    this.drawShape(new math.Circle(x,y, radius));\n\n    return this;\n};\n\n/**\n * Draws an ellipse.\n *\n * @param x {number} The X coordinate of the center of the ellipse\n * @param y {number} The Y coordinate of the center of the ellipse\n * @param width {number} The half width of the ellipse\n * @param height {number} The half height of the ellipse\n * @return {Graphics}\n */\nGraphics.prototype.drawEllipse = function (x, y, width, height)\n{\n    this.drawShape(new math.Ellipse(x, y, width, height));\n\n    return this;\n};\n\n/**\n * Draws a polygon using the given path.\n *\n * @param path {Array} The path data used to construct the polygon.\n * @return {Graphics}\n */\nGraphics.prototype.drawPolygon = function (path)\n{\n    // prevents an argument assignment deopt\n    // see section 3.1: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n    var points = path;\n\n    if (!Array.isArray(points))\n    {\n        // prevents an argument leak deopt\n        // see section 3.2: https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#3-managing-arguments\n        points = new Array(arguments.length);\n\n        for (var i = 0; i < points.length; ++i)\n        {\n            points[i] = arguments[i];\n        }\n    }\n\n    this.drawShape(new math.Polygon(points));\n\n    return this;\n};\n\n/**\n * Clears the graphics that were drawn to this Graphics object, and resets fill and line style settings.\n *\n * @return {Graphics}\n */\nGraphics.prototype.clear = function ()\n{\n    this.lineWidth = 0;\n    this.filling = false;\n\n    this.dirty = true;\n    this.clearDirty = true;\n    this.graphicsData = [];\n\n    return this;\n};\n\n/**\n * Useful function that returns a texture of the graphics object that can then be used to create sprites\n * This can be quite useful if your geometry is complicated and needs to be reused multiple times.\n *\n * @param resolution {number} The resolution of the texture being generated\n * @param scaleMode {number} Should be one of the scaleMode consts\n * @return {Texture} a texture of the graphics object\n */\nGraphics.prototype.generateTexture = function (renderer, resolution, scaleMode)\n{\n\n    resolution = resolution || 1;\n\n    var bounds = this.getLocalBounds();\n\n    var canvasBuffer = new CanvasBuffer(bounds.width * resolution, bounds.height * resolution);\n\n    var texture = Texture.fromCanvas(canvasBuffer.canvas, scaleMode);\n    texture.baseTexture.resolution = resolution;\n\n    canvasBuffer.context.scale(resolution, resolution);\n\n    canvasBuffer.context.translate(-bounds.x,-bounds.y);\n\n    CanvasGraphics.renderGraphics(this, canvasBuffer.context);\n\n    return texture;\n};\n\n/**\n * Renders the object using the WebGL renderer\n *\n * @param renderer {WebGLRenderer}\n * @private\n */\nGraphics.prototype._renderWebGL = function (renderer)\n{\n    // if the sprite is not visible or the alpha is 0 then no need to render this element\n\n    // this code may still be needed so leaving for now..\n    //\n    /*\n    if (this._cacheAsBitmap)\n    {\n        if (this.dirty || this.cachedSpriteDirty)\n        {\n            this._generateCachedSprite();\n\n            // we will also need to update the texture on the gpu too!\n            this.updateCachedSpriteTexture();\n\n            this.cachedSpriteDirty = false;\n            this.dirty = false;\n        }\n\n        this._cachedSprite.worldAlpha = this.worldAlpha;\n\n        Sprite.prototype.renderWebGL.call(this._cachedSprite, renderer);\n\n        return;\n    }\n\n    */\n\n    if (this.glDirty)\n    {\n        this.dirty = true;\n        this.glDirty = false;\n    }\n\n    renderer.setObjectRenderer(renderer.plugins.graphics);\n    renderer.plugins.graphics.render(this);\n\n};\n\n/**\n * Renders the object using the Canvas renderer\n *\n * @param renderer {CanvasRenderer}\n * @private\n */\nGraphics.prototype._renderCanvas = function (renderer)\n{\n    if (this.isMask === true)\n    {\n        return;\n    }\n\n    // if the tint has changed, set the graphics object to dirty.\n    if (this._prevTint !== this.tint) {\n        this.dirty = true;\n        this._prevTint = this.tint;\n    }\n\n    // this code may still be needed so leaving for now..\n    //\n    /*\n    if (this._cacheAsBitmap)\n    {\n        if (this.dirty || this.cachedSpriteDirty)\n        {\n            this._generateCachedSprite();\n\n            // we will also need to update the texture\n            this.updateCachedSpriteTexture();\n\n            this.cachedSpriteDirty = false;\n            this.dirty = false;\n        }\n\n        this._cachedSprite.alpha = this.alpha;\n\n        Sprite.prototype._renderCanvas.call(this._cachedSprite, renderer);\n\n        return;\n    }\n    */\n    var context = renderer.context;\n    var transform = this.worldTransform;\n\n    if (this.blendMode !== renderer.currentBlendMode)\n    {\n        renderer.currentBlendMode = this.blendMode;\n        context.globalCompositeOperation = renderer.blendModes[renderer.currentBlendMode];\n    }\n\n    var resolution = renderer.resolution;\n    context.setTransform(\n        transform.a * resolution,\n        transform.b * resolution,\n        transform.c * resolution,\n        transform.d * resolution,\n        transform.tx * resolution,\n        transform.ty * resolution\n    );\n\n    CanvasGraphics.renderGraphics(this, context);\n};\n\n/**\n * Retrieves the bounds of the graphic shape as a rectangle object\n *\n * @return {Rectangle} the rectangular bounding area\n */\nGraphics.prototype.getBounds = function (matrix)\n{\n    if(!this._currentBounds)\n    {\n\n        // return an empty object if the item is a mask!\n        if (!this.renderable)\n        {\n            return math.Rectangle.EMPTY;\n        }\n\n        if (this.boundsDirty)\n        {\n            this.updateLocalBounds();\n\n            this.glDirty = true;\n            this.cachedSpriteDirty = true;\n            this.boundsDirty = false;\n        }\n\n        var bounds = this._localBounds;\n\n        var w0 = bounds.x;\n        var w1 = bounds.width + bounds.x;\n\n        var h0 = bounds.y;\n        var h1 = bounds.height + bounds.y;\n\n        var worldTransform = matrix || this.worldTransform;\n\n        var a = worldTransform.a;\n        var b = worldTransform.b;\n        var c = worldTransform.c;\n        var d = worldTransform.d;\n        var tx = worldTransform.tx;\n        var ty = worldTransform.ty;\n\n        var x1 = a * w1 + c * h1 + tx;\n        var y1 = d * h1 + b * w1 + ty;\n\n        var x2 = a * w0 + c * h1 + tx;\n        var y2 = d * h1 + b * w0 + ty;\n\n        var x3 = a * w0 + c * h0 + tx;\n        var y3 = d * h0 + b * w0 + ty;\n\n        var x4 =  a * w1 + c * h0 + tx;\n        var y4 =  d * h0 + b * w1 + ty;\n\n        var maxX = x1;\n        var maxY = y1;\n\n        var minX = x1;\n        var minY = y1;\n\n        minX = x2 < minX ? x2 : minX;\n        minX = x3 < minX ? x3 : minX;\n        minX = x4 < minX ? x4 : minX;\n\n        minY = y2 < minY ? y2 : minY;\n        minY = y3 < minY ? y3 : minY;\n        minY = y4 < minY ? y4 : minY;\n\n        maxX = x2 > maxX ? x2 : maxX;\n        maxX = x3 > maxX ? x3 : maxX;\n        maxX = x4 > maxX ? x4 : maxX;\n\n        maxY = y2 > maxY ? y2 : maxY;\n        maxY = y3 > maxY ? y3 : maxY;\n        maxY = y4 > maxY ? y4 : maxY;\n\n        this._bounds.x = minX;\n        this._bounds.width = maxX - minX;\n\n        this._bounds.y = minY;\n        this._bounds.height = maxY - minY;\n\n        this._currentBounds = this._bounds;\n    }\n\n    return this._currentBounds;\n};\n\n/**\n* Tests if a point is inside this graphics object\n*\n* @param point {Point} the point to test\n* @return {boolean} the result of the test\n*/\nGraphics.prototype.containsPoint = function( point )\n{\n    this.worldTransform.applyInverse(point,  tempPoint);\n\n    var graphicsData = this.graphicsData;\n\n    for (var i = 0; i < graphicsData.length; i++)\n    {\n        var data = graphicsData[i];\n\n        if (!data.fill)\n        {\n            continue;\n        }\n\n        // only deal with fills..\n        if (data.shape)\n        {\n            if ( data.shape.contains( tempPoint.x, tempPoint.y ) )\n            {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n/**\n * Update the bounds of the object\n *\n */\nGraphics.prototype.updateLocalBounds = function ()\n{\n    var minX = Infinity;\n    var maxX = -Infinity;\n\n    var minY = Infinity;\n    var maxY = -Infinity;\n\n    if (this.graphicsData.length)\n    {\n        var shape, points, x, y, w, h;\n\n        for (var i = 0; i < this.graphicsData.length; i++)\n        {\n            var data = this.graphicsData[i];\n            var type = data.type;\n            var lineWidth = data.lineWidth;\n            shape = data.shape;\n\n            if (type === CONST.SHAPES.RECT || type === CONST.SHAPES.RREC)\n            {\n                x = shape.x - lineWidth/2;\n                y = shape.y - lineWidth/2;\n                w = shape.width + lineWidth;\n                h = shape.height + lineWidth;\n\n                minX = x < minX ? x : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y < minY ? y : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else if (type === CONST.SHAPES.CIRC)\n            {\n                x = shape.x;\n                y = shape.y;\n                w = shape.radius + lineWidth/2;\n                h = shape.radius + lineWidth/2;\n\n                minX = x - w < minX ? x - w : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y - h < minY ? y - h : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else if (type === CONST.SHAPES.ELIP)\n            {\n                x = shape.x;\n                y = shape.y;\n                w = shape.width + lineWidth/2;\n                h = shape.height + lineWidth/2;\n\n                minX = x - w < minX ? x - w : minX;\n                maxX = x + w > maxX ? x + w : maxX;\n\n                minY = y - h < minY ? y - h : minY;\n                maxY = y + h > maxY ? y + h : maxY;\n            }\n            else\n            {\n                // POLY\n                points = shape.points;\n\n                for (var j = 0; j < points.length; j += 2)\n                {\n                    x = points[j];\n                    y = points[j+1];\n\n                    minX = x-lineWidth < minX ? x-lineWidth : minX;\n                    maxX = x+lineWidth > maxX ? x+lineWidth : maxX;\n\n                    minY = y-lineWidth < minY ? y-lineWidth : minY;\n                    maxY = y+lineWidth > maxY ? y+lineWidth : maxY;\n                }\n            }\n        }\n    }\n    else\n    {\n        minX = 0;\n        maxX = 0;\n        minY = 0;\n        maxY = 0;\n    }\n\n    var padding = this.boundsPadding;\n\n    this._localBounds.x = minX - padding;\n    this._localBounds.width = (maxX - minX) + padding * 2;\n\n    this._localBounds.y = minY - padding;\n    this._localBounds.height = (maxY - minY) + padding * 2;\n};\n\n/**\n * Generates the cached sprite when the sprite has cacheAsBitmap = true\n *\n * @private\n */\n/*\nGraphics.prototype._generateCachedSprite = function ()\n{\n    var bounds = this.getLocalBounds();\n\n    if (!this._cachedSprite)\n    {\n        var canvasBuffer = new CanvasBuffer(bounds.width, bounds.height);\n        var texture = Texture.fromCanvas(canvasBuffer.canvas);\n\n        this._cachedSprite = new Sprite(texture);\n        this._cachedSprite.buffer = canvasBuffer;\n\n        this._cachedSprite.worldTransform = this.worldTransform;\n    }\n    else\n    {\n        this._cachedSprite.buffer.resize(bounds.width, bounds.height);\n    }\n\n    // leverage the anchor to account for the offset of the element\n    this._cachedSprite.anchor.x = -( bounds.x / bounds.width );\n    this._cachedSprite.anchor.y = -( bounds.y / bounds.height );\n\n    // this._cachedSprite.buffer.context.save();\n    this._cachedSprite.buffer.context.translate(-bounds.x,-bounds.y);\n\n    // make sure we set the alpha of the graphics to 1 for the render..\n    this.worldAlpha = 1;\n\n    // now render the graphic..\n    CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context);\n\n    this._cachedSprite.alpha = this.alpha;\n};\n*/\n/**\n * Updates texture size based on canvas size\n *\n * @private\n */\n/*\nGraphics.prototype.updateCachedSpriteTexture = function ()\n{\n    var cachedSprite = this._cachedSprite;\n    var texture = cachedSprite.texture;\n    var canvas = cachedSprite.buffer.canvas;\n\n    texture.baseTexture.width = canvas.width;\n    texture.baseTexture.height = canvas.height;\n    texture.crop.width = texture.frame.width = canvas.width;\n    texture.crop.height = texture.frame.height = canvas.height;\n\n    cachedSprite._width = canvas.width;\n    cachedSprite._height = canvas.height;\n\n    // update the dirty base textures\n    texture.baseTexture.dirty();\n};*/\n\n/**\n * Destroys a previous cached sprite.\n *\n */\n/*\nGraphics.prototype.destroyCachedSprite = function ()\n{\n    this._cachedSprite.texture.destroy(true);\n\n    // let the gc collect the unused sprite\n    // TODO could be object pooled!\n    this._cachedSprite = null;\n};*/\n\n/**\n * Draws the given shape to this Graphics object. Can be any of Circle, Rectangle, Ellipse, Line or Polygon.\n *\n * @param shape {Circle|Rectangle|Ellipse|Line|Polygon} The shape object to draw.\n * @return {GraphicsData} The generated GraphicsData object.\n */\nGraphics.prototype.drawShape = function (shape)\n{\n    if (this.currentPath)\n    {\n        // check current path!\n        if (this.currentPath.shape.points.length <= 2)\n        {\n            this.graphicsData.pop();\n        }\n    }\n\n    this.currentPath = null;\n\n    var data = new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, shape);\n\n    this.graphicsData.push(data);\n\n    if (data.type === CONST.SHAPES.POLY)\n    {\n        data.shape.closed = data.shape.closed || this.filling;\n        this.currentPath = data;\n    }\n\n    this.dirty = this.boundsDirty = true;\n\n    return data;\n};\n\nGraphics.prototype.destroy = function () {\n    Container.prototype.destroy.apply(this, arguments);\n\n    // destroy each of the GraphicsData objects\n    for (var i = 0; i < this.graphicsData.length; ++i) {\n        this.graphicsData[i].destroy();\n    }\n\n    // for each webgl data entry, destroy the WebGLGraphicsData\n    for (var id in this._webgl) {\n        for (var j = 0; j < this._webgl[id].data.length; ++j) {\n            this._webgl[id].data[j].destroy();\n        }\n    }\n\n    this.graphicsData = null;\n\n    this.currentPath = null;\n    this._webgl = null;\n    this._localBounds = null;\n};\n"]},"metadata":{},"sourceType":"script"}