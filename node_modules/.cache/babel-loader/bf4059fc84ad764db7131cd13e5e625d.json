{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport musicalScaleColors from 'musical-scale-colors';\nimport * as pixi from 'pixi.js';\nimport * as teoria from 'teoria';\npixi.utils._saidHello = true;\n/**\n * JavaScript 2D WebGL / Canvas animated piano roll\n * @module pixiPianoRoll\n * @author Matthew Hasbach\n * @copyright Matthew Hasbach 2015\n * @license MIT\n */\n\n/**\n * Playback position expressed in bars:quarters:sixteenths format (e.g. `\"1:2:0\"`)\n * @typedef {string} transportTime\n * @global\n */\n\n/**\n * Musical note expressed in [Scientific notation]{@link https://en.wikipedia.org/wiki/Scientific_pitch_notation}, [Helmholtz notation]{@link https://en.wikipedia.org/wiki/Helmholtz_pitch_notation}, [piano key number]{@link https://en.wikipedia.org/wiki/Piano_key_frequencies}, [audio frequency]{@link https://en.wikipedia.org/wiki/Audio_frequency} (the closest note will be used), or [MIDI]{@link https://en.wikipedia.org/wiki/MIDI} note number\n * @typedef {string|number} note\n * @global\n */\n\n/**\n * Note duration expressed as a number (e.g. `1` for a whole note) or string (e.g. `\"4n\"` for a quarter note)\n * @typedef {string|number} noteDuration\n * @global\n */\n\n/**\n * See the typedefs for [transportTime]{@link transportTime}, [note]{@link note}, and [noteDuration]{@link noteDuration}\n * @typedef {Array.<Array<transportTime, note, noteDuration>>} noteData\n * @global\n */\n\n/**\n * Instantiate a pixiPianoRoll\n * @alias module:pixiPianoRoll\n * @param {Object} opt - Options object\n * @param {number} [opt.width=900] - Width of the piano roll\n * @param {number} [opt.height=400] - Height of the piano roll\n * @param {number} [opt.pianoKeyWidth=125] - Width of the piano keys\n * @param {number|Object<number>} [opt.noteColor=musicalScaleColors.dDJameson] - Hexadecimal color of every note or object that has pitch class (chroma) property names and hexadecimal color values. See [musical-scale-colors]{@link https://github.com/mjhasbach/musical-scale-colors} for palettes (including the default).\n * @param {number} [opt.noteColor=0x333333] - Hexadecimal color of the grid lines\n * @param {number} [opt.noteColor=0] - Hexadecimal color of the background\n * @param {number} [opt.bpm=140] - Beats per minute\n * @param {boolean} [opt.activateKeys=true] - If true, the color of the piano keys will change to the color of the notes that intersect them\n * @param {boolean} [opt.antialias=true] - Whether or not the renderer will use antialiasing\n * @param {number} [opt.zoom=4] - Amount of visible measures\n * @param {number} [opt.resolution=1] - Amount of vertical grid lines per measure\n * @param {transportTime} [opt.time=0:0:0] - The [transportTime]{@link transportTime} at which playback will begin\n * @param {string} [opt.renderer=WebGLRenderer] - Determines the renderer type. Must be `\"WebGLRenderer\"` or `\"CanvasRenderer\"`.\n * @param {string} [opt.noteFormat=String] - The format of the [notes]{@link note} in `opt.noteData`. `\"String\"` for scientific or Helmholtz notation, `\"Key\"` for piano key numbers, `\"Frequency\"` for audio frequencies, or `\"MIDI\"` for MIDI note numbers.\n * @param {noteData} [opt.noteData=[]] - Note data\n * @returns {pianoRollAPI}\n * @example\nvar pianoRoll = pixiPianoRoll({\n    width: 900,\n    height: 400,\n    noteColor: 0xdb000f,\n    gridLineColor: 0x333333,\n    blackGridBgColor: 0x1e1e1e,\n    whiteGridBgColor: 0x282828,\n    bpm: 140,\n    antialias: true,\n    zoom: 4,\n    resolution: 2,\n    time: '0:0:0',\n    renderer: 'WebGLRenderer',\n    noteFormat: 'String',\n    noteData: [\n        ['0:0:0', 'C4', '2n'],\n        ['0:0:0', 'D4', '2n'],\n        ['0:0:0', 'E4', '2n'],\n        ['0:2:0', 'B4', '4n'],\n        ['0:3:0', 'A#4', '4n']\n    ]\n});\n\ndocument.getElementsByTagName('body')[0].appendChild(pianoRoll.view);\n\npianoRoll.playback.play();\n */\n\nfunction pixiPianoRoll(opt) {\n  var colors = {\n    blackKey: 0x000000,\n    whiteKey: 0xffffff,\n    blackGridBg: 0x1e1e1e,\n    whiteGridBg: 0x282828\n  };\n  opt = Object.assign({\n    width: 900,\n    height: 400,\n    pianoKeyWidth: 125,\n    noteColor: musicalScaleColors.dDJameson,\n    gridLineColor: 0x333333,\n    blackGridBgColor: colors.blackGridBg,\n    whiteGridBgColor: colors.whiteGridBg,\n    bpm: 140,\n    activateKeys: true,\n    antialias: true,\n    zoom: 4,\n    resolution: 1,\n    time: '0:0:0',\n    renderer: 'WebGLRenderer',\n    noteFormat: 'String',\n    noteData: []\n  }, opt);\n  var keys,\n      lastTime,\n      beatsPerMs,\n      pxMovementPerMs,\n      noteContainer,\n      noteRange,\n      noteRangeDiff,\n      noteHeight,\n      innerNoteHeight,\n      pianoContainer,\n      barWidth,\n      beatWidth,\n      sixteenthWidth,\n      gridLineWidth,\n      halfGridLineWidth,\n      gridLineSpacing,\n      activeKeys,\n      playing = false,\n      stage = new pixi.Container(),\n      rollContainer = new pixi.Container(),\n      gridlineContainers = {\n    main: new pixi.Container()\n  },\n      renderer = new pixi[opt.renderer](opt.width, opt.height, {\n    antialias: opt.antialias,\n    autoResize: true\n  });\n\n  function getTeoriaNote(note) {\n    var noteObj = teoria.note['from' + opt.noteFormat](note);\n    return opt.noteFormat === 'Frequency' ? noteObj.note : noteObj;\n  }\n\n  function getNoteRange() {\n    var min, max;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = opt.noteData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref3 = _step.value;\n\n        var _ref2 = _slicedToArray(_ref3, 2);\n\n        var note = _ref2[1];\n        var keyNumber = getTeoriaNote(note).key();\n\n        if (keyNumber < min || typeof min !== 'number') {\n          min = keyNumber;\n        }\n\n        if (keyNumber > max || typeof max !== 'number') {\n          max = keyNumber;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return {\n      min: min - 1,\n      max: max\n    };\n  }\n\n  function drawPianoKey(key, active) {\n    return (key.graphic || new pixi.Graphics()).clear().beginFill(active ? key.activeColor : key.color).lineStyle(key.color === colors.whiteKey ? noteHeight / 10 : 0, colors.blackKey).drawRect(0, key.y, key.width, key.height).endFill();\n  }\n\n  function drawPianoKeys() {\n    var whiteKeys = [],\n        blackKeys = [],\n        blackKeyWidth = opt.pianoKeyWidth / 1.575;\n    keys = {};\n    activeKeys = new Set();\n    stage.removeChild(pianoContainer);\n    pianoContainer = new pixi.Container();\n\n    for (var i = noteRange.min; i < noteRange.max + 2; i++) {\n      var y = opt.height + (noteRange.min - i) * noteHeight,\n          note = teoria.note.fromKey(i),\n          chroma = note.chroma(),\n          key = {\n        keyNumber: note.key(),\n        activeColor: typeof opt.noteColor === 'number' ? opt.noteColor : opt.noteColor[chroma]\n      };\n\n      if (new Set([0, 2, 4, 5, 7, 9, 11]).has(chroma)) {\n        whiteKeys.push(Object.assign(key, {\n          y: y + (new Set([4, 11]).has(chroma) ? 0 : -noteHeight / 2),\n          width: opt.pianoKeyWidth,\n          height: new Set([2, 7, 9]).has(chroma) ? noteHeight * 2 : noteHeight * 1.5,\n          color: colors.whiteKey\n        }));\n      } else {\n        blackKeys.push(Object.assign(key, {\n          y: y,\n          width: blackKeyWidth,\n          height: noteHeight,\n          color: colors.blackKey\n        }));\n      }\n    }\n\n    whiteKeys.concat(blackKeys).forEach(function (key) {\n      var pixiKey = drawPianoKey(key);\n      keys[key.keyNumber] = Object.assign(key, {\n        graphic: pixiKey\n      });\n      pianoContainer.addChild(pixiKey);\n    });\n    stage.addChild(pianoContainer);\n  }\n\n  function transportTimeToX(transportTime, isNote) {\n    if (!transportTime) {\n      return 0;\n    }\n\n    var _transportTime$split = transportTime.split(':'),\n        _transportTime$split2 = _slicedToArray(_transportTime$split, 3),\n        bar = _transportTime$split2[0],\n        _transportTime$split3 = _transportTime$split2[1],\n        quarter = _transportTime$split3 === void 0 ? 0 : _transportTime$split3,\n        _transportTime$split4 = _transportTime$split2[2],\n        sixteenth = _transportTime$split4 === void 0 ? 0 : _transportTime$split4,\n        x = barWidth * bar + beatWidth * quarter + sixteenthWidth * sixteenth;\n\n    return isNote ? x : opt.pianoKeyWidth - x;\n  }\n\n  function drawNotes() {\n    var oldContainer = rollContainer.removeChild(noteContainer);\n    noteContainer = new pixi.Container();\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = opt.noteData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _ref6 = _step2.value;\n\n        var _ref5 = _slicedToArray(_ref6, 3);\n\n        var transportTime = _ref5[0];\n        var note = _ref5[1];\n        var duration = _ref5[2];\n        var pixiNote = new pixi.Graphics(),\n            teoriaNote = getTeoriaNote(note),\n            keyNumber = teoriaNote.key(),\n            color = typeof opt.noteColor === 'number' ? opt.noteColor : opt.noteColor[teoriaNote.chroma()];\n        pixiNote.beginFill(color).drawRect(0, 0, barWidth / parseInt(duration), innerNoteHeight).endFill();\n        pixiNote.x = transportTimeToX(transportTime, true) + halfGridLineWidth;\n        pixiNote.y = opt.height - (keyNumber - noteRange.min) * noteHeight + halfGridLineWidth;\n        pixiNote.keyNumber = keyNumber;\n        noteContainer.addChild(pixiNote);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    noteContainer.x = oldContainer ? oldContainer.x : transportTimeToX(opt.time);\n    rollContainer.addChild(noteContainer);\n  }\n\n  function moveVerticalGridLines(horizontalMovement) {\n    var verticalGridlines = gridlineContainers.vertical.children;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = verticalGridlines[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _line = _step3.value;\n        _line.x -= horizontalMovement;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    if (verticalGridlines[0].x + gridLineWidth < opt.pianoKeyWidth) {\n      var line = gridlineContainers.vertical.removeChildAt(0);\n      line.x = verticalGridlines[verticalGridlines.length - 1].x + gridLineSpacing;\n      gridlineContainers.vertical.addChild(line);\n    }\n  }\n\n  function getFirstVerticalGridLineX(transportX) {\n    var x = transportX;\n\n    while (x + gridLineSpacing < opt.pianoKeyWidth) {\n      x += gridLineSpacing;\n    }\n\n    return x;\n  }\n\n  function drawGridlines(type) {\n    var i;\n\n    if (!type || type === 'horizontal') {\n      gridlineContainers.main.removeChild(gridlineContainers.horizontal);\n      gridlineContainers.horizontal = new pixi.Container();\n\n      for (i = 0; i < noteRangeDiff + 1; i++) {\n        gridlineContainers.horizontal.addChild(new pixi.Graphics().beginFill(opt.gridLineColor).drawRect(0, i * noteHeight - halfGridLineWidth, opt.width, gridLineWidth).endFill());\n        var noteChroma = teoria.note.fromKey(i + 3).chroma();\n\n        if (new Set([0, 2, 4, 5, 7, 9, 11]).has(noteChroma)) {\n          gridlineContainers.horizontal.addChild(new pixi.Graphics().beginFill(opt.whiteGridBgColor).drawRect(0, i * noteHeight + halfGridLineWidth, opt.width, noteHeight - gridLineWidth).endFill());\n        }\n      }\n\n      gridlineContainers.main.addChild(gridlineContainers.horizontal);\n    }\n\n    if (!type || type === 'vertical') {\n      var offset = getFirstVerticalGridLineX(noteContainer ? noteContainer.x : transportTimeToX(opt.time));\n      gridlineContainers.main.removeChild(gridlineContainers.vertical);\n      gridlineContainers.vertical = new pixi.Container();\n\n      for (i = 0; i < opt.zoom * opt.resolution + 1; i++) {\n        var line = new pixi.Graphics().beginFill(opt.gridLineColor).drawRect(0, 0, gridLineWidth, opt.height).endFill();\n        line.x = offset + i * gridLineSpacing - halfGridLineWidth;\n        gridlineContainers.vertical.addChild(line);\n      }\n\n      gridlineContainers.main.addChild(gridlineContainers.vertical);\n    }\n\n    rollContainer.addChild(gridlineContainers.main);\n  }\n\n  function activateKeys() {\n    if (!opt.activateKeys) {\n      return;\n    }\n\n    var intersectedKeys = new Set();\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = noteContainer.children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var note = _step4.value;\n\n        if (note.containsPoint(new pixi.Point(opt.pianoKeyWidth, note.y))) {\n          intersectedKeys.add(note.keyNumber);\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = intersectedKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var intersectedKey = _step5.value;\n\n        if (!activeKeys.has(intersectedKey)) {\n          var key = keys[intersectedKey];\n          drawPianoKey(key, true);\n          activeKeys.add(intersectedKey);\n        }\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = activeKeys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var activeKey = _step6.value;\n\n        if (!intersectedKeys.has(activeKey)) {\n          var _key = keys[activeKey];\n          drawPianoKey(_key);\n          activeKeys.delete(activeKey);\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  }\n\n  function animate(frameTime) {\n    if (!lastTime) {\n      lastTime = frameTime;\n    }\n\n    var timeDiff = frameTime - lastTime,\n        horizontalMovement = timeDiff * pxMovementPerMs;\n    noteContainer.x = noteContainer.x - horizontalMovement;\n    moveVerticalGridLines(horizontalMovement);\n    activateKeys();\n    lastTime = frameTime;\n    renderer.render(stage);\n    playing ? requestAnimationFrame(animate) : lastTime = null;\n  }\n\n  function calculate() {\n    noteRange = getNoteRange(opt.noteData);\n    noteRangeDiff = noteRange.max - noteRange.min;\n    barWidth = (opt.width - opt.pianoKeyWidth) / opt.zoom;\n    beatWidth = (opt.width - opt.pianoKeyWidth) / (opt.zoom * 4);\n    sixteenthWidth = beatWidth / 4;\n    gridLineWidth = barWidth / 100;\n    halfGridLineWidth = gridLineWidth / 2;\n    gridLineSpacing = barWidth / opt.resolution;\n    beatsPerMs = opt.bpm / 60 / 1000;\n    pxMovementPerMs = beatWidth * beatsPerMs;\n    noteHeight = opt.height / noteRangeDiff;\n    innerNoteHeight = noteHeight - gridLineWidth;\n  }\n\n  (function init() {\n    stage.addChild(rollContainer);\n    calculate();\n    drawGridlines();\n    drawNotes();\n    drawPianoKeys();\n    renderer.backgroundColor = opt.blackGridBgColor;\n    renderer.render(stage);\n  })();\n  /**\n   * The piano roll API\n   * @typedef pianoRollAPI\n   * @type {Object}\n   * @global\n   */\n\n\n  var pianoRollAPI = {\n    /**\n     * Contains methods that control playback\n     * @memberof pianoRollAPI\n     * @type {Object}\n     */\n    playback: {\n      /**\n       * Pause if playing or play if paused\n       * @param {transportTime} [time] - If paused, the position to begin playing. If omitted, playback will begin at the current position.\n       */\n      toggle: function toggle(time) {\n        playing ? pianoRollAPI.playback.pause() : pianoRollAPI.playback.play(time);\n      },\n\n      /**\n       * Begin playback\n       * @param {transportTime} [time] - The position to begin playing. If omitted, playback will begin at the current position.\n       */\n      play: function play(time) {\n        if (!playing) {\n          if (time) {\n            pianoRollAPI.playback.seek(time);\n          }\n\n          playing = true;\n          requestAnimationFrame(animate);\n        }\n      },\n\n      /**\n       * Pause playback\n       */\n      pause: function pause() {\n        playing = false;\n      },\n\n      /**\n       * Change the playback position\n       * @param {transportTime} time - The new playback position\n       */\n      seek: function seek(time) {\n        opt.time = time;\n        noteContainer.x = transportTimeToX(time);\n        drawGridlines('vertical');\n        rollContainer.addChild(rollContainer.removeChild(noteContainer));\n        renderer.render(stage);\n      }\n    },\n\n    /**\n     * Change the bpm by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set bpm(bpm) {\n      opt.bpm = bpm;\n      calculate();\n    },\n\n    /**\n     * Change the zoom by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set zoom(zoom) {\n      opt.zoom = zoom;\n      calculate();\n      drawGridlines();\n      drawNotes();\n      renderer.render(stage);\n    },\n\n    /**\n     * Change the resolution by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set resolution(resolution) {\n      opt.resolution = resolution;\n      calculate();\n      drawGridlines('vertical');\n      rollContainer.addChild(rollContainer.removeChild(noteContainer));\n      renderer.render(stage);\n    },\n\n    /**\n     * Change the note data by changing this property\n     * @memberof pianoRollAPI\n     * @type {noteData}\n     */\n    set noteData(noteData) {\n      opt.noteData = noteData;\n      calculate();\n      drawGridlines('horizontal');\n      drawNotes();\n      drawPianoKeys();\n      renderer.render(stage);\n    },\n\n    /**\n     * Whether or not playback is ongoing\n     * @memberof pianoRollAPI\n     * @type {boolean}\n     * @readonly\n     */\n    get playing() {\n      return playing;\n    },\n\n    /**\n     * The piano roll canvas element\n     * @memberof pianoRollAPI\n     * @type {HTMLElement}\n     * @readonly\n     */\n    get view() {\n      return renderer.view;\n    }\n\n  };\n  return pianoRollAPI;\n}\n\nexport default pixiPianoRoll;","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/react-piano-roll/dist/pixiPianoRoll.js"],"names":["_slicedToArray","musicalScaleColors","pixi","teoria","utils","_saidHello","pixiPianoRoll","opt","colors","blackKey","whiteKey","blackGridBg","whiteGridBg","Object","assign","width","height","pianoKeyWidth","noteColor","dDJameson","gridLineColor","blackGridBgColor","whiteGridBgColor","bpm","activateKeys","antialias","zoom","resolution","time","renderer","noteFormat","noteData","keys","lastTime","beatsPerMs","pxMovementPerMs","noteContainer","noteRange","noteRangeDiff","noteHeight","innerNoteHeight","pianoContainer","barWidth","beatWidth","sixteenthWidth","gridLineWidth","halfGridLineWidth","gridLineSpacing","activeKeys","playing","stage","Container","rollContainer","gridlineContainers","main","autoResize","getTeoriaNote","note","noteObj","getNoteRange","min","max","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_iterator","Symbol","iterator","_step","next","done","_ref3","value","_ref2","keyNumber","key","err","return","drawPianoKey","active","graphic","Graphics","clear","beginFill","activeColor","color","lineStyle","drawRect","y","endFill","drawPianoKeys","whiteKeys","blackKeys","blackKeyWidth","Set","removeChild","i","fromKey","chroma","has","push","concat","forEach","pixiKey","addChild","transportTimeToX","transportTime","isNote","_transportTime$split","split","_transportTime$split2","bar","_transportTime$split3","quarter","_transportTime$split4","sixteenth","x","drawNotes","oldContainer","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_iterator2","_step2","_ref6","_ref5","duration","pixiNote","teoriaNote","parseInt","moveVerticalGridLines","horizontalMovement","verticalGridlines","vertical","children","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_iterator3","_step3","_line","line","removeChildAt","length","getFirstVerticalGridLineX","transportX","drawGridlines","type","horizontal","noteChroma","offset","intersectedKeys","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_iterator4","_step4","containsPoint","Point","add","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_iterator5","_step5","intersectedKey","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_iterator6","_step6","activeKey","_key","delete","animate","frameTime","timeDiff","render","requestAnimationFrame","calculate","init","backgroundColor","pianoRollAPI","playback","toggle","pause","play","seek","view"],"mappings":"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","sourcesContent":["import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport musicalScaleColors from 'musical-scale-colors';\nimport * as pixi from 'pixi.js';\nimport * as teoria from 'teoria';\npixi.utils._saidHello = true;\n/**\n * JavaScript 2D WebGL / Canvas animated piano roll\n * @module pixiPianoRoll\n * @author Matthew Hasbach\n * @copyright Matthew Hasbach 2015\n * @license MIT\n */\n\n/**\n * Playback position expressed in bars:quarters:sixteenths format (e.g. `\"1:2:0\"`)\n * @typedef {string} transportTime\n * @global\n */\n\n/**\n * Musical note expressed in [Scientific notation]{@link https://en.wikipedia.org/wiki/Scientific_pitch_notation}, [Helmholtz notation]{@link https://en.wikipedia.org/wiki/Helmholtz_pitch_notation}, [piano key number]{@link https://en.wikipedia.org/wiki/Piano_key_frequencies}, [audio frequency]{@link https://en.wikipedia.org/wiki/Audio_frequency} (the closest note will be used), or [MIDI]{@link https://en.wikipedia.org/wiki/MIDI} note number\n * @typedef {string|number} note\n * @global\n */\n\n/**\n * Note duration expressed as a number (e.g. `1` for a whole note) or string (e.g. `\"4n\"` for a quarter note)\n * @typedef {string|number} noteDuration\n * @global\n */\n\n/**\n * See the typedefs for [transportTime]{@link transportTime}, [note]{@link note}, and [noteDuration]{@link noteDuration}\n * @typedef {Array.<Array<transportTime, note, noteDuration>>} noteData\n * @global\n */\n\n/**\n * Instantiate a pixiPianoRoll\n * @alias module:pixiPianoRoll\n * @param {Object} opt - Options object\n * @param {number} [opt.width=900] - Width of the piano roll\n * @param {number} [opt.height=400] - Height of the piano roll\n * @param {number} [opt.pianoKeyWidth=125] - Width of the piano keys\n * @param {number|Object<number>} [opt.noteColor=musicalScaleColors.dDJameson] - Hexadecimal color of every note or object that has pitch class (chroma) property names and hexadecimal color values. See [musical-scale-colors]{@link https://github.com/mjhasbach/musical-scale-colors} for palettes (including the default).\n * @param {number} [opt.noteColor=0x333333] - Hexadecimal color of the grid lines\n * @param {number} [opt.noteColor=0] - Hexadecimal color of the background\n * @param {number} [opt.bpm=140] - Beats per minute\n * @param {boolean} [opt.activateKeys=true] - If true, the color of the piano keys will change to the color of the notes that intersect them\n * @param {boolean} [opt.antialias=true] - Whether or not the renderer will use antialiasing\n * @param {number} [opt.zoom=4] - Amount of visible measures\n * @param {number} [opt.resolution=1] - Amount of vertical grid lines per measure\n * @param {transportTime} [opt.time=0:0:0] - The [transportTime]{@link transportTime} at which playback will begin\n * @param {string} [opt.renderer=WebGLRenderer] - Determines the renderer type. Must be `\"WebGLRenderer\"` or `\"CanvasRenderer\"`.\n * @param {string} [opt.noteFormat=String] - The format of the [notes]{@link note} in `opt.noteData`. `\"String\"` for scientific or Helmholtz notation, `\"Key\"` for piano key numbers, `\"Frequency\"` for audio frequencies, or `\"MIDI\"` for MIDI note numbers.\n * @param {noteData} [opt.noteData=[]] - Note data\n * @returns {pianoRollAPI}\n * @example\nvar pianoRoll = pixiPianoRoll({\n    width: 900,\n    height: 400,\n    noteColor: 0xdb000f,\n    gridLineColor: 0x333333,\n    blackGridBgColor: 0x1e1e1e,\n    whiteGridBgColor: 0x282828,\n    bpm: 140,\n    antialias: true,\n    zoom: 4,\n    resolution: 2,\n    time: '0:0:0',\n    renderer: 'WebGLRenderer',\n    noteFormat: 'String',\n    noteData: [\n        ['0:0:0', 'C4', '2n'],\n        ['0:0:0', 'D4', '2n'],\n        ['0:0:0', 'E4', '2n'],\n        ['0:2:0', 'B4', '4n'],\n        ['0:3:0', 'A#4', '4n']\n    ]\n});\n\ndocument.getElementsByTagName('body')[0].appendChild(pianoRoll.view);\n\npianoRoll.playback.play();\n */\n\nfunction pixiPianoRoll(opt) {\n  var colors = {\n    blackKey: 0x000000,\n    whiteKey: 0xffffff,\n    blackGridBg: 0x1e1e1e,\n    whiteGridBg: 0x282828\n  };\n  opt = Object.assign({\n    width: 900,\n    height: 400,\n    pianoKeyWidth: 125,\n    noteColor: musicalScaleColors.dDJameson,\n    gridLineColor: 0x333333,\n    blackGridBgColor: colors.blackGridBg,\n    whiteGridBgColor: colors.whiteGridBg,\n    bpm: 140,\n    activateKeys: true,\n    antialias: true,\n    zoom: 4,\n    resolution: 1,\n    time: '0:0:0',\n    renderer: 'WebGLRenderer',\n    noteFormat: 'String',\n    noteData: []\n  }, opt);\n  var keys,\n      lastTime,\n      beatsPerMs,\n      pxMovementPerMs,\n      noteContainer,\n      noteRange,\n      noteRangeDiff,\n      noteHeight,\n      innerNoteHeight,\n      pianoContainer,\n      barWidth,\n      beatWidth,\n      sixteenthWidth,\n      gridLineWidth,\n      halfGridLineWidth,\n      gridLineSpacing,\n      activeKeys,\n      playing = false,\n      stage = new pixi.Container(),\n      rollContainer = new pixi.Container(),\n      gridlineContainers = {\n    main: new pixi.Container()\n  },\n      renderer = new pixi[opt.renderer](opt.width, opt.height, {\n    antialias: opt.antialias,\n    autoResize: true\n  });\n\n  function getTeoriaNote(note) {\n    var noteObj = teoria.note['from' + opt.noteFormat](note);\n    return opt.noteFormat === 'Frequency' ? noteObj.note : noteObj;\n  }\n\n  function getNoteRange() {\n    var min, max;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = opt.noteData[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var _ref3 = _step.value;\n\n        var _ref2 = _slicedToArray(_ref3, 2);\n\n        var note = _ref2[1];\n        var keyNumber = getTeoriaNote(note).key();\n\n        if (keyNumber < min || typeof min !== 'number') {\n          min = keyNumber;\n        }\n\n        if (keyNumber > max || typeof max !== 'number') {\n          max = keyNumber;\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return {\n      min: min - 1,\n      max: max\n    };\n  }\n\n  function drawPianoKey(key, active) {\n    return (key.graphic || new pixi.Graphics()).clear().beginFill(active ? key.activeColor : key.color).lineStyle(key.color === colors.whiteKey ? noteHeight / 10 : 0, colors.blackKey).drawRect(0, key.y, key.width, key.height).endFill();\n  }\n\n  function drawPianoKeys() {\n    var whiteKeys = [],\n        blackKeys = [],\n        blackKeyWidth = opt.pianoKeyWidth / 1.575;\n    keys = {};\n    activeKeys = new Set();\n    stage.removeChild(pianoContainer);\n    pianoContainer = new pixi.Container();\n\n    for (var i = noteRange.min; i < noteRange.max + 2; i++) {\n      var y = opt.height + (noteRange.min - i) * noteHeight,\n          note = teoria.note.fromKey(i),\n          chroma = note.chroma(),\n          key = {\n        keyNumber: note.key(),\n        activeColor: typeof opt.noteColor === 'number' ? opt.noteColor : opt.noteColor[chroma]\n      };\n\n      if (new Set([0, 2, 4, 5, 7, 9, 11]).has(chroma)) {\n        whiteKeys.push(Object.assign(key, {\n          y: y + (new Set([4, 11]).has(chroma) ? 0 : -noteHeight / 2),\n          width: opt.pianoKeyWidth,\n          height: new Set([2, 7, 9]).has(chroma) ? noteHeight * 2 : noteHeight * 1.5,\n          color: colors.whiteKey\n        }));\n      } else {\n        blackKeys.push(Object.assign(key, {\n          y: y,\n          width: blackKeyWidth,\n          height: noteHeight,\n          color: colors.blackKey\n        }));\n      }\n    }\n\n    whiteKeys.concat(blackKeys).forEach(function (key) {\n      var pixiKey = drawPianoKey(key);\n      keys[key.keyNumber] = Object.assign(key, {\n        graphic: pixiKey\n      });\n      pianoContainer.addChild(pixiKey);\n    });\n    stage.addChild(pianoContainer);\n  }\n\n  function transportTimeToX(transportTime, isNote) {\n    if (!transportTime) {\n      return 0;\n    }\n\n    var _transportTime$split = transportTime.split(':'),\n        _transportTime$split2 = _slicedToArray(_transportTime$split, 3),\n        bar = _transportTime$split2[0],\n        _transportTime$split3 = _transportTime$split2[1],\n        quarter = _transportTime$split3 === void 0 ? 0 : _transportTime$split3,\n        _transportTime$split4 = _transportTime$split2[2],\n        sixteenth = _transportTime$split4 === void 0 ? 0 : _transportTime$split4,\n        x = barWidth * bar + beatWidth * quarter + sixteenthWidth * sixteenth;\n\n    return isNote ? x : opt.pianoKeyWidth - x;\n  }\n\n  function drawNotes() {\n    var oldContainer = rollContainer.removeChild(noteContainer);\n    noteContainer = new pixi.Container();\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = opt.noteData[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _ref6 = _step2.value;\n\n        var _ref5 = _slicedToArray(_ref6, 3);\n\n        var transportTime = _ref5[0];\n        var note = _ref5[1];\n        var duration = _ref5[2];\n        var pixiNote = new pixi.Graphics(),\n            teoriaNote = getTeoriaNote(note),\n            keyNumber = teoriaNote.key(),\n            color = typeof opt.noteColor === 'number' ? opt.noteColor : opt.noteColor[teoriaNote.chroma()];\n        pixiNote.beginFill(color).drawRect(0, 0, barWidth / parseInt(duration), innerNoteHeight).endFill();\n        pixiNote.x = transportTimeToX(transportTime, true) + halfGridLineWidth;\n        pixiNote.y = opt.height - (keyNumber - noteRange.min) * noteHeight + halfGridLineWidth;\n        pixiNote.keyNumber = keyNumber;\n        noteContainer.addChild(pixiNote);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    noteContainer.x = oldContainer ? oldContainer.x : transportTimeToX(opt.time);\n    rollContainer.addChild(noteContainer);\n  }\n\n  function moveVerticalGridLines(horizontalMovement) {\n    var verticalGridlines = gridlineContainers.vertical.children;\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = verticalGridlines[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var _line = _step3.value;\n        _line.x -= horizontalMovement;\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    if (verticalGridlines[0].x + gridLineWidth < opt.pianoKeyWidth) {\n      var line = gridlineContainers.vertical.removeChildAt(0);\n      line.x = verticalGridlines[verticalGridlines.length - 1].x + gridLineSpacing;\n      gridlineContainers.vertical.addChild(line);\n    }\n  }\n\n  function getFirstVerticalGridLineX(transportX) {\n    var x = transportX;\n\n    while (x + gridLineSpacing < opt.pianoKeyWidth) {\n      x += gridLineSpacing;\n    }\n\n    return x;\n  }\n\n  function drawGridlines(type) {\n    var i;\n\n    if (!type || type === 'horizontal') {\n      gridlineContainers.main.removeChild(gridlineContainers.horizontal);\n      gridlineContainers.horizontal = new pixi.Container();\n\n      for (i = 0; i < noteRangeDiff + 1; i++) {\n        gridlineContainers.horizontal.addChild(new pixi.Graphics().beginFill(opt.gridLineColor).drawRect(0, i * noteHeight - halfGridLineWidth, opt.width, gridLineWidth).endFill());\n        var noteChroma = teoria.note.fromKey(i + 3).chroma();\n\n        if (new Set([0, 2, 4, 5, 7, 9, 11]).has(noteChroma)) {\n          gridlineContainers.horizontal.addChild(new pixi.Graphics().beginFill(opt.whiteGridBgColor).drawRect(0, i * noteHeight + halfGridLineWidth, opt.width, noteHeight - gridLineWidth).endFill());\n        }\n      }\n\n      gridlineContainers.main.addChild(gridlineContainers.horizontal);\n    }\n\n    if (!type || type === 'vertical') {\n      var offset = getFirstVerticalGridLineX(noteContainer ? noteContainer.x : transportTimeToX(opt.time));\n      gridlineContainers.main.removeChild(gridlineContainers.vertical);\n      gridlineContainers.vertical = new pixi.Container();\n\n      for (i = 0; i < opt.zoom * opt.resolution + 1; i++) {\n        var line = new pixi.Graphics().beginFill(opt.gridLineColor).drawRect(0, 0, gridLineWidth, opt.height).endFill();\n        line.x = offset + i * gridLineSpacing - halfGridLineWidth;\n        gridlineContainers.vertical.addChild(line);\n      }\n\n      gridlineContainers.main.addChild(gridlineContainers.vertical);\n    }\n\n    rollContainer.addChild(gridlineContainers.main);\n  }\n\n  function activateKeys() {\n    if (!opt.activateKeys) {\n      return;\n    }\n\n    var intersectedKeys = new Set();\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = noteContainer.children[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var note = _step4.value;\n\n        if (note.containsPoint(new pixi.Point(opt.pianoKeyWidth, note.y))) {\n          intersectedKeys.add(note.keyNumber);\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion5 = true;\n    var _didIteratorError5 = false;\n    var _iteratorError5 = undefined;\n\n    try {\n      for (var _iterator5 = intersectedKeys[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n        var intersectedKey = _step5.value;\n\n        if (!activeKeys.has(intersectedKey)) {\n          var key = keys[intersectedKey];\n          drawPianoKey(key, true);\n          activeKeys.add(intersectedKey);\n        }\n      }\n    } catch (err) {\n      _didIteratorError5 = true;\n      _iteratorError5 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion5 && _iterator5.return != null) {\n          _iterator5.return();\n        }\n      } finally {\n        if (_didIteratorError5) {\n          throw _iteratorError5;\n        }\n      }\n    }\n\n    var _iteratorNormalCompletion6 = true;\n    var _didIteratorError6 = false;\n    var _iteratorError6 = undefined;\n\n    try {\n      for (var _iterator6 = activeKeys[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n        var activeKey = _step6.value;\n\n        if (!intersectedKeys.has(activeKey)) {\n          var _key = keys[activeKey];\n          drawPianoKey(_key);\n          activeKeys.delete(activeKey);\n        }\n      }\n    } catch (err) {\n      _didIteratorError6 = true;\n      _iteratorError6 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion6 && _iterator6.return != null) {\n          _iterator6.return();\n        }\n      } finally {\n        if (_didIteratorError6) {\n          throw _iteratorError6;\n        }\n      }\n    }\n  }\n\n  function animate(frameTime) {\n    if (!lastTime) {\n      lastTime = frameTime;\n    }\n\n    var timeDiff = frameTime - lastTime,\n        horizontalMovement = timeDiff * pxMovementPerMs;\n    noteContainer.x = noteContainer.x - horizontalMovement;\n    moveVerticalGridLines(horizontalMovement);\n    activateKeys();\n    lastTime = frameTime;\n    renderer.render(stage);\n    playing ? requestAnimationFrame(animate) : lastTime = null;\n  }\n\n  function calculate() {\n    noteRange = getNoteRange(opt.noteData);\n    noteRangeDiff = noteRange.max - noteRange.min;\n    barWidth = (opt.width - opt.pianoKeyWidth) / opt.zoom;\n    beatWidth = (opt.width - opt.pianoKeyWidth) / (opt.zoom * 4);\n    sixteenthWidth = beatWidth / 4;\n    gridLineWidth = barWidth / 100;\n    halfGridLineWidth = gridLineWidth / 2;\n    gridLineSpacing = barWidth / opt.resolution;\n    beatsPerMs = opt.bpm / 60 / 1000;\n    pxMovementPerMs = beatWidth * beatsPerMs;\n    noteHeight = opt.height / noteRangeDiff;\n    innerNoteHeight = noteHeight - gridLineWidth;\n  }\n\n  (function init() {\n    stage.addChild(rollContainer);\n    calculate();\n    drawGridlines();\n    drawNotes();\n    drawPianoKeys();\n    renderer.backgroundColor = opt.blackGridBgColor;\n    renderer.render(stage);\n  })();\n  /**\n   * The piano roll API\n   * @typedef pianoRollAPI\n   * @type {Object}\n   * @global\n   */\n\n\n  var pianoRollAPI = {\n    /**\n     * Contains methods that control playback\n     * @memberof pianoRollAPI\n     * @type {Object}\n     */\n    playback: {\n      /**\n       * Pause if playing or play if paused\n       * @param {transportTime} [time] - If paused, the position to begin playing. If omitted, playback will begin at the current position.\n       */\n      toggle: function toggle(time) {\n        playing ? pianoRollAPI.playback.pause() : pianoRollAPI.playback.play(time);\n      },\n\n      /**\n       * Begin playback\n       * @param {transportTime} [time] - The position to begin playing. If omitted, playback will begin at the current position.\n       */\n      play: function play(time) {\n        if (!playing) {\n          if (time) {\n            pianoRollAPI.playback.seek(time);\n          }\n\n          playing = true;\n          requestAnimationFrame(animate);\n        }\n      },\n\n      /**\n       * Pause playback\n       */\n      pause: function pause() {\n        playing = false;\n      },\n\n      /**\n       * Change the playback position\n       * @param {transportTime} time - The new playback position\n       */\n      seek: function seek(time) {\n        opt.time = time;\n        noteContainer.x = transportTimeToX(time);\n        drawGridlines('vertical');\n        rollContainer.addChild(rollContainer.removeChild(noteContainer));\n        renderer.render(stage);\n      }\n    },\n\n    /**\n     * Change the bpm by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set bpm(bpm) {\n      opt.bpm = bpm;\n      calculate();\n    },\n\n    /**\n     * Change the zoom by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set zoom(zoom) {\n      opt.zoom = zoom;\n      calculate();\n      drawGridlines();\n      drawNotes();\n      renderer.render(stage);\n    },\n\n    /**\n     * Change the resolution by changing this property\n     * @memberof pianoRollAPI\n     * @type {number}\n     */\n    set resolution(resolution) {\n      opt.resolution = resolution;\n      calculate();\n      drawGridlines('vertical');\n      rollContainer.addChild(rollContainer.removeChild(noteContainer));\n      renderer.render(stage);\n    },\n\n    /**\n     * Change the note data by changing this property\n     * @memberof pianoRollAPI\n     * @type {noteData}\n     */\n    set noteData(noteData) {\n      opt.noteData = noteData;\n      calculate();\n      drawGridlines('horizontal');\n      drawNotes();\n      drawPianoKeys();\n      renderer.render(stage);\n    },\n\n    /**\n     * Whether or not playback is ongoing\n     * @memberof pianoRollAPI\n     * @type {boolean}\n     * @readonly\n     */\n    get playing() {\n      return playing;\n    },\n\n    /**\n     * The piano roll canvas element\n     * @memberof pianoRollAPI\n     * @type {HTMLElement}\n     * @readonly\n     */\n    get view() {\n      return renderer.view;\n    }\n\n  };\n  return pianoRollAPI;\n}\n\nexport default pixiPianoRoll;"]},"metadata":{},"sourceType":"module"}