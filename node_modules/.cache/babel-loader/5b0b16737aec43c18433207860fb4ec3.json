{"ast":null,"code":"import _regeneratorRuntime from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { __awaiter } from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\n\nexport var Reverb = /*#__PURE__*/function (_Effect) {\n  _inherits(Reverb, _Effect);\n\n  var _super = _createSuper(Reverb);\n\n  function Reverb() {\n    var _this;\n\n    _classCallCheck(this, Reverb);\n\n    _this = _super.call(this, optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n    _this.name = \"Reverb\";\n    /**\n     * Convolver node\n     */\n\n    _this._convolver = _this.context.createConvolver();\n    /**\n     * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n     * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n     * before the IR is generated with the latest values.\n     */\n\n    _this.ready = Promise.resolve();\n    var options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n    _this._decay = options.decay;\n    _this._preDelay = options.preDelay;\n\n    _this.generate();\n\n    _this.connectEffect(_this._convolver);\n\n    return _this;\n  }\n\n  _createClass(Reverb, [{\n    key: \"generate\",\n\n    /**\n     * Generate the Impulse Response. Returns a promise while the IR is being generated.\n     * @return Promise which returns this object.\n     */\n    value: function generate() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var previousReady, context, noiseL, noiseR, merge, gainNode, renderPromise;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                previousReady = this.ready; // create a noise burst which decays over the duration in each channel\n\n                context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n                noiseL = new Noise({\n                  context: context\n                });\n                noiseR = new Noise({\n                  context: context\n                });\n                merge = new Merge({\n                  context: context\n                });\n                noiseL.connect(merge, 0, 0);\n                noiseR.connect(merge, 0, 1);\n                gainNode = new Gain({\n                  context: context\n                }).toDestination();\n                merge.connect(gainNode);\n                noiseL.start(0);\n                noiseR.start(0); // predelay\n\n                gainNode.gain.setValueAtTime(0, 0);\n                gainNode.gain.setValueAtTime(1, this._preDelay); // decay\n\n                gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay); // render the buffer\n\n                renderPromise = context.render();\n                this.ready = renderPromise.then(noOp); // wait for the previous `ready` to resolve\n\n                _context.next = 18;\n                return previousReady;\n\n              case 18:\n                _context.next = 20;\n                return renderPromise;\n\n              case 20:\n                this._convolver.buffer = _context.sent.get();\n                return _context.abrupt(\"return\", this);\n\n              case 22:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Reverb.prototype), \"dispose\", this).call(this);\n\n      this._convolver.disconnect();\n\n      return this;\n    }\n  }, {\n    key: \"decay\",\n\n    /**\n     * The duration of the reverb.\n     */\n    get: function get() {\n      return this._decay;\n    },\n    set: function set(time) {\n      time = this.toSeconds(time);\n      assertRange(time, 0.001);\n      this._decay = time;\n      this.generate();\n    }\n    /**\n     * The amount of time before the reverb is fully ramped in.\n     */\n\n  }, {\n    key: \"preDelay\",\n    get: function get() {\n      return this._preDelay;\n    },\n    set: function set(time) {\n      time = this.toSeconds(time);\n      assertRange(time, 0);\n      this._preDelay = time;\n      this.generate();\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Effect.getDefaults(), {\n        decay: 1.5,\n        preDelay: 0.01\n      });\n    }\n  }]);\n\n  return Reverb;\n}(Effect);","map":{"version":3,"sources":["../../../Tone/effect/Reverb.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { __awaiter } from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\nexport class Reverb extends Effect {\n    constructor() {\n        super(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n        this.name = \"Reverb\";\n        /**\n         * Convolver node\n         */\n        this._convolver = this.context.createConvolver();\n        /**\n         * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n         * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n         * before the IR is generated with the latest values.\n         */\n        this.ready = Promise.resolve();\n        const options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n        this._decay = options.decay;\n        this._preDelay = options.preDelay;\n        this.generate();\n        this.connectEffect(this._convolver);\n    }\n    static getDefaults() {\n        return Object.assign(Effect.getDefaults(), {\n            decay: 1.5,\n            preDelay: 0.01,\n        });\n    }\n    /**\n     * The duration of the reverb.\n     */\n    get decay() {\n        return this._decay;\n    }\n    set decay(time) {\n        time = this.toSeconds(time);\n        assertRange(time, 0.001);\n        this._decay = time;\n        this.generate();\n    }\n    /**\n     * The amount of time before the reverb is fully ramped in.\n     */\n    get preDelay() {\n        return this._preDelay;\n    }\n    set preDelay(time) {\n        time = this.toSeconds(time);\n        assertRange(time, 0);\n        this._preDelay = time;\n        this.generate();\n    }\n    /**\n     * Generate the Impulse Response. Returns a promise while the IR is being generated.\n     * @return Promise which returns this object.\n     */\n    generate() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const previousReady = this.ready;\n            // create a noise burst which decays over the duration in each channel\n            const context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n            const noiseL = new Noise({ context });\n            const noiseR = new Noise({ context });\n            const merge = new Merge({ context });\n            noiseL.connect(merge, 0, 0);\n            noiseR.connect(merge, 0, 1);\n            const gainNode = new Gain({ context }).toDestination();\n            merge.connect(gainNode);\n            noiseL.start(0);\n            noiseR.start(0);\n            // predelay\n            gainNode.gain.setValueAtTime(0, 0);\n            gainNode.gain.setValueAtTime(1, this._preDelay);\n            // decay\n            gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n            // render the buffer\n            const renderPromise = context.render();\n            this.ready = renderPromise.then(noOp);\n            // wait for the previous `ready` to resolve\n            yield previousReady;\n            // set the buffer\n            this._convolver.buffer = (yield renderPromise).get();\n            return this;\n        });\n    }\n    dispose() {\n        super.dispose();\n        this._convolver.disconnect();\n        return this;\n    }\n}\n//# sourceMappingURL=Reverb.js.map"]},"metadata":{},"sourceType":"module"}