{"ast":null,"code":"/* eslint no-magic-numbers: 0 */\n'use strict';\n\nmodule.exports = {\n  // private property\n  _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n  encodeBinary: function (input) {\n    var output = '';\n    var bytebuffer;\n    var encodedCharIndexes = new Array(4);\n    var inx = 0;\n    var jnx = 0;\n    var paddingBytes = 0;\n\n    while (inx < input.length) {\n      // Fill byte buffer array\n      bytebuffer = new Array(3);\n\n      for (jnx = 0; jnx < bytebuffer.length; jnx++) {\n        if (inx < input.length) {\n          // throw away high-order byte, as documented at:\n          // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n          bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n        } else {\n          bytebuffer[jnx] = 0;\n        }\n      } // Get each encoded character, 6 bits at a time\n      // index 1: first 6 bits\n\n\n      encodedCharIndexes[0] = bytebuffer[0] >> 2; // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n\n      encodedCharIndexes[1] = (bytebuffer[0] & 0x3) << 4 | bytebuffer[1] >> 4; // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n\n      encodedCharIndexes[2] = (bytebuffer[1] & 0x0f) << 2 | bytebuffer[2] >> 6; // index 3: forth 6 bits (6 least significant bits from input byte 3)\n\n      encodedCharIndexes[3] = bytebuffer[2] & 0x3f; // Determine whether padding happened, and adjust accordingly\n\n      paddingBytes = inx - (input.length - 1);\n\n      switch (paddingBytes) {\n        case 2:\n          // Set last 2 characters to padding char\n          encodedCharIndexes[3] = 64;\n          encodedCharIndexes[2] = 64;\n          break;\n\n        case 1:\n          // Set last character to padding char\n          encodedCharIndexes[3] = 64;\n          break;\n\n        default:\n          break;\n        // No padding - proceed\n      } // Now we will grab each appropriate character out of our keystring\n      // based on our index array and append it to the output string\n\n\n      for (jnx = 0; jnx < encodedCharIndexes.length; jnx++) {\n        output += this._keyStr.charAt(encodedCharIndexes[jnx]);\n      }\n    }\n\n    return output;\n  }\n};","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/resource-loader/src/b64.js"],"names":["module","exports","_keyStr","encodeBinary","input","output","bytebuffer","encodedCharIndexes","Array","inx","jnx","paddingBytes","length","charCodeAt","charAt"],"mappings":"AAAA;AACA;;AAEAA,MAAM,CAACC,OAAP,GAAiB;AACb;AACAC,EAAAA,OAAO,EAAE,mEAFI;AAIbC,EAAAA,YAAY,EAAE,UAAUC,KAAV,EAAiB;AAC3B,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,UAAJ;AACA,QAAIC,kBAAkB,GAAG,IAAIC,KAAJ,CAAU,CAAV,CAAzB;AACA,QAAIC,GAAG,GAAG,CAAV;AACA,QAAIC,GAAG,GAAG,CAAV;AACA,QAAIC,YAAY,GAAG,CAAnB;;AAEA,WAAOF,GAAG,GAAGL,KAAK,CAACQ,MAAnB,EAA2B;AACvB;AACAN,MAAAA,UAAU,GAAG,IAAIE,KAAJ,CAAU,CAAV,CAAb;;AAEA,WAAKE,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAGJ,UAAU,CAACM,MAA/B,EAAuCF,GAAG,EAA1C,EAA8C;AAC1C,YAAID,GAAG,GAAGL,KAAK,CAACQ,MAAhB,EAAwB;AACpB;AACA;AACAN,UAAAA,UAAU,CAACI,GAAD,CAAV,GAAkBN,KAAK,CAACS,UAAN,CAAiBJ,GAAG,EAApB,IAA0B,IAA5C;AACH,SAJD,MAKK;AACDH,UAAAA,UAAU,CAACI,GAAD,CAAV,GAAkB,CAAlB;AACH;AACJ,OAbsB,CAevB;AACA;;;AACAH,MAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAwBD,UAAU,CAAC,CAAD,CAAV,IAAiB,CAAzC,CAjBuB,CAkBvB;;AACAC,MAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAyB,CAACD,UAAU,CAAC,CAAD,CAAV,GAAgB,GAAjB,KAAyB,CAA1B,GAAgCA,UAAU,CAAC,CAAD,CAAV,IAAiB,CAAzE,CAnBuB,CAoBvB;;AACAC,MAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAyB,CAACD,UAAU,CAAC,CAAD,CAAV,GAAgB,IAAjB,KAA0B,CAA3B,GAAiCA,UAAU,CAAC,CAAD,CAAV,IAAiB,CAA1E,CArBuB,CAsBvB;;AACAC,MAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAwBD,UAAU,CAAC,CAAD,CAAV,GAAgB,IAAxC,CAvBuB,CAyBvB;;AACAK,MAAAA,YAAY,GAAGF,GAAG,IAAIL,KAAK,CAACQ,MAAN,GAAe,CAAnB,CAAlB;;AACA,cAAQD,YAAR;AACI,aAAK,CAAL;AACI;AACAJ,UAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAwB,EAAxB;AACAA,UAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAwB,EAAxB;AACA;;AAEJ,aAAK,CAAL;AACI;AACAA,UAAAA,kBAAkB,CAAC,CAAD,CAAlB,GAAwB,EAAxB;AACA;;AAEJ;AACI;AAAO;AAbf,OA3BuB,CA2CvB;AACA;;;AACA,WAAKG,GAAG,GAAG,CAAX,EAAcA,GAAG,GAAGH,kBAAkB,CAACK,MAAvC,EAA+CF,GAAG,EAAlD,EAAsD;AAClDL,QAAAA,MAAM,IAAI,KAAKH,OAAL,CAAaY,MAAb,CAAoBP,kBAAkB,CAACG,GAAD,CAAtC,CAAV;AACH;AACJ;;AAED,WAAOL,MAAP;AACH;AA/DY,CAAjB","sourcesContent":["/* eslint no-magic-numbers: 0 */\n'use strict';\n\nmodule.exports = {\n    // private property\n    _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n\n    encodeBinary: function (input) {\n        var output = '';\n        var bytebuffer;\n        var encodedCharIndexes = new Array(4);\n        var inx = 0;\n        var jnx = 0;\n        var paddingBytes = 0;\n\n        while (inx < input.length) {\n            // Fill byte buffer array\n            bytebuffer = new Array(3);\n\n            for (jnx = 0; jnx < bytebuffer.length; jnx++) {\n                if (inx < input.length) {\n                    // throw away high-order byte, as documented at:\n                    // https://developer.mozilla.org/En/Using_XMLHttpRequest#Handling_binary_data\n                    bytebuffer[jnx] = input.charCodeAt(inx++) & 0xff;\n                }\n                else {\n                    bytebuffer[jnx] = 0;\n                }\n            }\n\n            // Get each encoded character, 6 bits at a time\n            // index 1: first 6 bits\n            encodedCharIndexes[0] = bytebuffer[0] >> 2;\n            // index 2: second 6 bits (2 least significant bits from input byte 1 + 4 most significant bits from byte 2)\n            encodedCharIndexes[1] = ((bytebuffer[0] & 0x3) << 4) | (bytebuffer[1] >> 4);\n            // index 3: third 6 bits (4 least significant bits from input byte 2 + 2 most significant bits from byte 3)\n            encodedCharIndexes[2] = ((bytebuffer[1] & 0x0f) << 2) | (bytebuffer[2] >> 6);\n            // index 3: forth 6 bits (6 least significant bits from input byte 3)\n            encodedCharIndexes[3] = bytebuffer[2] & 0x3f;\n\n            // Determine whether padding happened, and adjust accordingly\n            paddingBytes = inx - (input.length - 1);\n            switch (paddingBytes) {\n                case 2:\n                    // Set last 2 characters to padding char\n                    encodedCharIndexes[3] = 64;\n                    encodedCharIndexes[2] = 64;\n                    break;\n\n                case 1:\n                    // Set last character to padding char\n                    encodedCharIndexes[3] = 64;\n                    break;\n\n                default:\n                    break; // No padding - proceed\n            }\n\n            // Now we will grab each appropriate character out of our keystring\n            // based on our index array and append it to the output string\n            for (jnx = 0; jnx < encodedCharIndexes.length; jnx++) {\n                output += this._keyStr.charAt(encodedCharIndexes[jnx]);\n            }\n        }\n\n        return output;\n    }\n};\n"]},"metadata":{},"sourceType":"script"}