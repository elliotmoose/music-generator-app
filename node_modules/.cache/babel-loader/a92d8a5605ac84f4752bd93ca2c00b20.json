{"ast":null,"code":"var BaseTexture = require('./BaseTexture'),\n    VideoBaseTexture = require('./VideoBaseTexture'),\n    TextureUvs = require('./TextureUvs'),\n    EventEmitter = require('eventemitter3'),\n    math = require('../math'),\n    utils = require('../utils');\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * var texture = PIXI.Texture.fromImage('assets/image.png');\n * var sprite1 = new PIXI.Sprite(texture);\n * var sprite2 = new PIXI.Sprite(texture);\n * ```\n *\n * @class\n * @memberof PIXI\n * @param baseTexture {BaseTexture} The base texture source to create the texture from\n * @param [frame] {Rectangle} The rectangle frame of the texture to show\n * @param [crop] {Rectangle} The area of original texture\n * @param [trim] {Rectangle} Trimmed texture rectangle\n * @param [rotate] {boolean} indicates whether the texture should be rotated by 90 degrees ( used by texture packer )\n */\n\n\nfunction Texture(baseTexture, frame, crop, trim, rotate) {\n  EventEmitter.call(this);\n  /**\n   * Does this Texture have any frame data assigned to it?\n   *\n   * @member {boolean}\n   */\n\n  this.noFrame = false;\n\n  if (!frame) {\n    this.noFrame = true;\n    frame = new math.Rectangle(0, 0, 1, 1);\n  }\n\n  if (baseTexture instanceof Texture) {\n    baseTexture = baseTexture.baseTexture;\n  } //  console.log(frame);\n\n  /**\n   * The base texture that this texture uses.\n   *\n   * @member {BaseTexture}\n   */\n\n\n  this.baseTexture = baseTexture;\n  /**\n   * The frame specifies the region of the base texture that this texture uses\n   *\n   * @member {Rectangle}\n   * @private\n   */\n\n  this._frame = frame;\n  /**\n   * The texture trim data.\n   *\n   * @member {Rectangle}\n   */\n\n  this.trim = trim;\n  /**\n   * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n   *\n   * @member {boolean}\n   */\n\n  this.valid = false;\n  /**\n   * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)\n   *\n   * @member {boolean}\n   */\n\n  this.requiresUpdate = false;\n  /**\n   * The WebGL UV data cache.\n   *\n   * @member {TextureUvs}\n   * @private\n   */\n\n  this._uvs = null;\n  /**\n   * The width of the Texture in pixels.\n   *\n   * @member {number}\n   */\n\n  this.width = 0;\n  /**\n   * The height of the Texture in pixels.\n   *\n   * @member {number}\n   */\n\n  this.height = 0;\n  /**\n   * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n   * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n   *\n   * @member {Rectangle}\n   */\n\n  this.crop = crop || frame; //new math.Rectangle(0, 0, 1, 1);\n\n  /**\n   * Indicates whether the texture should be rotated by 90 degrees\n   *\n   * @private\n   * @member {boolean}\n   */\n\n  this.rotate = !!rotate;\n\n  if (baseTexture.hasLoaded) {\n    if (this.noFrame) {\n      frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height); // if there is no frame we should monitor for any base texture changes..\n\n      baseTexture.on('update', this.onBaseTextureUpdated, this);\n    }\n\n    this.frame = frame;\n  } else {\n    baseTexture.once('loaded', this.onBaseTextureLoaded, this);\n  }\n  /**\n   * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.\n   *\n   * @event update\n   * @memberof PIXI.Texture#\n   * @protected\n   */\n\n}\n\nTexture.prototype = Object.create(EventEmitter.prototype);\nTexture.prototype.constructor = Texture;\nmodule.exports = Texture;\nObject.defineProperties(Texture.prototype, {\n  frame: {\n    get: function () {\n      return this._frame;\n    },\n    set: function (frame) {\n      this._frame = frame;\n      this.noFrame = false;\n      this.width = frame.width;\n      this.height = frame.height;\n\n      if (!this.trim && !this.rotate && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height)) {\n        throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);\n      } //this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;\n\n\n      this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;\n\n      if (this.trim) {\n        this.width = this.trim.width;\n        this.height = this.trim.height;\n        this._frame.width = this.trim.width;\n        this._frame.height = this.trim.height;\n      } else {\n        this.crop = frame;\n      }\n\n      if (this.valid) {\n        this._updateUvs();\n      }\n    }\n  }\n});\n/**\n * Updates this texture on the gpu.\n *\n */\n\nTexture.prototype.update = function () {\n  this.baseTexture.update();\n};\n/**\n * Called when the base texture is loaded\n *\n * @private\n */\n\n\nTexture.prototype.onBaseTextureLoaded = function (baseTexture) {\n  // TODO this code looks confusing.. boo to abusing getters and setterss!\n  if (this.noFrame) {\n    this.frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n  } else {\n    this.frame = this._frame;\n  }\n\n  this.emit('update', this);\n};\n\nTexture.prototype.onBaseTextureUpdated = function (baseTexture) {\n  this._frame.width = baseTexture.width;\n  this._frame.height = baseTexture.height;\n  this.emit('update', this);\n};\n/**\n * Destroys this texture\n *\n * @param destroyBase {boolean} Whether to destroy the base texture as well\n */\n\n\nTexture.prototype.destroy = function (destroyBase) {\n  if (this.baseTexture) {\n    if (destroyBase) {\n      this.baseTexture.destroy();\n    }\n\n    this.baseTexture.off('update', this.onBaseTextureUpdated, this);\n    this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);\n    this.baseTexture = null;\n  }\n\n  this._frame = null;\n  this._uvs = null;\n  this.trim = null;\n  this.crop = null;\n  this.valid = false;\n};\n\nTexture.prototype.clone = function () {\n  return new Texture(this.baseTexture, this.frame, this.crop, this.trim, this.rotate);\n};\n/**\n * Updates the internal WebGL UV cache.\n *\n * @private\n */\n\n\nTexture.prototype._updateUvs = function () {\n  if (!this._uvs) {\n    this._uvs = new TextureUvs();\n  }\n\n  this._uvs.set(this.crop, this.baseTexture, this.rotate);\n};\n/**\n * Helper function that creates a Texture object from the given image url.\n * If the image is not in the texture cache it will be  created and loaded.\n *\n * @static\n * @param imageUrl {string} The image url of the texture\n * @param crossorigin {boolean} Whether requests should be treated as crossorigin\n * @param scaleMode {number} See {{#crossLink \"PIXI/scaleModes:property\"}}scaleModes{{/crossLink}} for possible values\n * @return {Texture} The newly created texture\n */\n\n\nTexture.fromImage = function (imageUrl, crossorigin, scaleMode) {\n  var texture = utils.TextureCache[imageUrl];\n\n  if (!texture) {\n    texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));\n    utils.TextureCache[imageUrl] = texture;\n  }\n\n  return texture;\n};\n/**\n * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @static\n * @param frameId {String} The frame Id of the texture in the cache\n * @return {Texture} The newly created texture\n */\n\n\nTexture.fromFrame = function (frameId) {\n  var texture = utils.TextureCache[frameId];\n\n  if (!texture) {\n    throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache');\n  }\n\n  return texture;\n};\n/**\n * Helper function that creates a new Texture based on the given canvas element.\n *\n * @static\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {number} See {{#crossLink \"PIXI/scaleModes:property\"}}scaleModes{{/crossLink}} for possible values\n * @return {Texture}\n */\n\n\nTexture.fromCanvas = function (canvas, scaleMode) {\n  return new Texture(BaseTexture.fromCanvas(canvas, scaleMode));\n};\n/**\n * Helper function that creates a new Texture based on the given video element.\n *\n * @static\n * @param video {HTMLVideoElement}\n * @param scaleMode {number} See {{#crossLink \"PIXI/scaleModes:property\"}}scaleModes{{/crossLink}} for possible values\n * @return {Texture} A Texture\n */\n\n\nTexture.fromVideo = function (video, scaleMode) {\n  if (typeof video === 'string') {\n    return Texture.fromVideoUrl(video, scaleMode);\n  } else {\n    return new Texture(VideoBaseTexture.fromVideo(video, scaleMode));\n  }\n};\n/**\n * Helper function that creates a new Texture based on the video url.\n *\n * @static\n * @param videoUrl {string}\n * @param scaleMode {number} See {{@link SCALE_MODES}} for possible values\n * @return {Texture} A Texture\n */\n\n\nTexture.fromVideoUrl = function (videoUrl, scaleMode) {\n  return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode));\n};\n/**\n * Adds a texture to the global utils.TextureCache. This cache is shared across the whole PIXI object.\n *\n * @static\n * @param texture {Texture} The Texture to add to the cache.\n * @param id {string} The id that the texture will be stored against.\n */\n\n\nTexture.addTextureToCache = function (texture, id) {\n  utils.TextureCache[id] = texture;\n};\n/**\n * Remove a texture from the global utils.TextureCache.\n *\n * @static\n * @param id {string} The id of the texture to be removed\n * @return {Texture} The texture that was removed\n */\n\n\nTexture.removeTextureFromCache = function (id) {\n  var texture = utils.TextureCache[id];\n  delete utils.TextureCache[id];\n  delete utils.BaseTextureCache[id];\n  return texture;\n};\n\nTexture.EMPTY = new Texture(new BaseTexture());","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/textures/Texture.js"],"names":["BaseTexture","require","VideoBaseTexture","TextureUvs","EventEmitter","math","utils","Texture","baseTexture","frame","crop","trim","rotate","call","noFrame","Rectangle","_frame","valid","requiresUpdate","_uvs","width","height","hasLoaded","on","onBaseTextureUpdated","once","onBaseTextureLoaded","prototype","Object","create","constructor","module","exports","defineProperties","get","set","x","y","Error","_updateUvs","update","emit","destroy","destroyBase","off","clone","fromImage","imageUrl","crossorigin","scaleMode","texture","TextureCache","fromFrame","frameId","fromCanvas","canvas","fromVideo","video","fromVideoUrl","videoUrl","fromUrl","addTextureToCache","id","removeTextureFromCache","BaseTextureCache","EMPTY"],"mappings":"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","sourcesContent":["var BaseTexture = require('./BaseTexture'),\n    VideoBaseTexture = require('./VideoBaseTexture'),\n    TextureUvs = require('./TextureUvs'),\n    EventEmitter = require('eventemitter3'),\n    math = require('../math'),\n    utils = require('../utils');\n\n/**\n * A texture stores the information that represents an image or part of an image. It cannot be added\n * to the display list directly. Instead use it as the texture for a Sprite. If no frame is provided then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * var texture = PIXI.Texture.fromImage('assets/image.png');\n * var sprite1 = new PIXI.Sprite(texture);\n * var sprite2 = new PIXI.Sprite(texture);\n * ```\n *\n * @class\n * @memberof PIXI\n * @param baseTexture {BaseTexture} The base texture source to create the texture from\n * @param [frame] {Rectangle} The rectangle frame of the texture to show\n * @param [crop] {Rectangle} The area of original texture\n * @param [trim] {Rectangle} Trimmed texture rectangle\n * @param [rotate] {boolean} indicates whether the texture should be rotated by 90 degrees ( used by texture packer )\n */\nfunction Texture(baseTexture, frame, crop, trim, rotate)\n{\n    EventEmitter.call(this);\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * @member {boolean}\n     */\n    this.noFrame = false;\n\n    if (!frame)\n    {\n        this.noFrame = true;\n        frame = new math.Rectangle(0, 0, 1, 1);\n    }\n\n    if (baseTexture instanceof Texture)\n    {\n        baseTexture = baseTexture.baseTexture;\n    }\n\n  //  console.log(frame);\n\n    /**\n     * The base texture that this texture uses.\n     *\n     * @member {BaseTexture}\n     */\n    this.baseTexture = baseTexture;\n\n    /**\n     * The frame specifies the region of the base texture that this texture uses\n     *\n     * @member {Rectangle}\n     * @private\n     */\n    this._frame = frame;\n\n    /**\n     * The texture trim data.\n     *\n     * @member {Rectangle}\n     */\n    this.trim = trim;\n\n    /**\n     * This will let the renderer know if the texture is valid. If it's not then it cannot be rendered.\n     *\n     * @member {boolean}\n     */\n    this.valid = false;\n\n    /**\n     * This will let a renderer know that a texture has been updated (used mainly for webGL uv updates)\n     *\n     * @member {boolean}\n     */\n    this.requiresUpdate = false;\n\n    /**\n     * The WebGL UV data cache.\n     *\n     * @member {TextureUvs}\n     * @private\n     */\n    this._uvs = null;\n\n    /**\n     * The width of the Texture in pixels.\n     *\n     * @member {number}\n     */\n    this.width = 0;\n\n    /**\n     * The height of the Texture in pixels.\n     *\n     * @member {number}\n     */\n    this.height = 0;\n\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     *\n     * @member {Rectangle}\n     */\n    this.crop = crop || frame;//new math.Rectangle(0, 0, 1, 1);\n\n    /**\n     * Indicates whether the texture should be rotated by 90 degrees\n     *\n     * @private\n     * @member {boolean}\n     */\n    this.rotate = !!rotate;\n\n    if (baseTexture.hasLoaded)\n    {\n        if (this.noFrame)\n        {\n            frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n\n            // if there is no frame we should monitor for any base texture changes..\n            baseTexture.on('update', this.onBaseTextureUpdated, this);\n        }\n        this.frame = frame;\n    }\n    else\n    {\n        baseTexture.once('loaded', this.onBaseTextureLoaded, this);\n    }\n\n    /**\n     * Fired when the texture is updated. This happens if the frame or the baseTexture is updated.\n     *\n     * @event update\n     * @memberof PIXI.Texture#\n     * @protected\n     */\n}\n\nTexture.prototype = Object.create(EventEmitter.prototype);\nTexture.prototype.constructor = Texture;\nmodule.exports = Texture;\n\nObject.defineProperties(Texture.prototype, {\n    frame: {\n        get: function ()\n        {\n            return this._frame;\n        },\n        set: function (frame)\n        {\n            this._frame = frame;\n\n            this.noFrame = false;\n\n            this.width = frame.width;\n            this.height = frame.height;\n\n\n\n            if (!this.trim && !this.rotate && (frame.x + frame.width > this.baseTexture.width || frame.y + frame.height > this.baseTexture.height))\n            {\n                throw new Error('Texture Error: frame does not fit inside the base Texture dimensions ' + this);\n            }\n\n            //this.valid = frame && frame.width && frame.height && this.baseTexture.source && this.baseTexture.hasLoaded;\n            this.valid = frame && frame.width && frame.height && this.baseTexture.hasLoaded;\n\n            if (this.trim)\n            {\n\n                this.width = this.trim.width;\n                this.height = this.trim.height;\n                this._frame.width = this.trim.width;\n                this._frame.height = this.trim.height;\n            }\n            else\n            {\n                this.crop = frame;\n            }\n\n            if (this.valid)\n            {\n                this._updateUvs();\n            }\n        }\n    }\n});\n\n/**\n * Updates this texture on the gpu.\n *\n */\nTexture.prototype.update = function ()\n{\n    this.baseTexture.update();\n};\n\n/**\n * Called when the base texture is loaded\n *\n * @private\n */\nTexture.prototype.onBaseTextureLoaded = function (baseTexture)\n{\n    // TODO this code looks confusing.. boo to abusing getters and setterss!\n    if (this.noFrame)\n    {\n        this.frame = new math.Rectangle(0, 0, baseTexture.width, baseTexture.height);\n    }\n    else\n    {\n        this.frame = this._frame;\n    }\n\n    this.emit('update', this);\n};\n\nTexture.prototype.onBaseTextureUpdated = function (baseTexture)\n{\n    this._frame.width = baseTexture.width;\n    this._frame.height = baseTexture.height;\n\n    this.emit('update', this);\n};\n\n/**\n * Destroys this texture\n *\n * @param destroyBase {boolean} Whether to destroy the base texture as well\n */\nTexture.prototype.destroy = function (destroyBase)\n{\n    if (this.baseTexture)\n    {\n        if (destroyBase)\n        {\n            this.baseTexture.destroy();\n        }\n\n        this.baseTexture.off('update', this.onBaseTextureUpdated, this);\n        this.baseTexture.off('loaded', this.onBaseTextureLoaded, this);\n\n        this.baseTexture = null;\n    }\n\n    this._frame = null;\n    this._uvs = null;\n    this.trim = null;\n    this.crop = null;\n\n    this.valid = false;\n};\n\nTexture.prototype.clone = function ()\n{\n    return new Texture(this.baseTexture, this.frame, this.crop, this.trim, this.rotate);\n};\n\n/**\n * Updates the internal WebGL UV cache.\n *\n * @private\n */\nTexture.prototype._updateUvs = function ()\n{\n    if (!this._uvs)\n    {\n        this._uvs = new TextureUvs();\n    }\n\n    this._uvs.set(this.crop, this.baseTexture, this.rotate);\n};\n\n/**\n * Helper function that creates a Texture object from the given image url.\n * If the image is not in the texture cache it will be  created and loaded.\n *\n * @static\n * @param imageUrl {string} The image url of the texture\n * @param crossorigin {boolean} Whether requests should be treated as crossorigin\n * @param scaleMode {number} See {{#crossLink \"PIXI/scaleModes:property\"}}scaleModes{{/crossLink}} for possible values\n * @return {Texture} The newly created texture\n */\nTexture.fromImage = function (imageUrl, crossorigin, scaleMode)\n{\n    var texture = utils.TextureCache[imageUrl];\n\n    if (!texture)\n    {\n        texture = new Texture(BaseTexture.fromImage(imageUrl, crossorigin, scaleMode));\n        utils.TextureCache[imageUrl] = texture;\n    }\n\n    return texture;\n};\n\n/**\n * Helper function that creates a sprite that will contain a texture from the TextureCache based on the frameId\n * The frame ids are created when a Texture packer file has been loaded\n *\n * @static\n * @param frameId {String} The frame Id of the texture in the cache\n * @return {Texture} The newly created texture\n */\nTexture.fromFrame = function (frameId)\n{\n    var texture = utils.TextureCache[frameId];\n\n    if (!texture)\n    {\n        throw new Error('The frameId \"' + frameId + '\" does not exist in the texture cache');\n    }\n\n    return texture;\n};\n\n/**\n * Helper function that creates a new Texture based on the given canvas element.\n *\n * @static\n * @param canvas {Canvas} The canvas element source of the texture\n * @param scaleMode {number} See {{#crossLink \"PIXI/scaleModes:property\"}}scaleModes{{/crossLink}} for possible values\n * @return {Texture}\n */\nTexture.fromCanvas = function (canvas, scaleMode)\n{\n    return new Texture(BaseTexture.fromCanvas(canvas, scaleMode));\n};\n\n/**\n * Helper function that creates a new Texture based on the given video element.\n *\n * @static\n * @param video {HTMLVideoElement}\n * @param scaleMode {number} See {{#crossLink \"PIXI/scaleModes:property\"}}scaleModes{{/crossLink}} for possible values\n * @return {Texture} A Texture\n */\nTexture.fromVideo = function (video, scaleMode)\n{\n    if (typeof video === 'string')\n    {\n        return Texture.fromVideoUrl(video, scaleMode);\n    }\n    else\n    {\n        return new Texture(VideoBaseTexture.fromVideo(video, scaleMode));\n    }\n};\n\n/**\n * Helper function that creates a new Texture based on the video url.\n *\n * @static\n * @param videoUrl {string}\n * @param scaleMode {number} See {{@link SCALE_MODES}} for possible values\n * @return {Texture} A Texture\n */\nTexture.fromVideoUrl = function (videoUrl, scaleMode)\n{\n    return new Texture(VideoBaseTexture.fromUrl(videoUrl, scaleMode));\n};\n\n/**\n * Adds a texture to the global utils.TextureCache. This cache is shared across the whole PIXI object.\n *\n * @static\n * @param texture {Texture} The Texture to add to the cache.\n * @param id {string} The id that the texture will be stored against.\n */\nTexture.addTextureToCache = function (texture, id)\n{\n    utils.TextureCache[id] = texture;\n};\n\n/**\n * Remove a texture from the global utils.TextureCache.\n *\n * @static\n * @param id {string} The id of the texture to be removed\n * @return {Texture} The texture that was removed\n */\nTexture.removeTextureFromCache = function (id)\n{\n    var texture = utils.TextureCache[id];\n\n    delete utils.TextureCache[id];\n    delete utils.BaseTextureCache[id];\n\n    return texture;\n};\n\nTexture.EMPTY = new Texture(new BaseTexture());\n"]},"metadata":{},"sourceType":"script"}