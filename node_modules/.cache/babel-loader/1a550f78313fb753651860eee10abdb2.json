{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport var Ticker = /*#__PURE__*/function () {\n  function Ticker(callback, type, updateInterval) {\n    _classCallCheck(this, Ticker);\n\n    this._callback = callback;\n    this._type = type;\n    this._updateInterval = updateInterval; // create the clock source for the first time\n\n    this._createClock();\n  }\n  /**\n   * Generate a web worker\n   */\n\n\n  _createClass(Ticker, [{\n    key: \"_createWorker\",\n    value: function _createWorker() {\n      var blob = new Blob([\n      /* javascript */\n      \"\\n\\t\\t\\t// the initial timeout time\\n\\t\\t\\tlet timeoutTime =  \".concat((this._updateInterval * 1000).toFixed(1), \";\\n\\t\\t\\t// onmessage callback\\n\\t\\t\\tself.onmessage = function(msg){\\n\\t\\t\\t\\ttimeoutTime = parseInt(msg.data);\\n\\t\\t\\t};\\n\\t\\t\\t// the tick function which posts a message\\n\\t\\t\\t// and schedules a new tick\\n\\t\\t\\tfunction tick(){\\n\\t\\t\\t\\tsetTimeout(tick, timeoutTime);\\n\\t\\t\\t\\tself.postMessage('tick');\\n\\t\\t\\t}\\n\\t\\t\\t// call tick initially\\n\\t\\t\\ttick();\\n\\t\\t\\t\")], {\n        type: \"text/javascript\"\n      });\n      var blobUrl = URL.createObjectURL(blob);\n      var worker = new Worker(blobUrl);\n      worker.onmessage = this._callback.bind(this);\n      this._worker = worker;\n    }\n    /**\n     * Create a timeout loop\n     */\n\n  }, {\n    key: \"_createTimeout\",\n    value: function _createTimeout() {\n      var _this = this;\n\n      this._timeout = setTimeout(function () {\n        _this._createTimeout();\n\n        _this._callback();\n      }, this._updateInterval * 1000);\n    }\n    /**\n     * Create the clock source.\n     */\n\n  }, {\n    key: \"_createClock\",\n    value: function _createClock() {\n      if (this._type === \"worker\") {\n        try {\n          this._createWorker();\n        } catch (e) {\n          // workers not supported, fallback to timeout\n          this._type = \"timeout\";\n\n          this._createClock();\n        }\n      } else if (this._type === \"timeout\") {\n        this._createTimeout();\n      }\n    }\n    /**\n     * Clean up the current clock source\n     */\n\n  }, {\n    key: \"_disposeClock\",\n    value: function _disposeClock() {\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n        this._timeout = 0;\n      }\n\n      if (this._worker) {\n        this._worker.terminate();\n\n        this._worker.onmessage = null;\n      }\n    }\n    /**\n     * The rate in seconds the ticker will update\n     */\n\n  }, {\n    key: \"dispose\",\n\n    /**\n     * Clean up\n     */\n    value: function dispose() {\n      this._disposeClock();\n    }\n  }, {\n    key: \"updateInterval\",\n    get: function get() {\n      return this._updateInterval;\n    },\n    set: function set(interval) {\n      this._updateInterval = Math.max(interval, 128 / 44100);\n\n      if (this._type === \"worker\") {\n        this._worker.postMessage(Math.max(interval * 1000, 1));\n      }\n    }\n    /**\n     * The type of the ticker, either a worker or a timeout\n     */\n\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      this._disposeClock();\n\n      this._type = type;\n\n      this._createClock();\n    }\n  }]);\n\n  return Ticker;\n}();","map":{"version":3,"sources":["../../../../Tone/core/clock/Ticker.ts"],"names":[],"mappings":";;;AAIA;;;AAGG;AACH,WAAa,MAAb;AA2BC,kBAAY,QAAZ,EAAkC,IAAlC,EAA2D,cAA3D,EAAkF;AAAA;;AAEjF,SAAK,SAAL,GAAiB,QAAjB;AACA,SAAK,KAAL,GAAa,IAAb;AACA,SAAK,eAAL,GAAuB,cAAvB,CAJiF,CAMjF;;AACA,SAAK,YAAL;AACA;AAED;;AAEG;;;AAvCJ;AAAA;AAAA,oCAwCsB;AAEpB,UAAM,IAAI,GAAG,IAAI,IAAJ,CAAS;AACrB;AADqB,8EAGA,CAAC,KAAK,eAAL,GAAuB,IAAxB,EAA8B,OAA9B,CAAsC,CAAtC,CAHA,sXAAT,EAiBV;AAAE,QAAA,IAAI,EAAE;AAAR,OAjBU,CAAb;AAkBA,UAAM,OAAO,GAAG,GAAG,CAAC,eAAJ,CAAoB,IAApB,CAAhB;AACA,UAAM,MAAM,GAAG,IAAI,MAAJ,CAAW,OAAX,CAAf;AAEA,MAAA,MAAM,CAAC,SAAP,GAAmB,KAAK,SAAL,CAAe,IAAf,CAAoB,IAApB,CAAnB;AAEA,WAAK,OAAL,GAAe,MAAf;AACA;AAED;;AAEG;;AAtEJ;AAAA;AAAA,qCAuEuB;AAAA;;AACrB,WAAK,QAAL,GAAgB,UAAU,CAAC,YAAK;AAC/B,QAAA,KAAI,CAAC,cAAL;;AACA,QAAA,KAAI,CAAC,SAAL;AACA,OAHyB,EAGvB,KAAK,eAAL,GAAuB,IAHA,CAA1B;AAIA;AAED;;AAEG;;AAhFJ;AAAA;AAAA,mCAiFqB;AACnB,UAAI,KAAK,KAAL,KAAe,QAAnB,EAA6B;AAC5B,YAAI;AACH,eAAK,aAAL;AACA,SAFD,CAEE,OAAO,CAAP,EAAU;AACX;AACA,eAAK,KAAL,GAAa,SAAb;;AACA,eAAK,YAAL;AACA;AACD,OARD,MAQO,IAAI,KAAK,KAAL,KAAe,SAAnB,EAA8B;AACpC,aAAK,cAAL;AACA;AACD;AAED;;AAEG;;AAjGJ;AAAA;AAAA,oCAkGsB;AACpB,UAAI,KAAK,QAAT,EAAmB;AAClB,QAAA,YAAY,CAAC,KAAK,QAAN,CAAZ;AACA,aAAK,QAAL,GAAgB,CAAhB;AACA;;AACD,UAAI,KAAK,OAAT,EAAkB;AACjB,aAAK,OAAL,CAAa,SAAb;;AACA,aAAK,OAAL,CAAa,SAAb,GAAyB,IAAzB;AACA;AACD;AAED;;AAEG;;AA/GJ;AAAA;;AAsIC;;AAEG;AAxIJ,8BAyIQ;AACN,WAAK,aAAL;AACA;AA3IF;AAAA;AAAA,wBAgHmB;AACjB,aAAO,KAAK,eAAZ;AACA,KAlHF;AAAA,sBAmHoB,QAnHpB,EAmHqC;AACnC,WAAK,eAAL,GAAuB,IAAI,CAAC,GAAL,CAAS,QAAT,EAAmB,MAAM,KAAzB,CAAvB;;AACA,UAAI,KAAK,KAAL,KAAe,QAAnB,EAA6B;AAC5B,aAAK,OAAL,CAAa,WAAb,CAAyB,IAAI,CAAC,GAAL,CAAS,QAAQ,GAAG,IAApB,EAA0B,CAA1B,CAAzB;AACA;AACD;AAED;;AAEG;;AA5HJ;AAAA;AAAA,wBA6HS;AACP,aAAO,KAAK,KAAZ;AACA,KA/HF;AAAA,sBAgIU,IAhIV,EAgIiC;AAC/B,WAAK,aAAL;;AACA,WAAK,KAAL,GAAa,IAAb;;AACA,WAAK,YAAL;AACA;AApIF;;AAAA;AAAA","sourceRoot":"","sourcesContent":["/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n    constructor(callback, type, updateInterval) {\n        this._callback = callback;\n        this._type = type;\n        this._updateInterval = updateInterval;\n        // create the clock source for the first time\n        this._createClock();\n    }\n    /**\n     * Generate a web worker\n     */\n    _createWorker() {\n        const blob = new Blob([\n            /* javascript */ `\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`\n        ], { type: \"text/javascript\" });\n        const blobUrl = URL.createObjectURL(blob);\n        const worker = new Worker(blobUrl);\n        worker.onmessage = this._callback.bind(this);\n        this._worker = worker;\n    }\n    /**\n     * Create a timeout loop\n     */\n    _createTimeout() {\n        this._timeout = setTimeout(() => {\n            this._createTimeout();\n            this._callback();\n        }, this._updateInterval * 1000);\n    }\n    /**\n     * Create the clock source.\n     */\n    _createClock() {\n        if (this._type === \"worker\") {\n            try {\n                this._createWorker();\n            }\n            catch (e) {\n                // workers not supported, fallback to timeout\n                this._type = \"timeout\";\n                this._createClock();\n            }\n        }\n        else if (this._type === \"timeout\") {\n            this._createTimeout();\n        }\n    }\n    /**\n     * Clean up the current clock source\n     */\n    _disposeClock() {\n        if (this._timeout) {\n            clearTimeout(this._timeout);\n            this._timeout = 0;\n        }\n        if (this._worker) {\n            this._worker.terminate();\n            this._worker.onmessage = null;\n        }\n    }\n    /**\n     * The rate in seconds the ticker will update\n     */\n    get updateInterval() {\n        return this._updateInterval;\n    }\n    set updateInterval(interval) {\n        this._updateInterval = Math.max(interval, 128 / 44100);\n        if (this._type === \"worker\") {\n            this._worker.postMessage(Math.max(interval * 1000, 1));\n        }\n    }\n    /**\n     * The type of the ticker, either a worker or a timeout\n     */\n    get type() {\n        return this._type;\n    }\n    set type(type) {\n        this._disposeClock();\n        this._type = type;\n        this._createClock();\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        this._disposeClock();\n    }\n}\n//# sourceMappingURL=Ticker.js.map"]},"metadata":{},"sourceType":"module"}