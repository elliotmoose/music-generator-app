{"ast":null,"code":"import _regeneratorRuntime from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nvar _marked = /*#__PURE__*/_regeneratorRuntime.mark(upPatternGen),\n    _marked2 = /*#__PURE__*/_regeneratorRuntime.mark(downPatternGen),\n    _marked3 = /*#__PURE__*/_regeneratorRuntime.mark(infiniteGen),\n    _marked4 = /*#__PURE__*/_regeneratorRuntime.mark(alternatingGenerator),\n    _marked5 = /*#__PURE__*/_regeneratorRuntime.mark(jumpUp),\n    _marked6 = /*#__PURE__*/_regeneratorRuntime.mark(jumpDown),\n    _marked7 = /*#__PURE__*/_regeneratorRuntime.mark(randomGen),\n    _marked8 = /*#__PURE__*/_regeneratorRuntime.mark(randomOnce),\n    _marked9 = /*#__PURE__*/_regeneratorRuntime.mark(randomWalk),\n    _marked10 = /*#__PURE__*/_regeneratorRuntime.mark(PatternGenerator);\n\nimport { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n/**\n * Start at the first value and go up to the last\n */\n\nfunction upPatternGen(values) {\n  var index;\n  return _regeneratorRuntime.wrap(function upPatternGen$(_context) {\n    while (1) {\n      switch (_context.prev = _context.next) {\n        case 0:\n          index = 0;\n\n        case 1:\n          if (!(index < values.length)) {\n            _context.next = 8;\n            break;\n          }\n\n          index = clampToArraySize(index, values);\n          _context.next = 5;\n          return values[index];\n\n        case 5:\n          index++;\n          _context.next = 1;\n          break;\n\n        case 8:\n        case \"end\":\n          return _context.stop();\n      }\n    }\n  }, _marked);\n}\n/**\n * Start at the last value and go down to 0\n */\n\n\nfunction downPatternGen(values) {\n  var index;\n  return _regeneratorRuntime.wrap(function downPatternGen$(_context2) {\n    while (1) {\n      switch (_context2.prev = _context2.next) {\n        case 0:\n          index = values.length - 1;\n\n        case 1:\n          if (!(index >= 0)) {\n            _context2.next = 8;\n            break;\n          }\n\n          index = clampToArraySize(index, values);\n          _context2.next = 5;\n          return values[index];\n\n        case 5:\n          index--;\n          _context2.next = 1;\n          break;\n\n        case 8:\n        case \"end\":\n          return _context2.stop();\n      }\n    }\n  }, _marked2);\n}\n/**\n * Infinitely yield the generator\n */\n\n\nfunction infiniteGen(values, gen) {\n  return _regeneratorRuntime.wrap(function infiniteGen$(_context3) {\n    while (1) {\n      switch (_context3.prev = _context3.next) {\n        case 0:\n          if (!true) {\n            _context3.next = 4;\n            break;\n          }\n\n          return _context3.delegateYield(gen(values), \"t0\", 2);\n\n        case 2:\n          _context3.next = 0;\n          break;\n\n        case 4:\n        case \"end\":\n          return _context3.stop();\n      }\n    }\n  }, _marked3);\n}\n/**\n * Make sure that the index is in the given range\n */\n\n\nfunction clampToArraySize(index, values) {\n  return clamp(index, 0, values.length - 1);\n}\n/**\n * Alternate between two generators\n */\n\n\nfunction alternatingGenerator(values, directionUp) {\n  var index;\n  return _regeneratorRuntime.wrap(function alternatingGenerator$(_context4) {\n    while (1) {\n      switch (_context4.prev = _context4.next) {\n        case 0:\n          index = directionUp ? 0 : values.length - 1;\n\n        case 1:\n          if (!true) {\n            _context4.next = 8;\n            break;\n          }\n\n          index = clampToArraySize(index, values);\n          _context4.next = 5;\n          return values[index];\n\n        case 5:\n          if (directionUp) {\n            index++;\n\n            if (index >= values.length - 1) {\n              directionUp = false;\n            }\n          } else {\n            index--;\n\n            if (index <= 0) {\n              directionUp = true;\n            }\n          }\n\n          _context4.next = 1;\n          break;\n\n        case 8:\n        case \"end\":\n          return _context4.stop();\n      }\n    }\n  }, _marked4);\n}\n/**\n * Starting from the bottom move up 2, down 1\n */\n\n\nfunction jumpUp(values) {\n  var index, stepIndex;\n  return _regeneratorRuntime.wrap(function jumpUp$(_context5) {\n    while (1) {\n      switch (_context5.prev = _context5.next) {\n        case 0:\n          index = 0;\n          stepIndex = 0;\n\n        case 2:\n          if (!(index < values.length)) {\n            _context5.next = 10;\n            break;\n          }\n\n          index = clampToArraySize(index, values);\n          _context5.next = 6;\n          return values[index];\n\n        case 6:\n          stepIndex++;\n          index += stepIndex % 2 ? 2 : -1;\n          _context5.next = 2;\n          break;\n\n        case 10:\n        case \"end\":\n          return _context5.stop();\n      }\n    }\n  }, _marked5);\n}\n/**\n * Starting from the top move down 2, up 1\n */\n\n\nfunction jumpDown(values) {\n  var index, stepIndex;\n  return _regeneratorRuntime.wrap(function jumpDown$(_context6) {\n    while (1) {\n      switch (_context6.prev = _context6.next) {\n        case 0:\n          index = values.length - 1;\n          stepIndex = 0;\n\n        case 2:\n          if (!(index >= 0)) {\n            _context6.next = 10;\n            break;\n          }\n\n          index = clampToArraySize(index, values);\n          _context6.next = 6;\n          return values[index];\n\n        case 6:\n          stepIndex++;\n          index += stepIndex % 2 ? -2 : 1;\n          _context6.next = 2;\n          break;\n\n        case 10:\n        case \"end\":\n          return _context6.stop();\n      }\n    }\n  }, _marked6);\n}\n/**\n * Choose a random index each time\n */\n\n\nfunction randomGen(values) {\n  var randomIndex;\n  return _regeneratorRuntime.wrap(function randomGen$(_context7) {\n    while (1) {\n      switch (_context7.prev = _context7.next) {\n        case 0:\n          if (!true) {\n            _context7.next = 6;\n            break;\n          }\n\n          randomIndex = Math.floor(Math.random() * values.length);\n          _context7.next = 4;\n          return values[randomIndex];\n\n        case 4:\n          _context7.next = 0;\n          break;\n\n        case 6:\n        case \"end\":\n          return _context7.stop();\n      }\n    }\n  }, _marked7);\n}\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\n\n\nfunction randomOnce(values) {\n  var copy, i, randVal, index;\n  return _regeneratorRuntime.wrap(function randomOnce$(_context8) {\n    while (1) {\n      switch (_context8.prev = _context8.next) {\n        case 0:\n          // create an array of indices\n          copy = [];\n\n          for (i = 0; i < values.length; i++) {\n            copy.push(i);\n          }\n\n        case 2:\n          if (!(copy.length > 0)) {\n            _context8.next = 9;\n            break;\n          }\n\n          // random choose an index, and then remove it so it's not chosen again\n          randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n          index = clampToArraySize(randVal[0], values);\n          _context8.next = 7;\n          return values[index];\n\n        case 7:\n          _context8.next = 2;\n          break;\n\n        case 9:\n        case \"end\":\n          return _context8.stop();\n      }\n    }\n  }, _marked8);\n}\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\n\n\nfunction randomWalk(values) {\n  var index;\n  return _regeneratorRuntime.wrap(function randomWalk$(_context9) {\n    while (1) {\n      switch (_context9.prev = _context9.next) {\n        case 0:\n          // randomly choose a starting index in the values array\n          index = Math.floor(Math.random() * values.length);\n\n        case 1:\n          if (!true) {\n            _context9.next = 7;\n            break;\n          }\n\n          if (index === 0) {\n            index++; // at bottom of array, so force upward step\n          } else if (index === values.length - 1) {\n            index--; // at top of array, so force downward step\n          } else if (Math.random() < 0.5) {\n            // else choose random downward or upward step\n            index--;\n          } else {\n            index++;\n          }\n\n          _context9.next = 5;\n          return values[index];\n\n        case 5:\n          _context9.next = 1;\n          break;\n\n        case 7:\n        case \"end\":\n          return _context9.stop();\n      }\n    }\n  }, _marked9);\n}\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\n\n\nexport function PatternGenerator(values) {\n  var pattern,\n      index,\n      _args10 = arguments;\n  return _regeneratorRuntime.wrap(function PatternGenerator$(_context10) {\n    while (1) {\n      switch (_context10.prev = _context10.next) {\n        case 0:\n          pattern = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : \"up\";\n          index = _args10.length > 2 && _args10[2] !== undefined ? _args10[2] : 0;\n          // safeguards\n          assert(values.length > 0, \"The array must have more than one value in it\");\n          _context10.t0 = pattern;\n          _context10.next = _context10.t0 === \"up\" ? 6 : _context10.t0 === \"down\" ? 7 : _context10.t0 === \"upDown\" ? 8 : _context10.t0 === \"downUp\" ? 9 : _context10.t0 === \"alternateUp\" ? 10 : _context10.t0 === \"alternateDown\" ? 11 : _context10.t0 === \"random\" ? 12 : _context10.t0 === \"randomOnce\" ? 13 : _context10.t0 === \"randomWalk\" ? 14 : 15;\n          break;\n\n        case 6:\n          return _context10.delegateYield(infiniteGen(values, upPatternGen), \"t1\", 7);\n\n        case 7:\n          return _context10.delegateYield(infiniteGen(values, downPatternGen), \"t2\", 8);\n\n        case 8:\n          return _context10.delegateYield(alternatingGenerator(values, true), \"t3\", 9);\n\n        case 9:\n          return _context10.delegateYield(alternatingGenerator(values, false), \"t4\", 10);\n\n        case 10:\n          return _context10.delegateYield(infiniteGen(values, jumpUp), \"t5\", 11);\n\n        case 11:\n          return _context10.delegateYield(infiniteGen(values, jumpDown), \"t6\", 12);\n\n        case 12:\n          return _context10.delegateYield(randomGen(values), \"t7\", 13);\n\n        case 13:\n          return _context10.delegateYield(infiniteGen(values, randomOnce), \"t8\", 14);\n\n        case 14:\n          return _context10.delegateYield(randomWalk(values), \"t9\", 15);\n\n        case 15:\n        case \"end\":\n          return _context10.stop();\n      }\n    }\n  }, _marked10);\n}","map":{"version":3,"sources":["../../../Tone/event/PatternGenerator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen(values) {\n    let index = 0;\n    while (index < values.length) {\n        index = clampToArraySize(index, values);\n        yield values[index];\n        index++;\n    }\n}\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen(values) {\n    let index = values.length - 1;\n    while (index >= 0) {\n        index = clampToArraySize(index, values);\n        yield values[index];\n        index--;\n    }\n}\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen(values, gen) {\n    while (true) {\n        yield* gen(values);\n    }\n}\n/**\n * Make sure that the index is in the given range\n */\nfunction clampToArraySize(index, values) {\n    return clamp(index, 0, values.length - 1);\n}\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator(values, directionUp) {\n    let index = directionUp ? 0 : values.length - 1;\n    while (true) {\n        index = clampToArraySize(index, values);\n        yield values[index];\n        if (directionUp) {\n            index++;\n            if (index >= values.length - 1) {\n                directionUp = false;\n            }\n        }\n        else {\n            index--;\n            if (index <= 0) {\n                directionUp = true;\n            }\n        }\n    }\n}\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp(values) {\n    let index = 0;\n    let stepIndex = 0;\n    while (index < values.length) {\n        index = clampToArraySize(index, values);\n        yield values[index];\n        stepIndex++;\n        index += (stepIndex % 2 ? 2 : -1);\n    }\n}\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown(values) {\n    let index = values.length - 1;\n    let stepIndex = 0;\n    while (index >= 0) {\n        index = clampToArraySize(index, values);\n        yield values[index];\n        stepIndex++;\n        index += (stepIndex % 2 ? -2 : 1);\n    }\n}\n/**\n * Choose a random index each time\n */\nfunction* randomGen(values) {\n    while (true) {\n        const randomIndex = Math.floor(Math.random() * values.length);\n        yield values[randomIndex];\n    }\n}\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce(values) {\n    // create an array of indices\n    const copy = [];\n    for (let i = 0; i < values.length; i++) {\n        copy.push(i);\n    }\n    while (copy.length > 0) {\n        // random choose an index, and then remove it so it's not chosen again\n        const randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n        const index = clampToArraySize(randVal[0], values);\n        yield values[index];\n    }\n}\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\nfunction* randomWalk(values) {\n    // randomly choose a starting index in the values array\n    let index = Math.floor(Math.random() * values.length);\n    while (true) {\n        if (index === 0) {\n            index++; // at bottom of array, so force upward step\n        }\n        else if (index === values.length - 1) {\n            index--; // at top of array, so force downward step\n        }\n        else if (Math.random() < 0.5) { // else choose random downward or upward step\n            index--;\n        }\n        else {\n            index++;\n        }\n        yield values[index];\n    }\n}\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function* PatternGenerator(values, pattern = \"up\", index = 0) {\n    // safeguards\n    assert(values.length > 0, \"The array must have more than one value in it\");\n    switch (pattern) {\n        case \"up\":\n            yield* infiniteGen(values, upPatternGen);\n        case \"down\":\n            yield* infiniteGen(values, downPatternGen);\n        case \"upDown\":\n            yield* alternatingGenerator(values, true);\n        case \"downUp\":\n            yield* alternatingGenerator(values, false);\n        case \"alternateUp\":\n            yield* infiniteGen(values, jumpUp);\n        case \"alternateDown\":\n            yield* infiniteGen(values, jumpDown);\n        case \"random\":\n            yield* randomGen(values);\n        case \"randomOnce\":\n            yield* infiniteGen(values, randomOnce);\n        case \"randomWalk\":\n            yield* randomWalk(values);\n    }\n}\n//# sourceMappingURL=PatternGenerator.js.map"]},"metadata":{},"sourceType":"module"}