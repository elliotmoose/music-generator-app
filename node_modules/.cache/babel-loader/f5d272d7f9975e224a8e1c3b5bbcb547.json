{"ast":null,"code":"import _classCallCheck from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/Users/thebe/Desktop/music-generator-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Volume } from \"../../component/channel/Volume\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { connectSeries, ToneAudioNode } from \"./ToneAudioNode\";\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * const oscillator = new Tone.Oscillator().start();\n * // the audio will go from the oscillator to the speakers\n * oscillator.connect(Tone.Destination);\n * // a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * @category Core\n */\n\nexport var Destination = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(Destination, _ToneAudioNode);\n\n  var _super = _createSuper(Destination);\n\n  function Destination() {\n    var _this;\n\n    _classCallCheck(this, Destination);\n\n    _this = _super.call(this, optionsFromArguments(Destination.getDefaults(), arguments));\n    _this.name = \"Destination\";\n    _this.input = new Volume({\n      context: _this.context\n    });\n    _this.output = new Gain({\n      context: _this.context\n    });\n    /**\n     * The volume of the master output.\n     */\n\n    _this.volume = _this.input.volume;\n    var options = optionsFromArguments(Destination.getDefaults(), arguments);\n    connectSeries(_this.input, _this.output, _this.context.rawContext.destination);\n    _this.mute = options.mute;\n    _this._internalChannels = [_this.input, _this.context.rawContext.destination, _this.output];\n    return _this;\n  }\n\n  _createClass(Destination, [{\n    key: \"chain\",\n\n    /**\n     * Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n     * chained in the master effects chain.\n     * @param args All arguments will be connected in a row and the Master will be routed through it.\n     * @example\n     * // route all audio through a filter and compressor\n     * const lowpass = new Tone.Filter(800, \"lowpass\");\n     * const compressor = new Tone.Compressor(-18);\n     * Tone.Destination.chain(lowpass, compressor);\n     */\n    value: function chain() {\n      this.input.disconnect();\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      args.unshift(this.input);\n      args.push(this.output);\n      connectSeries.apply(void 0, args);\n      return this;\n    }\n    /**\n     * The maximum number of channels the system can output\n     * @example\n     * console.log(Tone.Destination.maxChannelCount);\n     */\n\n  }, {\n    key: \"dispose\",\n\n    /**\n     * Clean up\n     */\n    value: function dispose() {\n      _get(_getPrototypeOf(Destination.prototype), \"dispose\", this).call(this);\n\n      this.volume.dispose();\n      return this;\n    }\n  }, {\n    key: \"mute\",\n\n    /**\n     * Mute the output.\n     * @example\n     * const oscillator = new Tone.Oscillator().start().toDestination();\n     * setTimeout(() => {\n     * \t// mute the output\n     * \tTone.Destination.mute = true;\n     * }, 1000);\n     */\n    get: function get() {\n      return this.input.mute;\n    },\n    set: function set(mute) {\n      this.input.mute = mute;\n    }\n  }, {\n    key: \"maxChannelCount\",\n    get: function get() {\n      return this.context.rawContext.destination.maxChannelCount;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        mute: false,\n        volume: 0\n      });\n    }\n  }]);\n\n  return Destination;\n}(ToneAudioNode); //-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(function (context) {\n  context.destination = new Destination({\n    context: context\n  });\n});\nonContextClose(function (context) {\n  context.destination.dispose();\n});","map":{"version":3,"sources":["../../../../Tone/core/context/Destination.ts"],"names":[],"mappings":";;;;;;AAAA,SAAS,MAAT,QAAuB,gCAAvB;AAEA,SAAS,oBAAT,QAAqC,kBAArC;AACA,SAAS,cAAT,EAAyB,aAAzB,QAA8C,yBAA9C;AACA,SAAS,IAAT,QAAqB,QAArB;AAEA,SAAS,aAAT,EAAwB,aAAxB,QAAmE,iBAAnE;AAOA;;;;;;;;;;;;;;AAcG;;AACH,WAAa,WAAb;AAAA;;AAAA;;AAaC,yBAAA;AAAA;;AAAA;;AAEC,8BAAM,oBAAoB,CAAC,WAAW,CAAC,WAAZ,EAAD,EAA4B,SAA5B,CAA1B;AAbQ,UAAA,IAAA,GAAe,aAAf;AAET,UAAA,KAAA,GAAgB,IAAI,MAAJ,CAAW;AAAE,MAAA,OAAO,EAAE,MAAK;AAAhB,KAAX,CAAhB;AACA,UAAA,MAAA,GAAe,IAAI,IAAJ,CAAS;AAAE,MAAA,OAAO,EAAE,MAAK;AAAhB,KAAT,CAAf;AAEA;;AAEG;;AACH,UAAA,MAAA,GAA4B,MAAK,KAAL,CAAW,MAAvC;AAMC,QAAM,OAAO,GAAG,oBAAoB,CAAC,WAAW,CAAC,WAAZ,EAAD,EAA4B,SAA5B,CAApC;AAEA,IAAA,aAAa,CAAC,MAAK,KAAN,EAAa,MAAK,MAAlB,EAA0B,MAAK,OAAL,CAAa,UAAb,CAAwB,WAAlD,CAAb;AAEA,UAAK,IAAL,GAAY,OAAO,CAAC,IAApB;AACA,UAAK,iBAAL,GAAyB,CAAC,MAAK,KAAN,EAAa,MAAK,OAAL,CAAa,UAAb,CAAwB,WAArC,EAAkD,MAAK,MAAvD,CAAzB;AARD;AASC;;AAtBF;AAAA;;AA+CC;;;;;;;;;AASG;AAxDJ,4BAyDgD;AAC9C,WAAK,KAAL,CAAW,UAAX;;AAD8C,wCAAtC,IAAsC;AAAtC,QAAA,IAAsC;AAAA;;AAE9C,MAAA,IAAI,CAAC,OAAL,CAAa,KAAK,KAAlB;AACA,MAAA,IAAI,CAAC,IAAL,CAAU,KAAK,MAAf;AACA,MAAA,aAAa,MAAb,SAAiB,IAAjB;AACA,aAAO,IAAP;AACA;AAED;;;;AAIG;;AArEJ;AAAA;;AA0EC;;AAEG;AA5EJ,8BA6EQ;AACN;;AACA,WAAK,MAAL,CAAY,OAAZ;AACA,aAAO,IAAP;AACA;AAjFF;AAAA;;AA+BC;;;;;;;;AAQG;AAvCJ,wBAwCS;AACP,aAAO,KAAK,KAAL,CAAW,IAAlB;AACA,KA1CF;AAAA,sBA2CU,IA3CV,EA2CuB;AACrB,WAAK,KAAL,CAAW,IAAX,GAAkB,IAAlB;AACA;AA7CF;AAAA;AAAA,wBAsEoB;AAClB,aAAO,KAAK,OAAL,CAAa,UAAb,CAAwB,WAAxB,CAAoC,eAA3C;AACA;AAxEF;AAAA;AAAA,kCAwBmB;AACjB,aAAO,MAAM,CAAC,MAAP,CAAc,aAAa,CAAC,WAAd,EAAd,EAA2C;AACjD,QAAA,IAAI,EAAE,KAD2C;AAEjD,QAAA,MAAM,EAAE;AAFyC,OAA3C,CAAP;AAIA;AA7BF;;AAAA;AAAA,EAAiC,aAAjC,E,CAoFA;AACA;AACA;;AAEA,aAAa,CAAC,UAAA,OAAO,EAAG;AACvB,EAAA,OAAO,CAAC,WAAR,GAAsB,IAAI,WAAJ,CAAgB;AAAE,IAAA,OAAO,EAAP;AAAF,GAAhB,CAAtB;AACA,CAFY,CAAb;AAIA,cAAc,CAAC,UAAA,OAAO,EAAG;AACxB,EAAA,OAAO,CAAC,WAAR,CAAoB,OAApB;AACA,CAFa,CAAd","sourceRoot":"","sourcesContent":["import { Volume } from \"../../component/channel/Volume\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { connectSeries, ToneAudioNode } from \"./ToneAudioNode\";\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * const oscillator = new Tone.Oscillator().start();\n * // the audio will go from the oscillator to the speakers\n * oscillator.connect(Tone.Destination);\n * // a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * @category Core\n */\nexport class Destination extends ToneAudioNode {\n    constructor() {\n        super(optionsFromArguments(Destination.getDefaults(), arguments));\n        this.name = \"Destination\";\n        this.input = new Volume({ context: this.context });\n        this.output = new Gain({ context: this.context });\n        /**\n         * The volume of the master output.\n         */\n        this.volume = this.input.volume;\n        const options = optionsFromArguments(Destination.getDefaults(), arguments);\n        connectSeries(this.input, this.output, this.context.rawContext.destination);\n        this.mute = options.mute;\n        this._internalChannels = [this.input, this.context.rawContext.destination, this.output];\n    }\n    static getDefaults() {\n        return Object.assign(ToneAudioNode.getDefaults(), {\n            mute: false,\n            volume: 0,\n        });\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const oscillator = new Tone.Oscillator().start().toDestination();\n     * setTimeout(() => {\n     * \t// mute the output\n     * \tTone.Destination.mute = true;\n     * }, 1000);\n     */\n    get mute() {\n        return this.input.mute;\n    }\n    set mute(mute) {\n        this.input.mute = mute;\n    }\n    /**\n     * Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n     * chained in the master effects chain.\n     * @param args All arguments will be connected in a row and the Master will be routed through it.\n     * @example\n     * // route all audio through a filter and compressor\n     * const lowpass = new Tone.Filter(800, \"lowpass\");\n     * const compressor = new Tone.Compressor(-18);\n     * Tone.Destination.chain(lowpass, compressor);\n     */\n    chain(...args) {\n        this.input.disconnect();\n        args.unshift(this.input);\n        args.push(this.output);\n        connectSeries(...args);\n        return this;\n    }\n    /**\n     * The maximum number of channels the system can output\n     * @example\n     * console.log(Tone.Destination.maxChannelCount);\n     */\n    get maxChannelCount() {\n        return this.context.rawContext.destination.maxChannelCount;\n    }\n    /**\n     * Clean up\n     */\n    dispose() {\n        super.dispose();\n        this.volume.dispose();\n        return this;\n    }\n}\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit(context => {\n    context.destination = new Destination({ context });\n});\nonContextClose(context => {\n    context.destination.dispose();\n});\n//# sourceMappingURL=Destination.js.map"]},"metadata":{},"sourceType":"module"}