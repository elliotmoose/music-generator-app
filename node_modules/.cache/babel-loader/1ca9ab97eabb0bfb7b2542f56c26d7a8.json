{"ast":null,"code":"var utils = require('../../../utils');\n/**\n * Utility methods for Sprite/Texture tinting.\n * @static\n * @class\n * @memberof PIXI\n */\n\n\nvar CanvasTinter = {};\nmodule.exports = CanvasTinter;\n/**\n * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n *\n * @param sprite {Sprite} the sprite to tint\n * @param color {number} the color to use to tint the sprite with\n * @return {HTMLCanvasElement} The tinted canvas\n */\n\nCanvasTinter.getTintedTexture = function (sprite, color) {\n  var texture = sprite.texture;\n  color = CanvasTinter.roundColor(color);\n  var stringColor = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n  texture.tintCache = texture.tintCache || {};\n\n  if (texture.tintCache[stringColor]) {\n    return texture.tintCache[stringColor];\n  } // clone texture..\n\n\n  var canvas = CanvasTinter.canvas || document.createElement('canvas'); //CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);\n\n  CanvasTinter.tintMethod(texture, color, canvas);\n\n  if (CanvasTinter.convertTintToImage) {\n    // is this better?\n    var tintImage = new Image();\n    tintImage.src = canvas.toDataURL();\n    texture.tintCache[stringColor] = tintImage;\n  } else {\n    texture.tintCache[stringColor] = canvas; // if we are not converting the texture to an image then we need to lose the reference to the canvas\n\n    CanvasTinter.canvas = null;\n  }\n\n  return canvas;\n};\n/**\n * Tint a texture using the 'multiply' operation.\n *\n * @param texture {Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\n\n\nCanvasTinter.tintWithMultiply = function (texture, color, canvas) {\n  var context = canvas.getContext('2d');\n  var crop = texture.crop;\n  canvas.width = crop.width;\n  canvas.height = crop.height;\n  context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n  context.fillRect(0, 0, crop.width, crop.height);\n  context.globalCompositeOperation = 'multiply';\n  context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n  context.globalCompositeOperation = 'destination-atop';\n  context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n};\n/**\n * Tint a texture using the 'overlay' operation.\n *\n * @param texture {Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\n\n\nCanvasTinter.tintWithOverlay = function (texture, color, canvas) {\n  var context = canvas.getContext('2d');\n  var crop = texture.crop;\n  canvas.width = crop.width;\n  canvas.height = crop.height;\n  context.globalCompositeOperation = 'copy';\n  context.fillStyle = '#' + ('00000' + (color | 0).toString(16)).substr(-6);\n  context.fillRect(0, 0, crop.width, crop.height);\n  context.globalCompositeOperation = 'destination-atop';\n  context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height); // context.globalCompositeOperation = 'copy';\n};\n/**\n * Tint a texture pixel per pixel.\n *\n * @param texture {Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\n\n\nCanvasTinter.tintWithPerPixel = function (texture, color, canvas) {\n  var context = canvas.getContext('2d');\n  var crop = texture.crop;\n  canvas.width = crop.width;\n  canvas.height = crop.height;\n  context.globalCompositeOperation = 'copy';\n  context.drawImage(texture.baseTexture.source, crop.x, crop.y, crop.width, crop.height, 0, 0, crop.width, crop.height);\n  var rgbValues = utils.hex2rgb(color);\n  var r = rgbValues[0],\n      g = rgbValues[1],\n      b = rgbValues[2];\n  var pixelData = context.getImageData(0, 0, crop.width, crop.height);\n  var pixels = pixelData.data;\n\n  for (var i = 0; i < pixels.length; i += 4) {\n    pixels[i + 0] *= r;\n    pixels[i + 1] *= g;\n    pixels[i + 2] *= b;\n  }\n\n  context.putImageData(pixelData, 0, 0);\n};\n/**\n * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.\n *\n * @param color {number} the color to round, should be a hex color\n */\n\n\nCanvasTinter.roundColor = function (color) {\n  var step = CanvasTinter.cacheStepsPerColorChannel;\n  var rgbValues = utils.hex2rgb(color);\n  rgbValues[0] = Math.min(255, rgbValues[0] / step * step);\n  rgbValues[1] = Math.min(255, rgbValues[1] / step * step);\n  rgbValues[2] = Math.min(255, rgbValues[2] / step * step);\n  return utils.rgb2hex(rgbValues);\n};\n/**\n * Number of steps which will be used as a cap when rounding colors.\n *\n * @member\n */\n\n\nCanvasTinter.cacheStepsPerColorChannel = 8;\n/**\n * Tint cache boolean flag.\n *\n * @member\n */\n\nCanvasTinter.convertTintToImage = false;\n/**\n * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n *\n * @member\n */\n\nCanvasTinter.canUseMultiply = utils.canUseNewCanvasBlendModes();\n/**\n * The tinting method that will be used.\n *\n */\n\nCanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply : CanvasTinter.tintWithPerPixel;","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/pixi.js/src/core/renderers/canvas/utils/CanvasTinter.js"],"names":["utils","require","CanvasTinter","module","exports","getTintedTexture","sprite","color","texture","roundColor","stringColor","toString","substr","tintCache","canvas","document","createElement","tintMethod","convertTintToImage","tintImage","Image","src","toDataURL","tintWithMultiply","context","getContext","crop","width","height","fillStyle","fillRect","globalCompositeOperation","drawImage","baseTexture","source","x","y","tintWithOverlay","tintWithPerPixel","rgbValues","hex2rgb","r","g","b","pixelData","getImageData","pixels","data","i","length","putImageData","step","cacheStepsPerColorChannel","Math","min","rgb2hex","canUseMultiply","canUseNewCanvasBlendModes"],"mappings":"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","sourcesContent":["var utils = require('../../../utils');\n\n/**\n * Utility methods for Sprite/Texture tinting.\n * @static\n * @class\n * @memberof PIXI\n */\nvar CanvasTinter = {};\nmodule.exports = CanvasTinter;\n\n/**\n * Basically this method just needs a sprite and a color and tints the sprite with the given color.\n *\n * @param sprite {Sprite} the sprite to tint\n * @param color {number} the color to use to tint the sprite with\n * @return {HTMLCanvasElement} The tinted canvas\n */\nCanvasTinter.getTintedTexture = function (sprite, color)\n{\n    var texture = sprite.texture;\n\n    color = CanvasTinter.roundColor(color);\n\n    var stringColor = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);\n\n    texture.tintCache = texture.tintCache || {};\n\n    if (texture.tintCache[stringColor])\n    {\n        return texture.tintCache[stringColor];\n    }\n\n     // clone texture..\n    var canvas = CanvasTinter.canvas || document.createElement('canvas');\n\n    //CanvasTinter.tintWithPerPixel(texture, stringColor, canvas);\n    CanvasTinter.tintMethod(texture, color, canvas);\n\n    if (CanvasTinter.convertTintToImage)\n    {\n        // is this better?\n        var tintImage = new Image();\n        tintImage.src = canvas.toDataURL();\n\n        texture.tintCache[stringColor] = tintImage;\n    }\n    else\n    {\n        texture.tintCache[stringColor] = canvas;\n        // if we are not converting the texture to an image then we need to lose the reference to the canvas\n        CanvasTinter.canvas = null;\n    }\n\n    return canvas;\n};\n\n/**\n * Tint a texture using the 'multiply' operation.\n *\n * @param texture {Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nCanvasTinter.tintWithMultiply = function (texture, color, canvas)\n{\n    var context = canvas.getContext( '2d' );\n\n    var crop = texture.crop;\n\n    canvas.width = crop.width;\n    canvas.height = crop.height;\n\n    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);\n\n    context.fillRect(0, 0, crop.width, crop.height);\n\n    context.globalCompositeOperation = 'multiply';\n\n    context.drawImage(\n        texture.baseTexture.source,\n        crop.x,\n        crop.y,\n        crop.width,\n        crop.height,\n        0,\n        0,\n        crop.width,\n        crop.height\n    );\n\n    context.globalCompositeOperation = 'destination-atop';\n\n    context.drawImage(\n        texture.baseTexture.source,\n        crop.x,\n        crop.y,\n        crop.width,\n        crop.height,\n        0,\n        0,\n        crop.width,\n        crop.height\n    );\n};\n\n/**\n * Tint a texture using the 'overlay' operation.\n *\n * @param texture {Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nCanvasTinter.tintWithOverlay = function (texture, color, canvas)\n{\n    var context = canvas.getContext( '2d' );\n\n    var crop = texture.crop;\n\n    canvas.width = crop.width;\n    canvas.height = crop.height;\n\n    context.globalCompositeOperation = 'copy';\n    context.fillStyle = '#' + ('00000' + ( color | 0).toString(16)).substr(-6);\n    context.fillRect(0, 0, crop.width, crop.height);\n\n    context.globalCompositeOperation = 'destination-atop';\n    context.drawImage(\n        texture.baseTexture.source,\n        crop.x,\n        crop.y,\n        crop.width,\n        crop.height,\n        0,\n        0,\n        crop.width,\n        crop.height\n    );\n\n    // context.globalCompositeOperation = 'copy';\n};\n\n/**\n * Tint a texture pixel per pixel.\n *\n * @param texture {Texture} the texture to tint\n * @param color {number} the color to use to tint the sprite with\n * @param canvas {HTMLCanvasElement} the current canvas\n */\nCanvasTinter.tintWithPerPixel = function (texture, color, canvas)\n{\n    var context = canvas.getContext( '2d' );\n\n    var crop = texture.crop;\n\n    canvas.width = crop.width;\n    canvas.height = crop.height;\n\n    context.globalCompositeOperation = 'copy';\n    context.drawImage(\n        texture.baseTexture.source,\n        crop.x,\n        crop.y,\n        crop.width,\n        crop.height,\n        0,\n        0,\n        crop.width,\n        crop.height\n    );\n\n    var rgbValues = utils.hex2rgb(color);\n    var r = rgbValues[0], g = rgbValues[1], b = rgbValues[2];\n\n    var pixelData = context.getImageData(0, 0, crop.width, crop.height);\n\n    var pixels = pixelData.data;\n\n    for (var i = 0; i < pixels.length; i += 4)\n    {\n        pixels[i+0] *= r;\n        pixels[i+1] *= g;\n        pixels[i+2] *= b;\n    }\n\n    context.putImageData(pixelData, 0, 0);\n};\n\n/**\n * Rounds the specified color according to the CanvasTinter.cacheStepsPerColorChannel.\n *\n * @param color {number} the color to round, should be a hex color\n */\nCanvasTinter.roundColor = function (color)\n{\n    var step = CanvasTinter.cacheStepsPerColorChannel;\n\n    var rgbValues = utils.hex2rgb(color);\n\n    rgbValues[0] = Math.min(255, (rgbValues[0] / step) * step);\n    rgbValues[1] = Math.min(255, (rgbValues[1] / step) * step);\n    rgbValues[2] = Math.min(255, (rgbValues[2] / step) * step);\n\n    return utils.rgb2hex(rgbValues);\n};\n\n/**\n * Number of steps which will be used as a cap when rounding colors.\n *\n * @member\n */\nCanvasTinter.cacheStepsPerColorChannel = 8;\n\n/**\n * Tint cache boolean flag.\n *\n * @member\n */\nCanvasTinter.convertTintToImage = false;\n\n/**\n * Whether or not the Canvas BlendModes are supported, consequently the ability to tint using the multiply method.\n *\n * @member\n */\nCanvasTinter.canUseMultiply = utils.canUseNewCanvasBlendModes();\n\n/**\n * The tinting method that will be used.\n *\n */\nCanvasTinter.tintMethod = CanvasTinter.canUseMultiply ? CanvasTinter.tintWithMultiply :  CanvasTinter.tintWithPerPixel;\n"]},"metadata":{},"sourceType":"script"}