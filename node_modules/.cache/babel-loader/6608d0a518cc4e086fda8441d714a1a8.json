{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('eventemitter3');\n\nvar parseUri = require('parse-uri'); // tests is CORS is supported in XHR, if not we need to use XDR\n\n\nvar useXdr = !!(window.XDomainRequest && !('withCredentials' in new XMLHttpRequest()));\nvar tempAnchor = null; // some status constants\n\nvar STATUS_NONE = 0;\nvar STATUS_OK = 200;\nvar STATUS_EMPTY = 204;\n/**\n * Manages the state and loading of a single resource represented by\n * a single URL.\n *\n * @class\n * @param {string} name - The name of the resource to load.\n * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass an array of sources.\n * @param {object} [options] - The options for the load.\n * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.\n * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?\n * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should the data being\n *      loaded be interpreted when using XHR?\n * @param {object} [options.metadata] - Extra info for middleware.\n */\n\nfunction Resource(name, url, options) {\n  EventEmitter.call(this);\n  options = options || {};\n\n  if (typeof name !== 'string' || typeof url !== 'string') {\n    throw new Error('Both name and url are required for constructing a resource.');\n  }\n  /**\n   * The name of this resource.\n   *\n   * @member {string}\n   * @readonly\n   */\n\n\n  this.name = name;\n  /**\n   * The url used to load this resource.\n   *\n   * @member {string}\n   * @readonly\n   */\n\n  this.url = url;\n  /**\n   * Stores whether or not this url is a data url.\n   *\n   * @member {boolean}\n   * @readonly\n   */\n\n  this.isDataUrl = this.url.indexOf('data:') === 0;\n  /**\n   * The data that was loaded by the resource.\n   *\n   * @member {any}\n   */\n\n  this.data = null;\n  /**\n   * Is this request cross-origin? If unset, determined automatically.\n   *\n   * @member {string}\n   */\n\n  this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n  /**\n   * The method of loading to use for this resource.\n   *\n   * @member {Resource.LOAD_TYPE}\n   */\n\n  this.loadType = options.loadType || this._determineLoadType();\n  /**\n   * The type used to load the resource via XHR. If unset, determined automatically.\n   *\n   * @member {string}\n   */\n\n  this.xhrType = options.xhrType;\n  /**\n   * Extra info for middleware, and controlling specifics about how the resource loads.\n   *\n   * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n   * Meaning it will modify it as it sees fit.\n   *\n   * @member {object}\n   * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n   *  element to use for loading, instead of creating one.\n   * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n   *  is useful if you want to pass in a `loadElement` that you already added load sources\n   *  to.\n   */\n\n  this.metadata = options.metadata || {};\n  /**\n   * The error that occurred while loading (if any).\n   *\n   * @member {Error}\n   * @readonly\n   */\n\n  this.error = null;\n  /**\n   * The XHR object that was used to load this resource. This is only set\n   * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n   *\n   * @member {XMLHttpRequest}\n   */\n\n  this.xhr = null;\n  /**\n   * Describes if this resource was loaded as json. Only valid after the resource\n   * has completely loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isJson = false;\n  /**\n   * Describes if this resource was loaded as xml. Only valid after the resource\n   * has completely loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isXml = false;\n  /**\n   * Describes if this resource was loaded as an image tag. Only valid after the resource\n   * has completely loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isImage = false;\n  /**\n   * Describes if this resource was loaded as an audio tag. Only valid after the resource\n   * has completely loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isAudio = false;\n  /**\n   * Describes if this resource was loaded as a video tag. Only valid after the resource\n   * has completely loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isVideo = false;\n  /**\n   * Describes if this resource has finished loading. Is true when the resource has completely\n   * loaded.\n   *\n   * @member {boolean}\n   */\n\n  this.isComplete = false;\n  /**\n   * Describes if this resource is currently loading. Is true when the resource starts loading,\n   * and is false again when complete.\n   *\n   * @member {boolean}\n   */\n\n  this.isLoading = false;\n  /**\n   * The `dequeue` method that will be used a storage place for the async queue dequeue method\n   * used privately by the loader.\n   *\n   * @private\n   * @member {function}\n   */\n\n  this._dequeue = null;\n  /**\n   * The `complete` function bound to this resource's context.\n   *\n   * @private\n   * @member {function}\n   */\n\n  this._boundComplete = this.complete.bind(this);\n  /**\n   * The `_onError` function bound to this resource's context.\n   *\n   * @private\n   * @member {function}\n   */\n\n  this._boundOnError = this._onError.bind(this);\n  /**\n   * The `_onProgress` function bound to this resource's context.\n   *\n   * @private\n   * @member {function}\n   */\n\n  this._boundOnProgress = this._onProgress.bind(this); // xhr callbacks\n\n  this._boundXhrOnError = this._xhrOnError.bind(this);\n  this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n  this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n  this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);\n  /**\n   * Emitted when the resource beings to load.\n   *\n   * @event start\n   * @memberof Resource#\n   */\n\n  /**\n   * Emitted each time progress of this resource load updates.\n   * Not all resources types and loader systems can support this event\n   * so sometimes it may not be available. If the resource\n   * is being loaded on a modern browser, using XHR, and the remote server\n   * properly sets Content-Length headers, then this will be available.\n   *\n   * @event progress\n   * @memberof Resource#\n   */\n\n  /**\n   * Emitted once this resource has loaded, if there was an error it will\n   * be in the `error` property.\n   *\n   * @event complete\n   * @memberof Resource#\n   */\n}\n\nResource.prototype = Object.create(EventEmitter.prototype);\nResource.prototype.constructor = Resource;\nmodule.exports = Resource;\n/**\n * Marks the resource as complete.\n *\n * @fires complete\n */\n\nResource.prototype.complete = function () {\n  // TODO: Clean this up in a wrapper or something...gross....\n  if (this.data && this.data.removeEventListener) {\n    this.data.removeEventListener('error', this._boundOnError, false);\n    this.data.removeEventListener('load', this._boundComplete, false);\n    this.data.removeEventListener('progress', this._boundOnProgress, false);\n    this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n  }\n\n  if (this.xhr) {\n    if (this.xhr.removeEventListener) {\n      this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n      this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n      this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n      this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n    } else {\n      this.xhr.onerror = null;\n      this.xhr.ontimeout = null;\n      this.xhr.onprogress = null;\n      this.xhr.onload = null;\n    }\n  }\n\n  if (this.isComplete) {\n    throw new Error('Complete called again for an already completed resource.');\n  }\n\n  this.isComplete = true;\n  this.isLoading = false;\n  this.emit('complete', this);\n};\n/**\n * Aborts the loading of this resource, with an optional message.\n *\n * @param {string} message - The message to use for the error\n */\n\n\nResource.prototype.abort = function (message) {\n  // abort can be called multiple times, ignore subsequent calls.\n  if (this.error) {\n    return;\n  } // store error\n\n\n  this.error = new Error(message); // abort the actual loading\n\n  if (this.xhr) {\n    this.xhr.abort();\n  } else if (this.xdr) {\n    this.xdr.abort();\n  } else if (this.data) {\n    // single source\n    if (typeof this.data.src !== 'undefined') {\n      this.data.src = '';\n    } // multi-source\n    else {\n        while (this.data.firstChild) {\n          this.data.removeChild(this.data.firstChild);\n        }\n      }\n  } // done now.\n\n\n  this.complete();\n};\n/**\n * Kicks off loading of this resource. This method is asynchronous.\n *\n * @fires start\n * @param {function} [cb] - Optional callback to call once the resource is loaded.\n */\n\n\nResource.prototype.load = function (cb) {\n  if (this.isLoading) {\n    return;\n  }\n\n  if (this.isComplete) {\n    if (cb) {\n      var self = this;\n      setTimeout(function () {\n        cb(self);\n      }, 1);\n    }\n\n    return;\n  } else if (cb) {\n    this.once('complete', cb);\n  }\n\n  this.isLoading = true;\n  this.emit('start', this); // if unset, determine the value\n\n  if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n    this.crossOrigin = this._determineCrossOrigin(this.url);\n  }\n\n  switch (this.loadType) {\n    case Resource.LOAD_TYPE.IMAGE:\n      this._loadElement('image');\n\n      break;\n\n    case Resource.LOAD_TYPE.AUDIO:\n      this._loadSourceElement('audio');\n\n      break;\n\n    case Resource.LOAD_TYPE.VIDEO:\n      this._loadSourceElement('video');\n\n      break;\n\n    case Resource.LOAD_TYPE.XHR:\n    /* falls through */\n\n    default:\n      if (useXdr && this.crossOrigin) {\n        this._loadXdr();\n      } else {\n        this._loadXhr();\n      }\n\n      break;\n  }\n};\n/**\n * Loads this resources using an element that has a single source,\n * like an HTMLImageElement.\n *\n * @private\n * @param {string} type - The type of element to use.\n */\n\n\nResource.prototype._loadElement = function (type) {\n  if (this.metadata.loadElement) {\n    this.data = this.metadata.loadElement;\n  } else if (type === 'image' && typeof window.Image !== 'undefined') {\n    this.data = new Image();\n  } else {\n    this.data = document.createElement(type);\n  }\n\n  if (this.crossOrigin) {\n    this.data.crossOrigin = this.crossOrigin;\n  }\n\n  if (!this.metadata.skipSource) {\n    this.data.src = this.url;\n  }\n\n  var typeName = 'is' + type[0].toUpperCase() + type.substring(1);\n\n  if (this[typeName] === false) {\n    this[typeName] = true;\n  }\n\n  this.data.addEventListener('error', this._boundOnError, false);\n  this.data.addEventListener('load', this._boundComplete, false);\n  this.data.addEventListener('progress', this._boundOnProgress, false);\n};\n/**\n * Loads this resources using an element that has multiple sources,\n * like an HTMLAudioElement or HTMLVideoElement.\n *\n * @private\n * @param {string} type - The type of element to use.\n */\n\n\nResource.prototype._loadSourceElement = function (type) {\n  if (this.metadata.loadElement) {\n    this.data = this.metadata.loadElement;\n  } else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n    this.data = new Audio();\n  } else {\n    this.data = document.createElement(type);\n  }\n\n  if (this.data === null) {\n    this.abort('Unsupported element ' + type);\n    return;\n  }\n\n  if (!this.metadata.skipSource) {\n    // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n    if (navigator.isCocoonJS) {\n      this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n    } else if (Array.isArray(this.url)) {\n      for (var i = 0; i < this.url.length; ++i) {\n        this.data.appendChild(this._createSource(type, this.url[i]));\n      }\n    } else {\n      this.data.appendChild(this._createSource(type, this.url));\n    }\n  }\n\n  this['is' + type[0].toUpperCase() + type.substring(1)] = true;\n  this.data.addEventListener('error', this._boundOnError, false);\n  this.data.addEventListener('load', this._boundComplete, false);\n  this.data.addEventListener('progress', this._boundOnProgress, false);\n  this.data.addEventListener('canplaythrough', this._boundComplete, false);\n  this.data.load();\n};\n/**\n * Loads this resources using an XMLHttpRequest.\n *\n * @private\n */\n\n\nResource.prototype._loadXhr = function () {\n  // if unset, determine the value\n  if (typeof this.xhrType !== 'string') {\n    this.xhrType = this._determineXhrType();\n  }\n\n  var xhr = this.xhr = new XMLHttpRequest(); // set the request type and url\n\n  xhr.open('GET', this.url, true); // load json as text and parse it ourselves. We do this because some browsers\n  // *cough* safari *cough* can't deal with it.\n\n  if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n    xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n  } else {\n    xhr.responseType = this.xhrType;\n  }\n\n  xhr.addEventListener('error', this._boundXhrOnError, false);\n  xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n  xhr.addEventListener('progress', this._boundOnProgress, false);\n  xhr.addEventListener('load', this._boundXhrOnLoad, false);\n  xhr.send();\n};\n/**\n * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n *\n * @private\n */\n\n\nResource.prototype._loadXdr = function () {\n  // if unset, determine the value\n  if (typeof this.xhrType !== 'string') {\n    this.xhrType = this._determineXhrType();\n  }\n\n  var xdr = this.xhr = new XDomainRequest(); // XDomainRequest has a few quirks. Occasionally it will abort requests\n  // A way to avoid this is to make sure ALL callbacks are set even if not used\n  // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n\n  xdr.timeout = 5000;\n  xdr.onerror = this._boundXhrOnError;\n  xdr.ontimeout = this._boundXdrOnTimeout;\n  xdr.onprogress = this._boundOnProgress;\n  xdr.onload = this._boundXhrOnLoad;\n  xdr.open('GET', this.url, true); // Note: The xdr.send() call is wrapped in a timeout to prevent an\n  // issue with the interface where some requests are lost if multiple\n  // XDomainRequests are being sent at the same time.\n  // Some info here: https://github.com/photonstorm/phaser/issues/1248\n\n  setTimeout(function () {\n    xdr.send();\n  }, 0);\n};\n/**\n * Creates a source used in loading via an element.\n *\n * @private\n * @param {string} type - The element type (video or audio).\n * @param {string} url - The source URL to load from.\n * @param {string} [mime] - The mime type of the video\n * @return {HTMLSourceElement} The source element.\n */\n\n\nResource.prototype._createSource = function (type, url, mime) {\n  if (!mime) {\n    mime = type + '/' + url.substr(url.lastIndexOf('.') + 1);\n  }\n\n  var source = document.createElement('source');\n  source.src = url;\n  source.type = mime;\n  return source;\n};\n/**\n * Called if a load errors out.\n *\n * @param {Event} event - The error event from the element that emits it.\n * @private\n */\n\n\nResource.prototype._onError = function (event) {\n  this.abort('Failed to load element using ' + event.target.nodeName);\n};\n/**\n * Called if a load progress event fires for xhr/xdr.\n *\n * @fires progress\n * @private\n * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n */\n\n\nResource.prototype._onProgress = function (event) {\n  if (event && event.lengthComputable) {\n    this.emit('progress', this, event.loaded / event.total);\n  }\n};\n/**\n * Called if an error event fires for xhr/xdr.\n *\n * @private\n * @param {XMLHttpRequestErrorEvent|Event} event - Error event.\n */\n\n\nResource.prototype._xhrOnError = function () {\n  var xhr = this.xhr;\n  this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: \"' + xhr.statusText + '\"');\n};\n/**\n * Called if an abort event fires for xhr.\n *\n * @private\n * @param {XMLHttpRequestAbortEvent} event - Abort Event\n */\n\n\nResource.prototype._xhrOnAbort = function () {\n  this.abort(reqType(this.xhr) + ' Request was aborted by the user.');\n};\n/**\n * Called if a timeout event fires for xdr.\n *\n * @private\n * @param {Event} event - Timeout event.\n */\n\n\nResource.prototype._xdrOnTimeout = function () {\n  this.abort(reqType(this.xhr) + ' Request timed out.');\n};\n/**\n * Called when data successfully loads from an xhr/xdr request.\n *\n * @private\n * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n */\n\n\nResource.prototype._xhrOnLoad = function () {\n  var xhr = this.xhr;\n  var status = typeof xhr.status === 'undefined' ? xhr.status : STATUS_OK; // XDR has no `.status`, assume 200.\n  // status can be 0 when using the file:// protocol, also check if a response was found\n\n  if (status === STATUS_OK || status === STATUS_EMPTY || status === STATUS_NONE && xhr.responseText.length > 0) {\n    // if text, just return it\n    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n      this.data = xhr.responseText;\n    } // if json, parse into json object\n    else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n        try {\n          this.data = JSON.parse(xhr.responseText);\n          this.isJson = true;\n        } catch (e) {\n          this.abort('Error trying to parse loaded json:', e);\n          return;\n        }\n      } // if xml, parse into an xml document or div element\n      else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n          try {\n            if (window.DOMParser) {\n              var domparser = new DOMParser();\n              this.data = domparser.parseFromString(xhr.responseText, 'text/xml');\n            } else {\n              var div = document.createElement('div');\n              div.innerHTML = xhr.responseText;\n              this.data = div;\n            }\n\n            this.isXml = true;\n          } catch (e) {\n            this.abort('Error trying to parse loaded xml:', e);\n            return;\n          }\n        } // other types just return the response\n        else {\n            this.data = xhr.response || xhr.responseText;\n          }\n  } else {\n    this.abort('[' + xhr.status + ']' + xhr.statusText + ':' + xhr.responseURL);\n    return;\n  }\n\n  this.complete();\n};\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n *\n * @private\n * @param {string} url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @return {string} The crossOrigin value to use (or empty string for none).\n */\n\n\nResource.prototype._determineCrossOrigin = function (url, loc) {\n  // data: and javascript: urls are considered same-origin\n  if (url.indexOf('data:') === 0) {\n    return '';\n  } // default is window.location\n\n\n  loc = loc || window.location;\n\n  if (!tempAnchor) {\n    tempAnchor = document.createElement('a');\n  } // let the browser determine the full href for the url of this resource and then\n  // parse with the node url lib, we can't use the properties of the anchor element\n  // because they don't work in IE9 :(\n\n\n  tempAnchor.href = url;\n  url = parseUri(tempAnchor.href, {\n    strictMode: true\n  });\n  var samePort = !url.port && loc.port === '' || url.port === loc.port;\n  var protocol = url.protocol ? url.protocol + ':' : ''; // if cross origin\n\n  if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n    return 'anonymous';\n  }\n\n  return '';\n};\n/**\n * Determines the responseType of an XHR request based on the extension of the\n * resource being loaded.\n *\n * @private\n * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n */\n\n\nResource.prototype._determineXhrType = function () {\n  return Resource._xhrTypeMap[this._getExtension()] || Resource.XHR_RESPONSE_TYPE.TEXT;\n};\n\nResource.prototype._determineLoadType = function () {\n  return Resource._loadTypeMap[this._getExtension()] || Resource.LOAD_TYPE.XHR;\n};\n\nResource.prototype._getExtension = function () {\n  var url = this.url;\n  var ext = '';\n\n  if (this.isDataUrl) {\n    var slashIndex = url.indexOf('/');\n    ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n  } else {\n    var queryStart = url.indexOf('?');\n\n    if (queryStart !== -1) {\n      url = url.substring(0, queryStart);\n    }\n\n    ext = url.substring(url.lastIndexOf('.') + 1);\n  }\n\n  return ext.toLowerCase();\n};\n/**\n * Determines the mime type of an XHR request based on the responseType of\n * resource being loaded.\n *\n * @private\n * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n * @return {string} The mime type to use.\n */\n\n\nResource.prototype._getMimeFromXhrType = function (type) {\n  switch (type) {\n    case Resource.XHR_RESPONSE_TYPE.BUFFER:\n      return 'application/octet-binary';\n\n    case Resource.XHR_RESPONSE_TYPE.BLOB:\n      return 'application/blob';\n\n    case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n      return 'application/xml';\n\n    case Resource.XHR_RESPONSE_TYPE.JSON:\n      return 'application/json';\n\n    case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n    case Resource.XHR_RESPONSE_TYPE.TEXT:\n    /* falls through */\n\n    default:\n      return 'text/plain';\n  }\n};\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\n\n\nfunction reqType(xhr) {\n  return xhr.toString().replace('object ', '');\n}\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\n\n\nResource.LOAD_TYPE = {\n  /** Uses XMLHttpRequest to load the resource. */\n  XHR: 1,\n\n  /** Uses an `Image` object to load the resource. */\n  IMAGE: 2,\n\n  /** Uses an `Audio` object to load the resource. */\n  AUDIO: 3,\n\n  /** Uses a `Video` object to load the resource. */\n  VIDEO: 4\n};\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\n\nResource.XHR_RESPONSE_TYPE = {\n  /** defaults to text */\n  DEFAULT: 'text',\n\n  /** ArrayBuffer */\n  BUFFER: 'arraybuffer',\n\n  /** Blob */\n  BLOB: 'blob',\n\n  /** Document */\n  DOCUMENT: 'document',\n\n  /** Object */\n  JSON: 'json',\n\n  /** String */\n  TEXT: 'text'\n};\nResource._loadTypeMap = {\n  gif: Resource.LOAD_TYPE.IMAGE,\n  png: Resource.LOAD_TYPE.IMAGE,\n  bmp: Resource.LOAD_TYPE.IMAGE,\n  jpg: Resource.LOAD_TYPE.IMAGE,\n  jpeg: Resource.LOAD_TYPE.IMAGE,\n  tif: Resource.LOAD_TYPE.IMAGE,\n  tiff: Resource.LOAD_TYPE.IMAGE,\n  webp: Resource.LOAD_TYPE.IMAGE,\n  tga: Resource.LOAD_TYPE.IMAGE,\n  'svg+xml': Resource.LOAD_TYPE.IMAGE\n};\nResource._xhrTypeMap = {\n  // xml\n  xhtml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  html: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  htm: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  xml: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  tmx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  tsx: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  svg: Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n  // images\n  gif: Resource.XHR_RESPONSE_TYPE.BLOB,\n  png: Resource.XHR_RESPONSE_TYPE.BLOB,\n  bmp: Resource.XHR_RESPONSE_TYPE.BLOB,\n  jpg: Resource.XHR_RESPONSE_TYPE.BLOB,\n  jpeg: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tif: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tiff: Resource.XHR_RESPONSE_TYPE.BLOB,\n  webp: Resource.XHR_RESPONSE_TYPE.BLOB,\n  tga: Resource.XHR_RESPONSE_TYPE.BLOB,\n  // json\n  json: Resource.XHR_RESPONSE_TYPE.JSON,\n  // text\n  text: Resource.XHR_RESPONSE_TYPE.TEXT,\n  txt: Resource.XHR_RESPONSE_TYPE.TEXT\n};\n/**\n * Sets the load type to be used for a specific extension.\n *\n * @static\n * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n */\n\nResource.setExtensionLoadType = function (extname, loadType) {\n  setExtMap(Resource._loadTypeMap, extname, loadType);\n};\n/**\n * Sets the load type to be used for a specific extension.\n *\n * @static\n * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n */\n\n\nResource.setExtensionXhrType = function (extname, xhrType) {\n  setExtMap(Resource._xhrTypeMap, extname, xhrType);\n};\n\nfunction setExtMap(map, extname, val) {\n  if (extname && extname.indexOf('.') === 0) {\n    extname = extname.substring(1);\n  }\n\n  if (!extname) {\n    return;\n  }\n\n  map[extname] = val;\n}","map":{"version":3,"sources":["/Users/thebe/Desktop/music-generator-app/node_modules/resource-loader/src/Resource.js"],"names":["EventEmitter","require","parseUri","useXdr","window","XDomainRequest","XMLHttpRequest","tempAnchor","STATUS_NONE","STATUS_OK","STATUS_EMPTY","Resource","name","url","options","call","Error","isDataUrl","indexOf","data","crossOrigin","loadType","_determineLoadType","xhrType","metadata","error","xhr","isJson","isXml","isImage","isAudio","isVideo","isComplete","isLoading","_dequeue","_boundComplete","complete","bind","_boundOnError","_onError","_boundOnProgress","_onProgress","_boundXhrOnError","_xhrOnError","_boundXhrOnAbort","_xhrOnAbort","_boundXhrOnLoad","_xhrOnLoad","_boundXdrOnTimeout","_xdrOnTimeout","prototype","Object","create","constructor","module","exports","removeEventListener","onerror","ontimeout","onprogress","onload","emit","abort","message","xdr","src","firstChild","removeChild","load","cb","self","setTimeout","once","_determineCrossOrigin","LOAD_TYPE","IMAGE","_loadElement","AUDIO","_loadSourceElement","VIDEO","XHR","_loadXdr","_loadXhr","type","loadElement","Image","document","createElement","skipSource","typeName","toUpperCase","substring","addEventListener","Audio","navigator","isCocoonJS","Array","isArray","i","length","appendChild","_createSource","_determineXhrType","open","XHR_RESPONSE_TYPE","JSON","DOCUMENT","responseType","TEXT","send","timeout","mime","substr","lastIndexOf","source","event","target","nodeName","lengthComputable","loaded","total","reqType","status","statusText","responseText","parse","e","DOMParser","domparser","parseFromString","div","innerHTML","response","responseURL","loc","location","href","strictMode","samePort","port","protocol","host","hostname","_xhrTypeMap","_getExtension","_loadTypeMap","ext","slashIndex","queryStart","toLowerCase","_getMimeFromXhrType","BUFFER","BLOB","DEFAULT","toString","replace","gif","png","bmp","jpg","jpeg","tif","tiff","webp","tga","xhtml","html","htm","xml","tmx","tsx","svg","json","text","txt","setExtensionLoadType","extname","setExtMap","setExtensionXhrType","map","val"],"mappings":"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","sourcesContent":["'use strict';\n\nvar EventEmitter    = require('eventemitter3');\nvar parseUri        = require('parse-uri');\n\n// tests is CORS is supported in XHR, if not we need to use XDR\nvar useXdr = !!(window.XDomainRequest && !('withCredentials' in (new XMLHttpRequest())));\nvar tempAnchor = null;\n\n// some status constants\nvar STATUS_NONE = 0;\nvar STATUS_OK = 200;\nvar STATUS_EMPTY = 204;\n\n/**\n * Manages the state and loading of a single resource represented by\n * a single URL.\n *\n * @class\n * @param {string} name - The name of the resource to load.\n * @param {string|string[]} url - The url for this resource, for audio/video loads you can pass an array of sources.\n * @param {object} [options] - The options for the load.\n * @param {string|boolean} [options.crossOrigin] - Is this request cross-origin? Default is to determine automatically.\n * @param {Resource.LOAD_TYPE} [options.loadType=Resource.LOAD_TYPE.XHR] - How should this resource be loaded?\n * @param {Resource.XHR_RESPONSE_TYPE} [options.xhrType=Resource.XHR_RESPONSE_TYPE.DEFAULT] - How should the data being\n *      loaded be interpreted when using XHR?\n * @param {object} [options.metadata] - Extra info for middleware.\n */\nfunction Resource(name, url, options) {\n    EventEmitter.call(this);\n\n    options = options || {};\n\n    if (typeof name !== 'string' || typeof url !== 'string') {\n        throw new Error('Both name and url are required for constructing a resource.');\n    }\n\n    /**\n     * The name of this resource.\n     *\n     * @member {string}\n     * @readonly\n     */\n    this.name = name;\n\n    /**\n     * The url used to load this resource.\n     *\n     * @member {string}\n     * @readonly\n     */\n    this.url = url;\n\n    /**\n     * Stores whether or not this url is a data url.\n     *\n     * @member {boolean}\n     * @readonly\n     */\n    this.isDataUrl = this.url.indexOf('data:') === 0;\n\n    /**\n     * The data that was loaded by the resource.\n     *\n     * @member {any}\n     */\n    this.data = null;\n\n    /**\n     * Is this request cross-origin? If unset, determined automatically.\n     *\n     * @member {string}\n     */\n    this.crossOrigin = options.crossOrigin === true ? 'anonymous' : options.crossOrigin;\n\n    /**\n     * The method of loading to use for this resource.\n     *\n     * @member {Resource.LOAD_TYPE}\n     */\n    this.loadType = options.loadType || this._determineLoadType();\n\n    /**\n     * The type used to load the resource via XHR. If unset, determined automatically.\n     *\n     * @member {string}\n     */\n    this.xhrType = options.xhrType;\n\n    /**\n     * Extra info for middleware, and controlling specifics about how the resource loads.\n     *\n     * Note that if you pass in a `loadElement`, the Resource class takes ownership of it.\n     * Meaning it will modify it as it sees fit.\n     *\n     * @member {object}\n     * @property {HTMLImageElement|HTMLAudioElement|HTMLVideoElement} [loadElement=null] - The\n     *  element to use for loading, instead of creating one.\n     * @property {boolean} [skipSource=false] - Skips adding source(s) to the load element. This\n     *  is useful if you want to pass in a `loadElement` that you already added load sources\n     *  to.\n     */\n    this.metadata = options.metadata || {};\n\n    /**\n     * The error that occurred while loading (if any).\n     *\n     * @member {Error}\n     * @readonly\n     */\n    this.error = null;\n\n    /**\n     * The XHR object that was used to load this resource. This is only set\n     * when `loadType` is `Resource.LOAD_TYPE.XHR`.\n     *\n     * @member {XMLHttpRequest}\n     */\n    this.xhr = null;\n\n    /**\n     * Describes if this resource was loaded as json. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isJson = false;\n\n    /**\n     * Describes if this resource was loaded as xml. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isXml = false;\n\n    /**\n     * Describes if this resource was loaded as an image tag. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isImage = false;\n\n    /**\n     * Describes if this resource was loaded as an audio tag. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isAudio = false;\n\n    /**\n     * Describes if this resource was loaded as a video tag. Only valid after the resource\n     * has completely loaded.\n     *\n     * @member {boolean}\n     */\n    this.isVideo = false;\n\n    /**\n     * Describes if this resource has finished loading. Is true when the resource has completely\n     * loaded.\n     *\n     * @member {boolean}\n     */\n    this.isComplete = false;\n\n    /**\n     * Describes if this resource is currently loading. Is true when the resource starts loading,\n     * and is false again when complete.\n     *\n     * @member {boolean}\n     */\n    this.isLoading = false;\n\n    /**\n     * The `dequeue` method that will be used a storage place for the async queue dequeue method\n     * used privately by the loader.\n     *\n     * @private\n     * @member {function}\n     */\n    this._dequeue = null;\n\n    /**\n     * The `complete` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundComplete = this.complete.bind(this);\n\n    /**\n     * The `_onError` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundOnError = this._onError.bind(this);\n\n    /**\n     * The `_onProgress` function bound to this resource's context.\n     *\n     * @private\n     * @member {function}\n     */\n    this._boundOnProgress = this._onProgress.bind(this);\n\n    // xhr callbacks\n    this._boundXhrOnError = this._xhrOnError.bind(this);\n    this._boundXhrOnAbort = this._xhrOnAbort.bind(this);\n    this._boundXhrOnLoad = this._xhrOnLoad.bind(this);\n    this._boundXdrOnTimeout = this._xdrOnTimeout.bind(this);\n\n    /**\n     * Emitted when the resource beings to load.\n     *\n     * @event start\n     * @memberof Resource#\n     */\n\n    /**\n     * Emitted each time progress of this resource load updates.\n     * Not all resources types and loader systems can support this event\n     * so sometimes it may not be available. If the resource\n     * is being loaded on a modern browser, using XHR, and the remote server\n     * properly sets Content-Length headers, then this will be available.\n     *\n     * @event progress\n     * @memberof Resource#\n     */\n\n    /**\n     * Emitted once this resource has loaded, if there was an error it will\n     * be in the `error` property.\n     *\n     * @event complete\n     * @memberof Resource#\n     */\n}\n\nResource.prototype = Object.create(EventEmitter.prototype);\nResource.prototype.constructor = Resource;\nmodule.exports = Resource;\n\n/**\n * Marks the resource as complete.\n *\n * @fires complete\n */\nResource.prototype.complete = function () {\n    // TODO: Clean this up in a wrapper or something...gross....\n    if (this.data && this.data.removeEventListener) {\n        this.data.removeEventListener('error', this._boundOnError, false);\n        this.data.removeEventListener('load', this._boundComplete, false);\n        this.data.removeEventListener('progress', this._boundOnProgress, false);\n        this.data.removeEventListener('canplaythrough', this._boundComplete, false);\n    }\n\n    if (this.xhr) {\n        if (this.xhr.removeEventListener) {\n            this.xhr.removeEventListener('error', this._boundXhrOnError, false);\n            this.xhr.removeEventListener('abort', this._boundXhrOnAbort, false);\n            this.xhr.removeEventListener('progress', this._boundOnProgress, false);\n            this.xhr.removeEventListener('load', this._boundXhrOnLoad, false);\n        }\n        else {\n            this.xhr.onerror = null;\n            this.xhr.ontimeout = null;\n            this.xhr.onprogress = null;\n            this.xhr.onload = null;\n        }\n    }\n\n    if (this.isComplete) {\n        throw new Error('Complete called again for an already completed resource.');\n    }\n\n    this.isComplete = true;\n    this.isLoading = false;\n\n    this.emit('complete', this);\n};\n\n/**\n * Aborts the loading of this resource, with an optional message.\n *\n * @param {string} message - The message to use for the error\n */\nResource.prototype.abort = function (message) {\n    // abort can be called multiple times, ignore subsequent calls.\n    if (this.error) {\n        return;\n    }\n\n    // store error\n    this.error = new Error(message);\n\n    // abort the actual loading\n    if (this.xhr) {\n        this.xhr.abort();\n    }\n    else if (this.xdr) {\n        this.xdr.abort();\n    }\n    else if (this.data) {\n        // single source\n        if (typeof this.data.src !== 'undefined') {\n            this.data.src = '';\n        }\n        // multi-source\n        else {\n            while (this.data.firstChild) {\n                this.data.removeChild(this.data.firstChild);\n            }\n        }\n    }\n\n    // done now.\n    this.complete();\n};\n\n/**\n * Kicks off loading of this resource. This method is asynchronous.\n *\n * @fires start\n * @param {function} [cb] - Optional callback to call once the resource is loaded.\n */\nResource.prototype.load = function (cb) {\n    if (this.isLoading) {\n        return;\n    }\n\n    if (this.isComplete) {\n        if (cb) {\n            var self = this;\n\n            setTimeout(function () {\n                cb(self);\n            }, 1);\n        }\n\n        return;\n    }\n    else if (cb) {\n        this.once('complete', cb);\n    }\n\n    this.isLoading = true;\n\n    this.emit('start', this);\n\n    // if unset, determine the value\n    if (this.crossOrigin === false || typeof this.crossOrigin !== 'string') {\n        this.crossOrigin = this._determineCrossOrigin(this.url);\n    }\n\n    switch (this.loadType) {\n        case Resource.LOAD_TYPE.IMAGE:\n            this._loadElement('image');\n            break;\n\n        case Resource.LOAD_TYPE.AUDIO:\n            this._loadSourceElement('audio');\n            break;\n\n        case Resource.LOAD_TYPE.VIDEO:\n            this._loadSourceElement('video');\n            break;\n\n        case Resource.LOAD_TYPE.XHR:\n            /* falls through */\n        default:\n            if (useXdr && this.crossOrigin) {\n                this._loadXdr();\n            }\n            else {\n                this._loadXhr();\n            }\n            break;\n    }\n};\n\n/**\n * Loads this resources using an element that has a single source,\n * like an HTMLImageElement.\n *\n * @private\n * @param {string} type - The type of element to use.\n */\nResource.prototype._loadElement = function (type) {\n    if (this.metadata.loadElement) {\n        this.data = this.metadata.loadElement;\n    }\n    else if (type === 'image' && typeof window.Image !== 'undefined') {\n        this.data = new Image();\n    }\n    else {\n        this.data = document.createElement(type);\n    }\n\n    if (this.crossOrigin) {\n        this.data.crossOrigin = this.crossOrigin;\n    }\n\n    if (!this.metadata.skipSource) {\n        this.data.src = this.url;\n    }\n\n    var typeName = 'is' + type[0].toUpperCase() + type.substring(1);\n\n    if (this[typeName] === false) {\n        this[typeName] = true;\n    }\n\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n};\n\n/**\n * Loads this resources using an element that has multiple sources,\n * like an HTMLAudioElement or HTMLVideoElement.\n *\n * @private\n * @param {string} type - The type of element to use.\n */\nResource.prototype._loadSourceElement = function (type) {\n    if (this.metadata.loadElement) {\n        this.data = this.metadata.loadElement;\n    }\n    else if (type === 'audio' && typeof window.Audio !== 'undefined') {\n        this.data = new Audio();\n    }\n    else {\n        this.data = document.createElement(type);\n    }\n\n    if (this.data === null) {\n        this.abort('Unsupported element ' + type);\n\n        return;\n    }\n\n    if (!this.metadata.skipSource) {\n        // support for CocoonJS Canvas+ runtime, lacks document.createElement('source')\n        if (navigator.isCocoonJS) {\n            this.data.src = Array.isArray(this.url) ? this.url[0] : this.url;\n        }\n        else if (Array.isArray(this.url)) {\n            for (var i = 0; i < this.url.length; ++i) {\n                this.data.appendChild(this._createSource(type, this.url[i]));\n            }\n        }\n        else {\n            this.data.appendChild(this._createSource(type, this.url));\n        }\n    }\n\n    this['is' + type[0].toUpperCase() + type.substring(1)] = true;\n\n    this.data.addEventListener('error', this._boundOnError, false);\n    this.data.addEventListener('load', this._boundComplete, false);\n    this.data.addEventListener('progress', this._boundOnProgress, false);\n    this.data.addEventListener('canplaythrough', this._boundComplete, false);\n\n    this.data.load();\n};\n\n/**\n * Loads this resources using an XMLHttpRequest.\n *\n * @private\n */\nResource.prototype._loadXhr = function () {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n        this.xhrType = this._determineXhrType();\n    }\n\n    var xhr = this.xhr = new XMLHttpRequest();\n\n    // set the request type and url\n    xhr.open('GET', this.url, true);\n\n    // load json as text and parse it ourselves. We do this because some browsers\n    // *cough* safari *cough* can't deal with it.\n    if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON || this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n        xhr.responseType = Resource.XHR_RESPONSE_TYPE.TEXT;\n    }\n    else {\n        xhr.responseType = this.xhrType;\n    }\n\n    xhr.addEventListener('error', this._boundXhrOnError, false);\n    xhr.addEventListener('abort', this._boundXhrOnAbort, false);\n    xhr.addEventListener('progress', this._boundOnProgress, false);\n    xhr.addEventListener('load', this._boundXhrOnLoad, false);\n\n    xhr.send();\n};\n\n/**\n * Loads this resources using an XDomainRequest. This is here because we need to support IE9 (gross).\n *\n * @private\n */\nResource.prototype._loadXdr = function () {\n    // if unset, determine the value\n    if (typeof this.xhrType !== 'string') {\n        this.xhrType = this._determineXhrType();\n    }\n\n    var xdr = this.xhr = new XDomainRequest();\n\n    // XDomainRequest has a few quirks. Occasionally it will abort requests\n    // A way to avoid this is to make sure ALL callbacks are set even if not used\n    // More info here: http://stackoverflow.com/questions/15786966/xdomainrequest-aborts-post-on-ie-9\n    xdr.timeout = 5000;\n\n    xdr.onerror = this._boundXhrOnError;\n    xdr.ontimeout = this._boundXdrOnTimeout;\n    xdr.onprogress = this._boundOnProgress;\n    xdr.onload = this._boundXhrOnLoad;\n\n    xdr.open('GET', this.url, true);\n\n    // Note: The xdr.send() call is wrapped in a timeout to prevent an\n    // issue with the interface where some requests are lost if multiple\n    // XDomainRequests are being sent at the same time.\n    // Some info here: https://github.com/photonstorm/phaser/issues/1248\n    setTimeout(function () {\n        xdr.send();\n    }, 0);\n};\n\n/**\n * Creates a source used in loading via an element.\n *\n * @private\n * @param {string} type - The element type (video or audio).\n * @param {string} url - The source URL to load from.\n * @param {string} [mime] - The mime type of the video\n * @return {HTMLSourceElement} The source element.\n */\nResource.prototype._createSource = function (type, url, mime) {\n    if (!mime) {\n        mime = type + '/' + url.substr(url.lastIndexOf('.') + 1);\n    }\n\n    var source = document.createElement('source');\n\n    source.src = url;\n    source.type = mime;\n\n    return source;\n};\n\n/**\n * Called if a load errors out.\n *\n * @param {Event} event - The error event from the element that emits it.\n * @private\n */\nResource.prototype._onError = function (event) {\n    this.abort('Failed to load element using ' + event.target.nodeName);\n};\n\n/**\n * Called if a load progress event fires for xhr/xdr.\n *\n * @fires progress\n * @private\n * @param {XMLHttpRequestProgressEvent|Event} event - Progress event.\n */\nResource.prototype._onProgress = function (event) {\n    if (event && event.lengthComputable) {\n        this.emit('progress', this, event.loaded / event.total);\n    }\n};\n\n/**\n * Called if an error event fires for xhr/xdr.\n *\n * @private\n * @param {XMLHttpRequestErrorEvent|Event} event - Error event.\n */\nResource.prototype._xhrOnError = function () {\n    var xhr = this.xhr;\n\n    this.abort(reqType(xhr) + ' Request failed. Status: ' + xhr.status + ', text: \"' + xhr.statusText + '\"');\n};\n\n/**\n * Called if an abort event fires for xhr.\n *\n * @private\n * @param {XMLHttpRequestAbortEvent} event - Abort Event\n */\nResource.prototype._xhrOnAbort = function () {\n    this.abort(reqType(this.xhr) + ' Request was aborted by the user.');\n};\n\n/**\n * Called if a timeout event fires for xdr.\n *\n * @private\n * @param {Event} event - Timeout event.\n */\nResource.prototype._xdrOnTimeout = function () {\n    this.abort(reqType(this.xhr) + ' Request timed out.');\n};\n\n/**\n * Called when data successfully loads from an xhr/xdr request.\n *\n * @private\n * @param {XMLHttpRequestLoadEvent|Event} event - Load event\n */\nResource.prototype._xhrOnLoad = function () {\n    var xhr = this.xhr;\n    var status = typeof xhr.status === 'undefined' ? xhr.status : STATUS_OK; // XDR has no `.status`, assume 200.\n\n    // status can be 0 when using the file:// protocol, also check if a response was found\n    if (status === STATUS_OK || status === STATUS_EMPTY || (status === STATUS_NONE && xhr.responseText.length > 0)) {\n        // if text, just return it\n        if (this.xhrType === Resource.XHR_RESPONSE_TYPE.TEXT) {\n            this.data = xhr.responseText;\n        }\n        // if json, parse into json object\n        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.JSON) {\n            try {\n                this.data = JSON.parse(xhr.responseText);\n                this.isJson = true;\n            }\n            catch (e) {\n                this.abort('Error trying to parse loaded json:', e);\n\n                return;\n            }\n        }\n        // if xml, parse into an xml document or div element\n        else if (this.xhrType === Resource.XHR_RESPONSE_TYPE.DOCUMENT) {\n            try {\n                if (window.DOMParser) {\n                    var domparser = new DOMParser();\n\n                    this.data = domparser.parseFromString(xhr.responseText, 'text/xml');\n                }\n                else {\n                    var div = document.createElement('div');\n\n                    div.innerHTML = xhr.responseText;\n                    this.data = div;\n                }\n                this.isXml = true;\n            }\n            catch (e) {\n                this.abort('Error trying to parse loaded xml:', e);\n\n                return;\n            }\n        }\n        // other types just return the response\n        else {\n            this.data = xhr.response || xhr.responseText;\n        }\n    }\n    else {\n        this.abort('[' + xhr.status + ']' + xhr.statusText + ':' + xhr.responseURL);\n\n        return;\n    }\n\n    this.complete();\n};\n\n/**\n * Sets the `crossOrigin` property for this resource based on if the url\n * for this resource is cross-origin. If crossOrigin was manually set, this\n * function does nothing.\n *\n * @private\n * @param {string} url - The url to test.\n * @param {object} [loc=window.location] - The location object to test against.\n * @return {string} The crossOrigin value to use (or empty string for none).\n */\nResource.prototype._determineCrossOrigin = function (url, loc) {\n    // data: and javascript: urls are considered same-origin\n    if (url.indexOf('data:') === 0) {\n        return '';\n    }\n\n    // default is window.location\n    loc = loc || window.location;\n\n    if (!tempAnchor) {\n        tempAnchor = document.createElement('a');\n    }\n\n    // let the browser determine the full href for the url of this resource and then\n    // parse with the node url lib, we can't use the properties of the anchor element\n    // because they don't work in IE9 :(\n    tempAnchor.href = url;\n    url = parseUri(tempAnchor.href, { strictMode: true });\n\n    var samePort = (!url.port && loc.port === '') || (url.port === loc.port);\n    var protocol = url.protocol ? url.protocol + ':' : '';\n\n    // if cross origin\n    if (url.host !== loc.hostname || !samePort || protocol !== loc.protocol) {\n        return 'anonymous';\n    }\n\n    return '';\n};\n\n/**\n * Determines the responseType of an XHR request based on the extension of the\n * resource being loaded.\n *\n * @private\n * @return {Resource.XHR_RESPONSE_TYPE} The responseType to use.\n */\nResource.prototype._determineXhrType = function () {\n    return Resource._xhrTypeMap[this._getExtension()] || Resource.XHR_RESPONSE_TYPE.TEXT;\n};\n\nResource.prototype._determineLoadType = function () {\n    return Resource._loadTypeMap[this._getExtension()] || Resource.LOAD_TYPE.XHR;\n};\n\nResource.prototype._getExtension = function () {\n    var url = this.url;\n    var ext = '';\n\n    if (this.isDataUrl) {\n        var slashIndex = url.indexOf('/');\n\n        ext = url.substring(slashIndex + 1, url.indexOf(';', slashIndex));\n    }\n    else {\n        var queryStart = url.indexOf('?');\n\n        if (queryStart !== -1) {\n            url = url.substring(0, queryStart);\n        }\n\n        ext = url.substring(url.lastIndexOf('.') + 1);\n    }\n\n    return ext.toLowerCase();\n};\n\n/**\n * Determines the mime type of an XHR request based on the responseType of\n * resource being loaded.\n *\n * @private\n * @param {Resource.XHR_RESPONSE_TYPE} type - The type to get a mime type for.\n * @return {string} The mime type to use.\n */\nResource.prototype._getMimeFromXhrType = function (type) {\n    switch (type) {\n        case Resource.XHR_RESPONSE_TYPE.BUFFER:\n            return 'application/octet-binary';\n\n        case Resource.XHR_RESPONSE_TYPE.BLOB:\n            return 'application/blob';\n\n        case Resource.XHR_RESPONSE_TYPE.DOCUMENT:\n            return 'application/xml';\n\n        case Resource.XHR_RESPONSE_TYPE.JSON:\n            return 'application/json';\n\n        case Resource.XHR_RESPONSE_TYPE.DEFAULT:\n        case Resource.XHR_RESPONSE_TYPE.TEXT:\n            /* falls through */\n        default:\n            return 'text/plain';\n\n    }\n};\n\n/**\n * Quick helper to get string xhr type.\n *\n * @ignore\n * @param {XMLHttpRequest|XDomainRequest} xhr - The request to check.\n * @return {string} The type.\n */\nfunction reqType(xhr) {\n    return xhr.toString().replace('object ', '');\n}\n\n/**\n * The types of loading a resource can use.\n *\n * @static\n * @readonly\n * @enum {number}\n */\nResource.LOAD_TYPE = {\n    /** Uses XMLHttpRequest to load the resource. */\n    XHR:    1,\n    /** Uses an `Image` object to load the resource. */\n    IMAGE:  2,\n    /** Uses an `Audio` object to load the resource. */\n    AUDIO:  3,\n    /** Uses a `Video` object to load the resource. */\n    VIDEO:  4\n};\n\n/**\n * The XHR ready states, used internally.\n *\n * @static\n * @readonly\n * @enum {string}\n */\nResource.XHR_RESPONSE_TYPE = {\n    /** defaults to text */\n    DEFAULT:    'text',\n    /** ArrayBuffer */\n    BUFFER:     'arraybuffer',\n    /** Blob */\n    BLOB:       'blob',\n    /** Document */\n    DOCUMENT:   'document',\n    /** Object */\n    JSON:       'json',\n    /** String */\n    TEXT:       'text'\n};\n\nResource._loadTypeMap = {\n    gif:      Resource.LOAD_TYPE.IMAGE,\n    png:      Resource.LOAD_TYPE.IMAGE,\n    bmp:      Resource.LOAD_TYPE.IMAGE,\n    jpg:      Resource.LOAD_TYPE.IMAGE,\n    jpeg:     Resource.LOAD_TYPE.IMAGE,\n    tif:      Resource.LOAD_TYPE.IMAGE,\n    tiff:     Resource.LOAD_TYPE.IMAGE,\n    webp:     Resource.LOAD_TYPE.IMAGE,\n    tga:      Resource.LOAD_TYPE.IMAGE,\n    'svg+xml':  Resource.LOAD_TYPE.IMAGE\n};\n\nResource._xhrTypeMap = {\n    // xml\n    xhtml:    Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    html:     Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    htm:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    xml:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tmx:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    tsx:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n    svg:      Resource.XHR_RESPONSE_TYPE.DOCUMENT,\n\n    // images\n    gif:      Resource.XHR_RESPONSE_TYPE.BLOB,\n    png:      Resource.XHR_RESPONSE_TYPE.BLOB,\n    bmp:      Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpg:      Resource.XHR_RESPONSE_TYPE.BLOB,\n    jpeg:     Resource.XHR_RESPONSE_TYPE.BLOB,\n    tif:      Resource.XHR_RESPONSE_TYPE.BLOB,\n    tiff:     Resource.XHR_RESPONSE_TYPE.BLOB,\n    webp:     Resource.XHR_RESPONSE_TYPE.BLOB,\n    tga:      Resource.XHR_RESPONSE_TYPE.BLOB,\n\n    // json\n    json:     Resource.XHR_RESPONSE_TYPE.JSON,\n\n    // text\n    text:     Resource.XHR_RESPONSE_TYPE.TEXT,\n    txt:      Resource.XHR_RESPONSE_TYPE.TEXT\n};\n\n/**\n * Sets the load type to be used for a specific extension.\n *\n * @static\n * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n * @param {Resource.LOAD_TYPE} loadType - The load type to set it to.\n */\nResource.setExtensionLoadType = function (extname, loadType) {\n    setExtMap(Resource._loadTypeMap, extname, loadType);\n};\n\n/**\n * Sets the load type to be used for a specific extension.\n *\n * @static\n * @param {string} extname - The extension to set the type for, e.g. \"png\" or \"fnt\"\n * @param {Resource.XHR_RESPONSE_TYPE} xhrType - The xhr type to set it to.\n */\nResource.setExtensionXhrType = function (extname, xhrType) {\n    setExtMap(Resource._xhrTypeMap, extname, xhrType);\n};\n\nfunction setExtMap(map, extname, val) {\n    if (extname && extname.indexOf('.') === 0) {\n        extname = extname.substring(1);\n    }\n\n    if (!extname) {\n        return;\n    }\n\n    map[extname] = val;\n}\n"]},"metadata":{},"sourceType":"script"}